{"ast":null,"code":"//     (c) 2012-2018 Airbnb, Inc.\n//\n//     polyglot.js may be freely distributed under the terms of the BSD\n//     license. For all licensing information, details, and documentation:\n//     http://airbnb.github.com/polyglot.js\n//\n//\n// Polyglot.js is an I18n helper library written in JavaScript, made to\n// work both in the browser and in Node. It provides a simple solution for\n// interpolation and pluralization, based off of Airbnb's\n// experience adding I18n functionality to its Backbone.js and Node apps.\n//\n// Polylglot is agnostic to your translation backend. It doesn't perform any\n// translation; it simply gives you a way to manage translated phrases from\n// your client- or server-side JavaScript application.\n//\n\n'use strict';\n\nvar forEach = require('array.prototype.foreach');\nvar entries = require('object.entries');\nvar warning = require('warning');\nvar has = require('has');\nvar trim = require('string.prototype.trim');\nvar warn = function warn(message) {\n  warning(false, message);\n};\nvar replace = String.prototype.replace;\nvar split = String.prototype.split;\n\n// #### Pluralization methods\n// The string that separates the different phrase possibilities.\nvar delimiter = '||||';\nvar russianPluralGroups = function (n) {\n  var lastTwo = n % 100;\n  var end = lastTwo % 10;\n  if (lastTwo !== 11 && end === 1) {\n    return 0;\n  }\n  if (2 <= end && end <= 4 && !(lastTwo >= 12 && lastTwo <= 14)) {\n    return 1;\n  }\n  return 2;\n};\nvar defaultPluralRules = {\n  // Mapping from pluralization group plural logic.\n  pluralTypes: {\n    arabic: function (n) {\n      // http://www.arabeyes.org/Plural_Forms\n      if (n < 3) {\n        return n;\n      }\n      var lastTwo = n % 100;\n      if (lastTwo >= 3 && lastTwo <= 10) return 3;\n      return lastTwo >= 11 ? 4 : 5;\n    },\n    bosnian_serbian: russianPluralGroups,\n    chinese: function () {\n      return 0;\n    },\n    croatian: russianPluralGroups,\n    french: function (n) {\n      return n >= 2 ? 1 : 0;\n    },\n    german: function (n) {\n      return n !== 1 ? 1 : 0;\n    },\n    russian: russianPluralGroups,\n    lithuanian: function (n) {\n      if (n % 10 === 1 && n % 100 !== 11) {\n        return 0;\n      }\n      return n % 10 >= 2 && n % 10 <= 9 && (n % 100 < 11 || n % 100 > 19) ? 1 : 2;\n    },\n    czech: function (n) {\n      if (n === 1) {\n        return 0;\n      }\n      return n >= 2 && n <= 4 ? 1 : 2;\n    },\n    polish: function (n) {\n      if (n === 1) {\n        return 0;\n      }\n      var end = n % 10;\n      return 2 <= end && end <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n    },\n    icelandic: function (n) {\n      return n % 10 !== 1 || n % 100 === 11 ? 1 : 0;\n    },\n    slovenian: function (n) {\n      var lastTwo = n % 100;\n      if (lastTwo === 1) {\n        return 0;\n      }\n      if (lastTwo === 2) {\n        return 1;\n      }\n      if (lastTwo === 3 || lastTwo === 4) {\n        return 2;\n      }\n      return 3;\n    }\n  },\n  // Mapping from pluralization group to individual language codes/locales.\n  // Will look up based on exact match, if not found and it's a locale will parse the locale\n  // for language code, and if that does not exist will default to 'en'\n  pluralTypeToLanguages: {\n    arabic: ['ar'],\n    bosnian_serbian: ['bs-Latn-BA', 'bs-Cyrl-BA', 'srl-RS', 'sr-RS'],\n    chinese: ['id', 'id-ID', 'ja', 'ko', 'ko-KR', 'lo', 'ms', 'th', 'th-TH', 'zh'],\n    croatian: ['hr', 'hr-HR'],\n    german: ['fa', 'da', 'de', 'en', 'es', 'fi', 'el', 'he', 'hi-IN', 'hu', 'hu-HU', 'it', 'nl', 'no', 'pt', 'sv', 'tr'],\n    french: ['fr', 'tl', 'pt-br'],\n    russian: ['ru', 'ru-RU'],\n    lithuanian: ['lt'],\n    czech: ['cs', 'cs-CZ', 'sk'],\n    polish: ['pl'],\n    icelandic: ['is'],\n    slovenian: ['sl-SL']\n  }\n};\nfunction langToTypeMap(mapping) {\n  var ret = {};\n  forEach(entries(mapping), function (entry) {\n    var type = entry[0];\n    var langs = entry[1];\n    forEach(langs, function (lang) {\n      ret[lang] = type;\n    });\n  });\n  return ret;\n}\nfunction pluralTypeName(pluralRules, locale) {\n  var langToPluralType = langToTypeMap(pluralRules.pluralTypeToLanguages);\n  return langToPluralType[locale] || langToPluralType[split.call(locale, /-/, 1)[0]] || langToPluralType.en;\n}\nfunction pluralTypeIndex(pluralRules, pluralType, count) {\n  return pluralRules.pluralTypes[pluralType](count);\n}\nfunction createMemoizedPluralTypeNameSelector() {\n  var localePluralTypeStorage = {};\n  return function (pluralRules, locale) {\n    var pluralType = localePluralTypeStorage[locale];\n    if (pluralType && !pluralRules.pluralTypes[pluralType]) {\n      pluralType = null;\n      localePluralTypeStorage[locale] = pluralType;\n    }\n    if (!pluralType) {\n      pluralType = pluralTypeName(pluralRules, locale);\n      if (pluralType) {\n        localePluralTypeStorage[locale] = pluralType;\n      }\n    }\n    return pluralType;\n  };\n}\nfunction escape(token) {\n  return token.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction constructTokenRegex(opts) {\n  var prefix = opts && opts.prefix || '%{';\n  var suffix = opts && opts.suffix || '}';\n  if (prefix === delimiter || suffix === delimiter) {\n    throw new RangeError('\"' + delimiter + '\" token is reserved for pluralization');\n  }\n  return new RegExp(escape(prefix) + '(.*?)' + escape(suffix), 'g');\n}\nvar memoizedPluralTypeName = createMemoizedPluralTypeNameSelector();\nvar defaultTokenRegex = /%\\{(.*?)\\}/g;\n\n// ### transformPhrase(phrase, substitutions, locale)\n//\n// Takes a phrase string and transforms it by choosing the correct\n// plural form and interpolating it.\n//\n//     transformPhrase('Hello, %{name}!', {name: 'Spike'});\n//     // \"Hello, Spike!\"\n//\n// The correct plural form is selected if substitutions.smart_count\n// is set. You can pass in a number instead of an Object as `substitutions`\n// as a shortcut for `smart_count`.\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 1}, 'en');\n//     // \"1 new message\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 2}, 'en');\n//     // \"2 new messages\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', 5, 'en');\n//     // \"5 new messages\"\n//\n// You should pass in a third argument, the locale, to specify the correct plural type.\n// It defaults to `'en'` with 2 plural forms.\nfunction transformPhrase(phrase, substitutions, locale, tokenRegex, pluralRules) {\n  if (typeof phrase !== 'string') {\n    throw new TypeError('Polyglot.transformPhrase expects argument #1 to be string');\n  }\n  if (substitutions == null) {\n    return phrase;\n  }\n  var result = phrase;\n  var interpolationRegex = tokenRegex || defaultTokenRegex;\n\n  // allow number as a pluralization shortcut\n  var options = typeof substitutions === 'number' ? {\n    smart_count: substitutions\n  } : substitutions;\n\n  // Select plural form: based on a phrase text that contains `n`\n  // plural forms separated by `delimiter`, a `locale`, and a `substitutions.smart_count`,\n  // choose the correct plural form. This is only done if `count` is set.\n  if (options.smart_count != null && phrase) {\n    var pluralRulesOrDefault = pluralRules || defaultPluralRules;\n    var texts = split.call(phrase, delimiter);\n    var bestLocale = locale || 'en';\n    var pluralType = memoizedPluralTypeName(pluralRulesOrDefault, bestLocale);\n    var pluralTypeWithCount = pluralTypeIndex(pluralRulesOrDefault, pluralType, options.smart_count);\n    result = trim(texts[pluralTypeWithCount] || texts[0]);\n  }\n\n  // Interpolate: Creates a `RegExp` object for each interpolation placeholder.\n  result = replace.call(result, interpolationRegex, function (expression, argument) {\n    if (!has(options, argument) || options[argument] == null) {\n      return expression;\n    }\n    return options[argument];\n  });\n  return result;\n}\n\n// ### Polyglot class constructor\nfunction Polyglot(options) {\n  var opts = options || {};\n  this.phrases = {};\n  this.extend(opts.phrases || {});\n  this.currentLocale = opts.locale || 'en';\n  var allowMissing = opts.allowMissing ? transformPhrase : null;\n  this.onMissingKey = typeof opts.onMissingKey === 'function' ? opts.onMissingKey : allowMissing;\n  this.warn = opts.warn || warn;\n  this.tokenRegex = constructTokenRegex(opts.interpolation);\n  this.pluralRules = opts.pluralRules || defaultPluralRules;\n}\n\n// ### polyglot.locale([locale])\n//\n// Get or set locale. Internally, Polyglot only uses locale for pluralization.\nPolyglot.prototype.locale = function (newLocale) {\n  if (newLocale) this.currentLocale = newLocale;\n  return this.currentLocale;\n};\n\n// ### polyglot.extend(phrases)\n//\n// Use `extend` to tell Polyglot how to translate a given key.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The key can be any string.  Feel free to call `extend` multiple times;\n// it will override any phrases with the same key, but leave existing phrases\n// untouched.\n//\n// It is also possible to pass nested phrase objects, which get flattened\n// into an object with the nested keys concatenated using dot notation.\n//\n//     polyglot.extend({\n//       \"nav\": {\n//         \"hello\": \"Hello\",\n//         \"hello_name\": \"Hello, %{name}\",\n//         \"sidebar\": {\n//           \"welcome\": \"Welcome\"\n//         }\n//       }\n//     });\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}',\n//     //   'nav.sidebar.welcome': 'Welcome'\n//     // }\n//\n// `extend` accepts an optional second argument, `prefix`, which can be used\n// to prefix every key in the phrases object with some string, using dot\n// notation.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     }, \"nav\");\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}'\n//     // }\n//\n// This feature is used internally to support nested phrase objects.\nPolyglot.prototype.extend = function (morePhrases, prefix) {\n  forEach(entries(morePhrases || {}), function (entry) {\n    var key = entry[0];\n    var phrase = entry[1];\n    var prefixedKey = prefix ? prefix + '.' + key : key;\n    if (typeof phrase === 'object') {\n      this.extend(phrase, prefixedKey);\n    } else {\n      this.phrases[prefixedKey] = phrase;\n    }\n  }, this);\n};\n\n// ### polyglot.unset(phrases)\n// Use `unset` to selectively remove keys from a polyglot instance.\n//\n//     polyglot.unset(\"some_key\");\n//     polyglot.unset({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The unset method can take either a string (for the key), or an object hash with\n// the keys that you would like to unset.\nPolyglot.prototype.unset = function (morePhrases, prefix) {\n  if (typeof morePhrases === 'string') {\n    delete this.phrases[morePhrases];\n  } else {\n    forEach(entries(morePhrases || {}), function (entry) {\n      var key = entry[0];\n      var phrase = entry[1];\n      var prefixedKey = prefix ? prefix + '.' + key : key;\n      if (typeof phrase === 'object') {\n        this.unset(phrase, prefixedKey);\n      } else {\n        delete this.phrases[prefixedKey];\n      }\n    }, this);\n  }\n};\n\n// ### polyglot.clear()\n//\n// Clears all phrases. Useful for special cases, such as freeing\n// up memory if you have lots of phrases but no longer need to\n// perform any translation. Also used internally by `replace`.\nPolyglot.prototype.clear = function () {\n  this.phrases = {};\n};\n\n// ### polyglot.replace(phrases)\n//\n// Completely replace the existing phrases with a new set of phrases.\n// Normally, just use `extend` to add more phrases, but under certain\n// circumstances, you may want to make sure no old phrases are lying around.\nPolyglot.prototype.replace = function (newPhrases) {\n  this.clear();\n  this.extend(newPhrases);\n};\n\n// ### polyglot.t(key, options)\n//\n// The most-used method. Provide a key, and `t` will return the\n// phrase.\n//\n//     polyglot.t(\"hello\");\n//     => \"Hello\"\n//\n// The phrase value is provided first by a call to `polyglot.extend()` or\n// `polyglot.replace()`.\n//\n// Pass in an object as the second argument to perform interpolation.\n//\n//     polyglot.t(\"hello_name\", {name: \"Spike\"});\n//     => \"Hello, Spike\"\n//\n// If you like, you can provide a default value in case the phrase is missing.\n// Use the special option key \"_\" to specify a default.\n//\n//     polyglot.t(\"i_like_to_write_in_language\", {\n//       _: \"I like to write in %{language}.\",\n//       language: \"JavaScript\"\n//     });\n//     => \"I like to write in JavaScript.\"\n//\nPolyglot.prototype.t = function (key, options) {\n  var phrase, result;\n  var opts = options == null ? {} : options;\n  if (typeof this.phrases[key] === 'string') {\n    phrase = this.phrases[key];\n  } else if (typeof opts._ === 'string') {\n    phrase = opts._;\n  } else if (this.onMissingKey) {\n    var onMissingKey = this.onMissingKey;\n    result = onMissingKey(key, opts, this.currentLocale, this.tokenRegex, this.pluralRules);\n  } else {\n    this.warn('Missing translation for key: \"' + key + '\"');\n    result = key;\n  }\n  if (typeof phrase === 'string') {\n    result = transformPhrase(phrase, opts, this.currentLocale, this.tokenRegex, this.pluralRules);\n  }\n  return result;\n};\n\n// ### polyglot.has(key)\n//\n// Check if polyglot has a translation for given key\nPolyglot.prototype.has = function (key) {\n  return has(this.phrases, key);\n};\n\n// export transformPhrase\nPolyglot.transformPhrase = function transform(phrase, substitutions, locale) {\n  return transformPhrase(phrase, substitutions, locale);\n};\nmodule.exports = Polyglot;","map":{"version":3,"names":["forEach","require","entries","warning","has","trim","warn","message","replace","String","prototype","split","delimiter","russianPluralGroups","n","lastTwo","end","defaultPluralRules","pluralTypes","arabic","bosnian_serbian","chinese","croatian","french","german","russian","lithuanian","czech","polish","icelandic","slovenian","pluralTypeToLanguages","langToTypeMap","mapping","ret","entry","type","langs","lang","pluralTypeName","pluralRules","locale","langToPluralType","call","en","pluralTypeIndex","pluralType","count","createMemoizedPluralTypeNameSelector","localePluralTypeStorage","escape","token","constructTokenRegex","opts","prefix","suffix","RangeError","RegExp","memoizedPluralTypeName","defaultTokenRegex","transformPhrase","phrase","substitutions","tokenRegex","TypeError","result","interpolationRegex","options","smart_count","pluralRulesOrDefault","texts","bestLocale","pluralTypeWithCount","expression","argument","Polyglot","phrases","extend","currentLocale","allowMissing","onMissingKey","interpolation","newLocale","morePhrases","key","prefixedKey","unset","clear","newPhrases","t","_","transform","module","exports"],"sources":["/Users/paigedeveau/Desktop/se-diva-docs-frontend/bwmdn-admin-portal/node_modules/node-polyglot/index.js"],"sourcesContent":["//     (c) 2012-2018 Airbnb, Inc.\n//\n//     polyglot.js may be freely distributed under the terms of the BSD\n//     license. For all licensing information, details, and documentation:\n//     http://airbnb.github.com/polyglot.js\n//\n//\n// Polyglot.js is an I18n helper library written in JavaScript, made to\n// work both in the browser and in Node. It provides a simple solution for\n// interpolation and pluralization, based off of Airbnb's\n// experience adding I18n functionality to its Backbone.js and Node apps.\n//\n// Polylglot is agnostic to your translation backend. It doesn't perform any\n// translation; it simply gives you a way to manage translated phrases from\n// your client- or server-side JavaScript application.\n//\n\n'use strict';\n\nvar forEach = require('array.prototype.foreach');\nvar entries = require('object.entries');\nvar warning = require('warning');\nvar has = require('has');\nvar trim = require('string.prototype.trim');\n\nvar warn = function warn(message) {\n  warning(false, message);\n};\n\nvar replace = String.prototype.replace;\nvar split = String.prototype.split;\n\n// #### Pluralization methods\n// The string that separates the different phrase possibilities.\nvar delimiter = '||||';\n\nvar russianPluralGroups = function (n) {\n  var lastTwo = n % 100;\n  var end = lastTwo % 10;\n  if (lastTwo !== 11 && end === 1) {\n    return 0;\n  }\n  if (2 <= end && end <= 4 && !(lastTwo >= 12 && lastTwo <= 14)) {\n    return 1;\n  }\n  return 2;\n};\n\nvar defaultPluralRules = {\n  // Mapping from pluralization group plural logic.\n  pluralTypes: {\n    arabic: function (n) {\n      // http://www.arabeyes.org/Plural_Forms\n      if (n < 3) { return n; }\n      var lastTwo = n % 100;\n      if (lastTwo >= 3 && lastTwo <= 10) return 3;\n      return lastTwo >= 11 ? 4 : 5;\n    },\n    bosnian_serbian: russianPluralGroups,\n    chinese: function () { return 0; },\n    croatian: russianPluralGroups,\n    french: function (n) { return n >= 2 ? 1 : 0; },\n    german: function (n) { return n !== 1 ? 1 : 0; },\n    russian: russianPluralGroups,\n    lithuanian: function (n) {\n      if (n % 10 === 1 && n % 100 !== 11) { return 0; }\n      return n % 10 >= 2 && n % 10 <= 9 && (n % 100 < 11 || n % 100 > 19) ? 1 : 2;\n    },\n    czech: function (n) {\n      if (n === 1) { return 0; }\n      return (n >= 2 && n <= 4) ? 1 : 2;\n    },\n    polish: function (n) {\n      if (n === 1) { return 0; }\n      var end = n % 10;\n      return 2 <= end && end <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n    },\n    icelandic: function (n) { return (n % 10 !== 1 || n % 100 === 11) ? 1 : 0; },\n    slovenian: function (n) {\n      var lastTwo = n % 100;\n      if (lastTwo === 1) {\n        return 0;\n      }\n      if (lastTwo === 2) {\n        return 1;\n      }\n      if (lastTwo === 3 || lastTwo === 4) {\n        return 2;\n      }\n      return 3;\n    }\n  },\n\n  // Mapping from pluralization group to individual language codes/locales.\n  // Will look up based on exact match, if not found and it's a locale will parse the locale\n  // for language code, and if that does not exist will default to 'en'\n  pluralTypeToLanguages: {\n    arabic: ['ar'],\n    bosnian_serbian: ['bs-Latn-BA', 'bs-Cyrl-BA', 'srl-RS', 'sr-RS'],\n    chinese: ['id', 'id-ID', 'ja', 'ko', 'ko-KR', 'lo', 'ms', 'th', 'th-TH', 'zh'],\n    croatian: ['hr', 'hr-HR'],\n    german: ['fa', 'da', 'de', 'en', 'es', 'fi', 'el', 'he', 'hi-IN', 'hu', 'hu-HU', 'it', 'nl', 'no', 'pt', 'sv', 'tr'],\n    french: ['fr', 'tl', 'pt-br'],\n    russian: ['ru', 'ru-RU'],\n    lithuanian: ['lt'],\n    czech: ['cs', 'cs-CZ', 'sk'],\n    polish: ['pl'],\n    icelandic: ['is'],\n    slovenian: ['sl-SL']\n  }\n};\n\nfunction langToTypeMap(mapping) {\n  var ret = {};\n  forEach(entries(mapping), function (entry) {\n    var type = entry[0];\n    var langs = entry[1];\n    forEach(langs, function (lang) {\n      ret[lang] = type;\n    });\n  });\n  return ret;\n}\n\nfunction pluralTypeName(pluralRules, locale) {\n  var langToPluralType = langToTypeMap(pluralRules.pluralTypeToLanguages);\n  return langToPluralType[locale]\n    || langToPluralType[split.call(locale, /-/, 1)[0]]\n    || langToPluralType.en;\n}\n\nfunction pluralTypeIndex(pluralRules, pluralType, count) {\n  return pluralRules.pluralTypes[pluralType](count);\n}\n\nfunction createMemoizedPluralTypeNameSelector() {\n  var localePluralTypeStorage = {};\n\n  return function (pluralRules, locale) {\n    var pluralType = localePluralTypeStorage[locale];\n\n    if (pluralType && !pluralRules.pluralTypes[pluralType]) {\n      pluralType = null;\n      localePluralTypeStorage[locale] = pluralType;\n    }\n\n    if (!pluralType) {\n      pluralType = pluralTypeName(pluralRules, locale);\n\n      if (pluralType) {\n        localePluralTypeStorage[locale] = pluralType;\n      }\n    }\n\n    return pluralType;\n  };\n}\n\nfunction escape(token) {\n  return token.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction constructTokenRegex(opts) {\n  var prefix = (opts && opts.prefix) || '%{';\n  var suffix = (opts && opts.suffix) || '}';\n\n  if (prefix === delimiter || suffix === delimiter) {\n    throw new RangeError('\"' + delimiter + '\" token is reserved for pluralization');\n  }\n\n  return new RegExp(escape(prefix) + '(.*?)' + escape(suffix), 'g');\n}\n\nvar memoizedPluralTypeName = createMemoizedPluralTypeNameSelector();\n\nvar defaultTokenRegex = /%\\{(.*?)\\}/g;\n\n// ### transformPhrase(phrase, substitutions, locale)\n//\n// Takes a phrase string and transforms it by choosing the correct\n// plural form and interpolating it.\n//\n//     transformPhrase('Hello, %{name}!', {name: 'Spike'});\n//     // \"Hello, Spike!\"\n//\n// The correct plural form is selected if substitutions.smart_count\n// is set. You can pass in a number instead of an Object as `substitutions`\n// as a shortcut for `smart_count`.\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 1}, 'en');\n//     // \"1 new message\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 2}, 'en');\n//     // \"2 new messages\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', 5, 'en');\n//     // \"5 new messages\"\n//\n// You should pass in a third argument, the locale, to specify the correct plural type.\n// It defaults to `'en'` with 2 plural forms.\nfunction transformPhrase(phrase, substitutions, locale, tokenRegex, pluralRules) {\n  if (typeof phrase !== 'string') {\n    throw new TypeError('Polyglot.transformPhrase expects argument #1 to be string');\n  }\n\n  if (substitutions == null) {\n    return phrase;\n  }\n\n  var result = phrase;\n  var interpolationRegex = tokenRegex || defaultTokenRegex;\n\n  // allow number as a pluralization shortcut\n  var options = typeof substitutions === 'number' ? { smart_count: substitutions } : substitutions;\n\n  // Select plural form: based on a phrase text that contains `n`\n  // plural forms separated by `delimiter`, a `locale`, and a `substitutions.smart_count`,\n  // choose the correct plural form. This is only done if `count` is set.\n  if (options.smart_count != null && phrase) {\n    var pluralRulesOrDefault = pluralRules || defaultPluralRules;\n    var texts = split.call(phrase, delimiter);\n    var bestLocale = locale || 'en';\n    var pluralType = memoizedPluralTypeName(pluralRulesOrDefault, bestLocale);\n    var pluralTypeWithCount = pluralTypeIndex(\n      pluralRulesOrDefault,\n      pluralType,\n      options.smart_count\n    );\n\n    result = trim(texts[pluralTypeWithCount] || texts[0]);\n  }\n\n  // Interpolate: Creates a `RegExp` object for each interpolation placeholder.\n  result = replace.call(result, interpolationRegex, function (expression, argument) {\n    if (!has(options, argument) || options[argument] == null) { return expression; }\n    return options[argument];\n  });\n\n  return result;\n}\n\n// ### Polyglot class constructor\nfunction Polyglot(options) {\n  var opts = options || {};\n  this.phrases = {};\n  this.extend(opts.phrases || {});\n  this.currentLocale = opts.locale || 'en';\n  var allowMissing = opts.allowMissing ? transformPhrase : null;\n  this.onMissingKey = typeof opts.onMissingKey === 'function' ? opts.onMissingKey : allowMissing;\n  this.warn = opts.warn || warn;\n  this.tokenRegex = constructTokenRegex(opts.interpolation);\n  this.pluralRules = opts.pluralRules || defaultPluralRules;\n}\n\n// ### polyglot.locale([locale])\n//\n// Get or set locale. Internally, Polyglot only uses locale for pluralization.\nPolyglot.prototype.locale = function (newLocale) {\n  if (newLocale) this.currentLocale = newLocale;\n  return this.currentLocale;\n};\n\n// ### polyglot.extend(phrases)\n//\n// Use `extend` to tell Polyglot how to translate a given key.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The key can be any string.  Feel free to call `extend` multiple times;\n// it will override any phrases with the same key, but leave existing phrases\n// untouched.\n//\n// It is also possible to pass nested phrase objects, which get flattened\n// into an object with the nested keys concatenated using dot notation.\n//\n//     polyglot.extend({\n//       \"nav\": {\n//         \"hello\": \"Hello\",\n//         \"hello_name\": \"Hello, %{name}\",\n//         \"sidebar\": {\n//           \"welcome\": \"Welcome\"\n//         }\n//       }\n//     });\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}',\n//     //   'nav.sidebar.welcome': 'Welcome'\n//     // }\n//\n// `extend` accepts an optional second argument, `prefix`, which can be used\n// to prefix every key in the phrases object with some string, using dot\n// notation.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     }, \"nav\");\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}'\n//     // }\n//\n// This feature is used internally to support nested phrase objects.\nPolyglot.prototype.extend = function (morePhrases, prefix) {\n  forEach(entries(morePhrases || {}), function (entry) {\n    var key = entry[0];\n    var phrase = entry[1];\n    var prefixedKey = prefix ? prefix + '.' + key : key;\n    if (typeof phrase === 'object') {\n      this.extend(phrase, prefixedKey);\n    } else {\n      this.phrases[prefixedKey] = phrase;\n    }\n  }, this);\n};\n\n// ### polyglot.unset(phrases)\n// Use `unset` to selectively remove keys from a polyglot instance.\n//\n//     polyglot.unset(\"some_key\");\n//     polyglot.unset({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The unset method can take either a string (for the key), or an object hash with\n// the keys that you would like to unset.\nPolyglot.prototype.unset = function (morePhrases, prefix) {\n  if (typeof morePhrases === 'string') {\n    delete this.phrases[morePhrases];\n  } else {\n    forEach(entries(morePhrases || {}), function (entry) {\n      var key = entry[0];\n      var phrase = entry[1];\n      var prefixedKey = prefix ? prefix + '.' + key : key;\n      if (typeof phrase === 'object') {\n        this.unset(phrase, prefixedKey);\n      } else {\n        delete this.phrases[prefixedKey];\n      }\n    }, this);\n  }\n};\n\n// ### polyglot.clear()\n//\n// Clears all phrases. Useful for special cases, such as freeing\n// up memory if you have lots of phrases but no longer need to\n// perform any translation. Also used internally by `replace`.\nPolyglot.prototype.clear = function () {\n  this.phrases = {};\n};\n\n// ### polyglot.replace(phrases)\n//\n// Completely replace the existing phrases with a new set of phrases.\n// Normally, just use `extend` to add more phrases, but under certain\n// circumstances, you may want to make sure no old phrases are lying around.\nPolyglot.prototype.replace = function (newPhrases) {\n  this.clear();\n  this.extend(newPhrases);\n};\n\n// ### polyglot.t(key, options)\n//\n// The most-used method. Provide a key, and `t` will return the\n// phrase.\n//\n//     polyglot.t(\"hello\");\n//     => \"Hello\"\n//\n// The phrase value is provided first by a call to `polyglot.extend()` or\n// `polyglot.replace()`.\n//\n// Pass in an object as the second argument to perform interpolation.\n//\n//     polyglot.t(\"hello_name\", {name: \"Spike\"});\n//     => \"Hello, Spike\"\n//\n// If you like, you can provide a default value in case the phrase is missing.\n// Use the special option key \"_\" to specify a default.\n//\n//     polyglot.t(\"i_like_to_write_in_language\", {\n//       _: \"I like to write in %{language}.\",\n//       language: \"JavaScript\"\n//     });\n//     => \"I like to write in JavaScript.\"\n//\nPolyglot.prototype.t = function (key, options) {\n  var phrase, result;\n  var opts = options == null ? {} : options;\n  if (typeof this.phrases[key] === 'string') {\n    phrase = this.phrases[key];\n  } else if (typeof opts._ === 'string') {\n    phrase = opts._;\n  } else if (this.onMissingKey) {\n    var onMissingKey = this.onMissingKey;\n    result = onMissingKey(key, opts, this.currentLocale, this.tokenRegex, this.pluralRules);\n  } else {\n    this.warn('Missing translation for key: \"' + key + '\"');\n    result = key;\n  }\n  if (typeof phrase === 'string') {\n    result = transformPhrase(phrase, opts, this.currentLocale, this.tokenRegex, this.pluralRules);\n  }\n  return result;\n};\n\n// ### polyglot.has(key)\n//\n// Check if polyglot has a translation for given key\nPolyglot.prototype.has = function (key) {\n  return has(this.phrases, key);\n};\n\n// export transformPhrase\nPolyglot.transformPhrase = function transform(phrase, substitutions, locale) {\n  return transformPhrase(phrase, substitutions, locale);\n};\n\nmodule.exports = Polyglot;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,IAAIA,OAAO,GAAGC,OAAO,CAAC,yBAAyB,CAAC;AAChD,IAAIC,OAAO,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AACvC,IAAIE,OAAO,GAAGF,OAAO,CAAC,SAAS,CAAC;AAChC,IAAIG,GAAG,GAAGH,OAAO,CAAC,KAAK,CAAC;AACxB,IAAII,IAAI,GAAGJ,OAAO,CAAC,uBAAuB,CAAC;AAE3C,IAAIK,IAAI,GAAG,SAASA,IAAI,CAACC,OAAO,EAAE;EAChCJ,OAAO,CAAC,KAAK,EAAEI,OAAO,CAAC;AACzB,CAAC;AAED,IAAIC,OAAO,GAAGC,MAAM,CAACC,SAAS,CAACF,OAAO;AACtC,IAAIG,KAAK,GAAGF,MAAM,CAACC,SAAS,CAACC,KAAK;;AAElC;AACA;AACA,IAAIC,SAAS,GAAG,MAAM;AAEtB,IAAIC,mBAAmB,GAAG,UAAUC,CAAC,EAAE;EACrC,IAAIC,OAAO,GAAGD,CAAC,GAAG,GAAG;EACrB,IAAIE,GAAG,GAAGD,OAAO,GAAG,EAAE;EACtB,IAAIA,OAAO,KAAK,EAAE,IAAIC,GAAG,KAAK,CAAC,EAAE;IAC/B,OAAO,CAAC;EACV;EACA,IAAI,CAAC,IAAIA,GAAG,IAAIA,GAAG,IAAI,CAAC,IAAI,EAAED,OAAO,IAAI,EAAE,IAAIA,OAAO,IAAI,EAAE,CAAC,EAAE;IAC7D,OAAO,CAAC;EACV;EACA,OAAO,CAAC;AACV,CAAC;AAED,IAAIE,kBAAkB,GAAG;EACvB;EACAC,WAAW,EAAE;IACXC,MAAM,EAAE,UAAUL,CAAC,EAAE;MACnB;MACA,IAAIA,CAAC,GAAG,CAAC,EAAE;QAAE,OAAOA,CAAC;MAAE;MACvB,IAAIC,OAAO,GAAGD,CAAC,GAAG,GAAG;MACrB,IAAIC,OAAO,IAAI,CAAC,IAAIA,OAAO,IAAI,EAAE,EAAE,OAAO,CAAC;MAC3C,OAAOA,OAAO,IAAI,EAAE,GAAG,CAAC,GAAG,CAAC;IAC9B,CAAC;IACDK,eAAe,EAAEP,mBAAmB;IACpCQ,OAAO,EAAE,YAAY;MAAE,OAAO,CAAC;IAAE,CAAC;IAClCC,QAAQ,EAAET,mBAAmB;IAC7BU,MAAM,EAAE,UAAUT,CAAC,EAAE;MAAE,OAAOA,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;IAAE,CAAC;IAC/CU,MAAM,EAAE,UAAUV,CAAC,EAAE;MAAE,OAAOA,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;IAAE,CAAC;IAChDW,OAAO,EAAEZ,mBAAmB;IAC5Ba,UAAU,EAAE,UAAUZ,CAAC,EAAE;MACvB,IAAIA,CAAC,GAAG,EAAE,KAAK,CAAC,IAAIA,CAAC,GAAG,GAAG,KAAK,EAAE,EAAE;QAAE,OAAO,CAAC;MAAE;MAChD,OAAOA,CAAC,GAAG,EAAE,IAAI,CAAC,IAAIA,CAAC,GAAG,EAAE,IAAI,CAAC,KAAKA,CAAC,GAAG,GAAG,GAAG,EAAE,IAAIA,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC;IAC7E,CAAC;IACDa,KAAK,EAAE,UAAUb,CAAC,EAAE;MAClB,IAAIA,CAAC,KAAK,CAAC,EAAE;QAAE,OAAO,CAAC;MAAE;MACzB,OAAQA,CAAC,IAAI,CAAC,IAAIA,CAAC,IAAI,CAAC,GAAI,CAAC,GAAG,CAAC;IACnC,CAAC;IACDc,MAAM,EAAE,UAAUd,CAAC,EAAE;MACnB,IAAIA,CAAC,KAAK,CAAC,EAAE;QAAE,OAAO,CAAC;MAAE;MACzB,IAAIE,GAAG,GAAGF,CAAC,GAAG,EAAE;MAChB,OAAO,CAAC,IAAIE,GAAG,IAAIA,GAAG,IAAI,CAAC,KAAKF,CAAC,GAAG,GAAG,GAAG,EAAE,IAAIA,CAAC,GAAG,GAAG,IAAI,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC;IACxE,CAAC;IACDe,SAAS,EAAE,UAAUf,CAAC,EAAE;MAAE,OAAQA,CAAC,GAAG,EAAE,KAAK,CAAC,IAAIA,CAAC,GAAG,GAAG,KAAK,EAAE,GAAI,CAAC,GAAG,CAAC;IAAE,CAAC;IAC5EgB,SAAS,EAAE,UAAUhB,CAAC,EAAE;MACtB,IAAIC,OAAO,GAAGD,CAAC,GAAG,GAAG;MACrB,IAAIC,OAAO,KAAK,CAAC,EAAE;QACjB,OAAO,CAAC;MACV;MACA,IAAIA,OAAO,KAAK,CAAC,EAAE;QACjB,OAAO,CAAC;MACV;MACA,IAAIA,OAAO,KAAK,CAAC,IAAIA,OAAO,KAAK,CAAC,EAAE;QAClC,OAAO,CAAC;MACV;MACA,OAAO,CAAC;IACV;EACF,CAAC;EAED;EACA;EACA;EACAgB,qBAAqB,EAAE;IACrBZ,MAAM,EAAE,CAAC,IAAI,CAAC;IACdC,eAAe,EAAE,CAAC,YAAY,EAAE,YAAY,EAAE,QAAQ,EAAE,OAAO,CAAC;IAChEC,OAAO,EAAE,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC;IAC9EC,QAAQ,EAAE,CAAC,IAAI,EAAE,OAAO,CAAC;IACzBE,MAAM,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IACpHD,MAAM,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC;IAC7BE,OAAO,EAAE,CAAC,IAAI,EAAE,OAAO,CAAC;IACxBC,UAAU,EAAE,CAAC,IAAI,CAAC;IAClBC,KAAK,EAAE,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC;IAC5BC,MAAM,EAAE,CAAC,IAAI,CAAC;IACdC,SAAS,EAAE,CAAC,IAAI,CAAC;IACjBC,SAAS,EAAE,CAAC,OAAO;EACrB;AACF,CAAC;AAED,SAASE,aAAa,CAACC,OAAO,EAAE;EAC9B,IAAIC,GAAG,GAAG,CAAC,CAAC;EACZlC,OAAO,CAACE,OAAO,CAAC+B,OAAO,CAAC,EAAE,UAAUE,KAAK,EAAE;IACzC,IAAIC,IAAI,GAAGD,KAAK,CAAC,CAAC,CAAC;IACnB,IAAIE,KAAK,GAAGF,KAAK,CAAC,CAAC,CAAC;IACpBnC,OAAO,CAACqC,KAAK,EAAE,UAAUC,IAAI,EAAE;MAC7BJ,GAAG,CAACI,IAAI,CAAC,GAAGF,IAAI;IAClB,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,OAAOF,GAAG;AACZ;AAEA,SAASK,cAAc,CAACC,WAAW,EAAEC,MAAM,EAAE;EAC3C,IAAIC,gBAAgB,GAAGV,aAAa,CAACQ,WAAW,CAACT,qBAAqB,CAAC;EACvE,OAAOW,gBAAgB,CAACD,MAAM,CAAC,IAC1BC,gBAAgB,CAAC/B,KAAK,CAACgC,IAAI,CAACF,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAC/CC,gBAAgB,CAACE,EAAE;AAC1B;AAEA,SAASC,eAAe,CAACL,WAAW,EAAEM,UAAU,EAAEC,KAAK,EAAE;EACvD,OAAOP,WAAW,CAACtB,WAAW,CAAC4B,UAAU,CAAC,CAACC,KAAK,CAAC;AACnD;AAEA,SAASC,oCAAoC,GAAG;EAC9C,IAAIC,uBAAuB,GAAG,CAAC,CAAC;EAEhC,OAAO,UAAUT,WAAW,EAAEC,MAAM,EAAE;IACpC,IAAIK,UAAU,GAAGG,uBAAuB,CAACR,MAAM,CAAC;IAEhD,IAAIK,UAAU,IAAI,CAACN,WAAW,CAACtB,WAAW,CAAC4B,UAAU,CAAC,EAAE;MACtDA,UAAU,GAAG,IAAI;MACjBG,uBAAuB,CAACR,MAAM,CAAC,GAAGK,UAAU;IAC9C;IAEA,IAAI,CAACA,UAAU,EAAE;MACfA,UAAU,GAAGP,cAAc,CAACC,WAAW,EAAEC,MAAM,CAAC;MAEhD,IAAIK,UAAU,EAAE;QACdG,uBAAuB,CAACR,MAAM,CAAC,GAAGK,UAAU;MAC9C;IACF;IAEA,OAAOA,UAAU;EACnB,CAAC;AACH;AAEA,SAASI,MAAM,CAACC,KAAK,EAAE;EACrB,OAAOA,KAAK,CAAC3C,OAAO,CAAC,qBAAqB,EAAE,MAAM,CAAC;AACrD;AAEA,SAAS4C,mBAAmB,CAACC,IAAI,EAAE;EACjC,IAAIC,MAAM,GAAID,IAAI,IAAIA,IAAI,CAACC,MAAM,IAAK,IAAI;EAC1C,IAAIC,MAAM,GAAIF,IAAI,IAAIA,IAAI,CAACE,MAAM,IAAK,GAAG;EAEzC,IAAID,MAAM,KAAK1C,SAAS,IAAI2C,MAAM,KAAK3C,SAAS,EAAE;IAChD,MAAM,IAAI4C,UAAU,CAAC,GAAG,GAAG5C,SAAS,GAAG,uCAAuC,CAAC;EACjF;EAEA,OAAO,IAAI6C,MAAM,CAACP,MAAM,CAACI,MAAM,CAAC,GAAG,OAAO,GAAGJ,MAAM,CAACK,MAAM,CAAC,EAAE,GAAG,CAAC;AACnE;AAEA,IAAIG,sBAAsB,GAAGV,oCAAoC,EAAE;AAEnE,IAAIW,iBAAiB,GAAG,aAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,eAAe,CAACC,MAAM,EAAEC,aAAa,EAAErB,MAAM,EAAEsB,UAAU,EAAEvB,WAAW,EAAE;EAC/E,IAAI,OAAOqB,MAAM,KAAK,QAAQ,EAAE;IAC9B,MAAM,IAAIG,SAAS,CAAC,2DAA2D,CAAC;EAClF;EAEA,IAAIF,aAAa,IAAI,IAAI,EAAE;IACzB,OAAOD,MAAM;EACf;EAEA,IAAII,MAAM,GAAGJ,MAAM;EACnB,IAAIK,kBAAkB,GAAGH,UAAU,IAAIJ,iBAAiB;;EAExD;EACA,IAAIQ,OAAO,GAAG,OAAOL,aAAa,KAAK,QAAQ,GAAG;IAAEM,WAAW,EAAEN;EAAc,CAAC,GAAGA,aAAa;;EAEhG;EACA;EACA;EACA,IAAIK,OAAO,CAACC,WAAW,IAAI,IAAI,IAAIP,MAAM,EAAE;IACzC,IAAIQ,oBAAoB,GAAG7B,WAAW,IAAIvB,kBAAkB;IAC5D,IAAIqD,KAAK,GAAG3D,KAAK,CAACgC,IAAI,CAACkB,MAAM,EAAEjD,SAAS,CAAC;IACzC,IAAI2D,UAAU,GAAG9B,MAAM,IAAI,IAAI;IAC/B,IAAIK,UAAU,GAAGY,sBAAsB,CAACW,oBAAoB,EAAEE,UAAU,CAAC;IACzE,IAAIC,mBAAmB,GAAG3B,eAAe,CACvCwB,oBAAoB,EACpBvB,UAAU,EACVqB,OAAO,CAACC,WAAW,CACpB;IAEDH,MAAM,GAAG5D,IAAI,CAACiE,KAAK,CAACE,mBAAmB,CAAC,IAAIF,KAAK,CAAC,CAAC,CAAC,CAAC;EACvD;;EAEA;EACAL,MAAM,GAAGzD,OAAO,CAACmC,IAAI,CAACsB,MAAM,EAAEC,kBAAkB,EAAE,UAAUO,UAAU,EAAEC,QAAQ,EAAE;IAChF,IAAI,CAACtE,GAAG,CAAC+D,OAAO,EAAEO,QAAQ,CAAC,IAAIP,OAAO,CAACO,QAAQ,CAAC,IAAI,IAAI,EAAE;MAAE,OAAOD,UAAU;IAAE;IAC/E,OAAON,OAAO,CAACO,QAAQ,CAAC;EAC1B,CAAC,CAAC;EAEF,OAAOT,MAAM;AACf;;AAEA;AACA,SAASU,QAAQ,CAACR,OAAO,EAAE;EACzB,IAAId,IAAI,GAAGc,OAAO,IAAI,CAAC,CAAC;EACxB,IAAI,CAACS,OAAO,GAAG,CAAC,CAAC;EACjB,IAAI,CAACC,MAAM,CAACxB,IAAI,CAACuB,OAAO,IAAI,CAAC,CAAC,CAAC;EAC/B,IAAI,CAACE,aAAa,GAAGzB,IAAI,CAACZ,MAAM,IAAI,IAAI;EACxC,IAAIsC,YAAY,GAAG1B,IAAI,CAAC0B,YAAY,GAAGnB,eAAe,GAAG,IAAI;EAC7D,IAAI,CAACoB,YAAY,GAAG,OAAO3B,IAAI,CAAC2B,YAAY,KAAK,UAAU,GAAG3B,IAAI,CAAC2B,YAAY,GAAGD,YAAY;EAC9F,IAAI,CAACzE,IAAI,GAAG+C,IAAI,CAAC/C,IAAI,IAAIA,IAAI;EAC7B,IAAI,CAACyD,UAAU,GAAGX,mBAAmB,CAACC,IAAI,CAAC4B,aAAa,CAAC;EACzD,IAAI,CAACzC,WAAW,GAAGa,IAAI,CAACb,WAAW,IAAIvB,kBAAkB;AAC3D;;AAEA;AACA;AACA;AACA0D,QAAQ,CAACjE,SAAS,CAAC+B,MAAM,GAAG,UAAUyC,SAAS,EAAE;EAC/C,IAAIA,SAAS,EAAE,IAAI,CAACJ,aAAa,GAAGI,SAAS;EAC7C,OAAO,IAAI,CAACJ,aAAa;AAC3B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,QAAQ,CAACjE,SAAS,CAACmE,MAAM,GAAG,UAAUM,WAAW,EAAE7B,MAAM,EAAE;EACzDtD,OAAO,CAACE,OAAO,CAACiF,WAAW,IAAI,CAAC,CAAC,CAAC,EAAE,UAAUhD,KAAK,EAAE;IACnD,IAAIiD,GAAG,GAAGjD,KAAK,CAAC,CAAC,CAAC;IAClB,IAAI0B,MAAM,GAAG1B,KAAK,CAAC,CAAC,CAAC;IACrB,IAAIkD,WAAW,GAAG/B,MAAM,GAAGA,MAAM,GAAG,GAAG,GAAG8B,GAAG,GAAGA,GAAG;IACnD,IAAI,OAAOvB,MAAM,KAAK,QAAQ,EAAE;MAC9B,IAAI,CAACgB,MAAM,CAAChB,MAAM,EAAEwB,WAAW,CAAC;IAClC,CAAC,MAAM;MACL,IAAI,CAACT,OAAO,CAACS,WAAW,CAAC,GAAGxB,MAAM;IACpC;EACF,CAAC,EAAE,IAAI,CAAC;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAc,QAAQ,CAACjE,SAAS,CAAC4E,KAAK,GAAG,UAAUH,WAAW,EAAE7B,MAAM,EAAE;EACxD,IAAI,OAAO6B,WAAW,KAAK,QAAQ,EAAE;IACnC,OAAO,IAAI,CAACP,OAAO,CAACO,WAAW,CAAC;EAClC,CAAC,MAAM;IACLnF,OAAO,CAACE,OAAO,CAACiF,WAAW,IAAI,CAAC,CAAC,CAAC,EAAE,UAAUhD,KAAK,EAAE;MACnD,IAAIiD,GAAG,GAAGjD,KAAK,CAAC,CAAC,CAAC;MAClB,IAAI0B,MAAM,GAAG1B,KAAK,CAAC,CAAC,CAAC;MACrB,IAAIkD,WAAW,GAAG/B,MAAM,GAAGA,MAAM,GAAG,GAAG,GAAG8B,GAAG,GAAGA,GAAG;MACnD,IAAI,OAAOvB,MAAM,KAAK,QAAQ,EAAE;QAC9B,IAAI,CAACyB,KAAK,CAACzB,MAAM,EAAEwB,WAAW,CAAC;MACjC,CAAC,MAAM;QACL,OAAO,IAAI,CAACT,OAAO,CAACS,WAAW,CAAC;MAClC;IACF,CAAC,EAAE,IAAI,CAAC;EACV;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAV,QAAQ,CAACjE,SAAS,CAAC6E,KAAK,GAAG,YAAY;EACrC,IAAI,CAACX,OAAO,GAAG,CAAC,CAAC;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAD,QAAQ,CAACjE,SAAS,CAACF,OAAO,GAAG,UAAUgF,UAAU,EAAE;EACjD,IAAI,CAACD,KAAK,EAAE;EACZ,IAAI,CAACV,MAAM,CAACW,UAAU,CAAC;AACzB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAb,QAAQ,CAACjE,SAAS,CAAC+E,CAAC,GAAG,UAAUL,GAAG,EAAEjB,OAAO,EAAE;EAC7C,IAAIN,MAAM,EAAEI,MAAM;EAClB,IAAIZ,IAAI,GAAGc,OAAO,IAAI,IAAI,GAAG,CAAC,CAAC,GAAGA,OAAO;EACzC,IAAI,OAAO,IAAI,CAACS,OAAO,CAACQ,GAAG,CAAC,KAAK,QAAQ,EAAE;IACzCvB,MAAM,GAAG,IAAI,CAACe,OAAO,CAACQ,GAAG,CAAC;EAC5B,CAAC,MAAM,IAAI,OAAO/B,IAAI,CAACqC,CAAC,KAAK,QAAQ,EAAE;IACrC7B,MAAM,GAAGR,IAAI,CAACqC,CAAC;EACjB,CAAC,MAAM,IAAI,IAAI,CAACV,YAAY,EAAE;IAC5B,IAAIA,YAAY,GAAG,IAAI,CAACA,YAAY;IACpCf,MAAM,GAAGe,YAAY,CAACI,GAAG,EAAE/B,IAAI,EAAE,IAAI,CAACyB,aAAa,EAAE,IAAI,CAACf,UAAU,EAAE,IAAI,CAACvB,WAAW,CAAC;EACzF,CAAC,MAAM;IACL,IAAI,CAAClC,IAAI,CAAC,gCAAgC,GAAG8E,GAAG,GAAG,GAAG,CAAC;IACvDnB,MAAM,GAAGmB,GAAG;EACd;EACA,IAAI,OAAOvB,MAAM,KAAK,QAAQ,EAAE;IAC9BI,MAAM,GAAGL,eAAe,CAACC,MAAM,EAAER,IAAI,EAAE,IAAI,CAACyB,aAAa,EAAE,IAAI,CAACf,UAAU,EAAE,IAAI,CAACvB,WAAW,CAAC;EAC/F;EACA,OAAOyB,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACAU,QAAQ,CAACjE,SAAS,CAACN,GAAG,GAAG,UAAUgF,GAAG,EAAE;EACtC,OAAOhF,GAAG,CAAC,IAAI,CAACwE,OAAO,EAAEQ,GAAG,CAAC;AAC/B,CAAC;;AAED;AACAT,QAAQ,CAACf,eAAe,GAAG,SAAS+B,SAAS,CAAC9B,MAAM,EAAEC,aAAa,EAAErB,MAAM,EAAE;EAC3E,OAAOmB,eAAe,CAACC,MAAM,EAAEC,aAAa,EAAErB,MAAM,CAAC;AACvD,CAAC;AAEDmD,MAAM,CAACC,OAAO,GAAGlB,QAAQ"},"metadata":{},"sourceType":"script"}