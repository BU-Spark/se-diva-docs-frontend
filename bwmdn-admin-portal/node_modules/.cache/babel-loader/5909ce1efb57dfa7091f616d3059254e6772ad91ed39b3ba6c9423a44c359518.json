{"ast":null,"code":"import { isMatch, isValid, parseISO } from 'date-fns';\nexport var isNumeric = function (value) {\n  return !isNaN(parseFloat(value)) && isFinite(value);\n};\nexport var valuesAreNumeric = function (values) {\n  return values.every(isNumeric);\n};\nexport var isInteger = function (value) {\n  return Number.isInteger(value) || !isNaN(parseInt(value));\n};\nexport var valuesAreInteger = function (values) {\n  return values.every(isInteger);\n};\nexport var isBoolean = function (value) {\n  return typeof value === 'boolean';\n};\nexport var valuesAreBoolean = function (values) {\n  return values.every(isBoolean);\n};\nexport var isBooleanString = function (value) {\n  return ['true', 'false'].includes(value.toString().toLowerCase());\n};\nexport var valuesAreBooleanString = function (values) {\n  return values.every(isBooleanString);\n};\nexport var isString = function (value) {\n  return typeof value === 'string';\n};\nexport var valuesAreString = function (values) {\n  return values.every(isString);\n};\nvar HtmlRegexp = /<([A-Z][A-Z0-9]*)\\b[^>]*>(.*?)<\\/\\1>/i;\nexport var isHtml = function (value) {\n  return !value || HtmlRegexp.test(value);\n};\nexport var valuesAreHtml = function (values) {\n  return values.every(isHtml);\n};\nvar UrlRegexp = /http(s*):\\/\\/.*/i;\nexport var isUrl = function (value) {\n  return !value || UrlRegexp.test(value);\n};\nexport var valuesAreUrl = function (values) {\n  return values.every(isUrl);\n};\nvar ImageUrlRegexp = /http(s*):\\/\\/.*\\.(jpeg|jpg|jfif|pjpeg|pjp|png|svg|gif|webp|apng|bmp|ico|cur|tif|tiff)/i;\nexport var isImageUrl = function (value) {\n  return !value || ImageUrlRegexp.test(value);\n};\nexport var valuesAreImageUrl = function (values) {\n  return values.every(isImageUrl);\n};\n// This is a very simple regex to find emails\n// It is NOT meant to validate emails as the spec is way more complicated but is\n// enough for our inference needs\nvar EmailRegexp = /@{1}/;\nexport var isEmail = function (value) {\n  return !value || EmailRegexp.test(value);\n};\nexport var valuesAreEmail = function (values) {\n  return values.every(isEmail);\n};\nexport var isArray = function (value) {\n  return Array.isArray(value);\n};\nexport var valuesAreArray = function (values) {\n  return values.every(isArray);\n};\nexport var isDate = function (value) {\n  return !value || value instanceof Date;\n};\nexport var valuesAreDate = function (values) {\n  return values.every(isDate);\n};\nexport var isDateString = function (value) {\n  return !value || typeof value === 'string' && (isMatch(value, 'MM/dd/yyyy') || isMatch(value, 'MM/dd/yy') || isValid(parseISO(value)));\n};\nexport var valuesAreDateString = function (values) {\n  return values.every(isDateString);\n};\nexport var isObject = function (value) {\n  return Object.prototype.toString.call(value) === '[object Object]';\n};\nexport var valuesAreObject = function (values) {\n  return values.every(isObject);\n};","map":{"version":3,"mappings":"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","names":["isMatch","isValid","parseISO","isNumeric","value","isNaN","parseFloat","isFinite","valuesAreNumeric","values","every","isInteger","parseInt","valuesAreInteger","isBoolean","valuesAreBoolean","isBooleanString","includes","toString","toLowerCase","valuesAreBooleanString","isString","valuesAreString","HtmlRegexp","isHtml","test","valuesAreHtml","UrlRegexp","isUrl","valuesAreUrl","ImageUrlRegexp","isImageUrl","valuesAreImageUrl","EmailRegexp","isEmail","valuesAreEmail","isArray","valuesAreArray","isDate","Date","valuesAreDate","isDateString","valuesAreDateString","isObject","prototype","call","valuesAreObject"],"sources":["/Users/paigedeveau/Desktop/se-diva-docs-frontend/bwmdn-admin-portal/node_modules/ra-core/src/inference/assertions.ts"],"sourcesContent":["import { isMatch, isValid, parseISO } from 'date-fns';\n\nexport const isNumeric = (value: any) =>\n    !isNaN(parseFloat(value)) && isFinite(value);\nexport const valuesAreNumeric = (values: any[]) => values.every(isNumeric);\n\nexport const isInteger = (value: any) =>\n    Number.isInteger(value) || !isNaN(parseInt(value));\nexport const valuesAreInteger = (values: any[]) => values.every(isInteger);\n\nexport const isBoolean = (value: any) => typeof value === 'boolean';\nexport const valuesAreBoolean = (values: any[]) => values.every(isBoolean);\n\nexport const isBooleanString = (value: any) =>\n    ['true', 'false'].includes(value.toString().toLowerCase());\nexport const valuesAreBooleanString = (values: any[]) =>\n    values.every(isBooleanString);\n\nexport const isString = (value: any) => typeof value === 'string';\nexport const valuesAreString = (values: any[]) => values.every(isString);\n\nconst HtmlRegexp = /<([A-Z][A-Z0-9]*)\\b[^>]*>(.*?)<\\/\\1>/i;\nexport const isHtml = (value: any) => !value || HtmlRegexp.test(value);\nexport const valuesAreHtml = (values: any[]) => values.every(isHtml);\n\nconst UrlRegexp = /http(s*):\\/\\/.*/i;\nexport const isUrl = (value: any) => !value || UrlRegexp.test(value);\nexport const valuesAreUrl = (values: any[]) => values.every(isUrl);\n\nconst ImageUrlRegexp = /http(s*):\\/\\/.*\\.(jpeg|jpg|jfif|pjpeg|pjp|png|svg|gif|webp|apng|bmp|ico|cur|tif|tiff)/i;\nexport const isImageUrl = (value: any) => !value || ImageUrlRegexp.test(value);\nexport const valuesAreImageUrl = (values: any[]) => values.every(isImageUrl);\n\n// This is a very simple regex to find emails\n// It is NOT meant to validate emails as the spec is way more complicated but is\n// enough for our inference needs\nconst EmailRegexp = /@{1}/;\nexport const isEmail = (value: any) => !value || EmailRegexp.test(value);\nexport const valuesAreEmail = (values: any[]) => values.every(isEmail);\n\nexport const isArray = (value: any) => Array.isArray(value);\nexport const valuesAreArray = (values: any[]) => values.every(isArray);\n\nexport const isDate = (value: any) => !value || value instanceof Date;\nexport const valuesAreDate = (values: any[]) => values.every(isDate);\n\nexport const isDateString = (value: any) =>\n    !value ||\n    (typeof value === 'string' &&\n        (isMatch(value, 'MM/dd/yyyy') ||\n            isMatch(value, 'MM/dd/yy') ||\n            isValid(parseISO(value))));\n\nexport const valuesAreDateString = (values: any[]) =>\n    values.every(isDateString);\n\nexport const isObject = (value: any) =>\n    Object.prototype.toString.call(value) === '[object Object]';\nexport const valuesAreObject = (values: any[]) => values.every(isObject);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}