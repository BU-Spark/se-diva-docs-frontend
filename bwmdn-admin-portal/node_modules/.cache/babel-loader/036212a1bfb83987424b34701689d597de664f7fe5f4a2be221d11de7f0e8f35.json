{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { useQuery, useQueryClient, hashQueryKey } from 'react-query';\nimport { useDataProvider } from './useDataProvider';\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, refetch }\n * - success: { data: [data from store], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ post }) => {\n *     const { data, isLoading, error } = useGetMany(\n *         'tags',\n *         { ids: post.tags },\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(tag =>\n *         <li key={tag.id}>{tag.name}</li>\n *     )}</ul>;\n * };\n */\nexport var useGetMany = function (resource, params, options) {\n  if (params === void 0) {\n    params = {};\n  }\n  var ids = params.ids,\n    meta = params.meta;\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var queryCache = queryClient.getQueryCache();\n  return useQuery([resource, 'getMany', {\n    ids: !ids || ids.length === 0 ? [] : ids.map(function (id) {\n      return String(id);\n    }),\n    meta: meta\n  }], function () {\n    if (!ids || ids.length === 0) {\n      // no need to call the dataProvider\n      return Promise.resolve([]);\n    }\n    return dataProvider.getMany(resource, {\n      ids: ids,\n      meta: meta\n    }).then(function (_a) {\n      var data = _a.data;\n      return data;\n    });\n  }, __assign({\n    placeholderData: function () {\n      var records = !ids || ids.length === 0 ? [] : ids.map(function (id) {\n        var _a, _b;\n        var queryHash = hashQueryKey([resource, 'getOne', {\n          id: String(id),\n          meta: meta\n        }]);\n        return (_b = (_a = queryCache.get(queryHash)) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.data;\n      });\n      if (records.some(function (record) {\n        return record === undefined;\n      })) {\n        return undefined;\n      } else {\n        return records;\n      }\n    },\n    onSuccess: function (data) {\n      // optimistically populate the getOne cache\n      data.forEach(function (record) {\n        queryClient.setQueryData([resource, 'getOne', {\n          id: String(record.id),\n          meta: meta\n        }], function (oldRecord) {\n          return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;\n        });\n      });\n    },\n    retry: false\n  }, options));\n};","map":{"version":3,"mappings":";;;;;;;;;;AAAA,SACIA,QAAQ,EAGRC,cAAc,EACdC,YAAY,QACT,aAAa;AAGpB,SAASC,eAAe,QAAQ,mBAAmB;AAEnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCA,OAAO,IAAMC,UAAU,GAAG,UACtBC,QAAgB,EAChBC,MAAmC,EACnCC,OAA8C;EAD9C;IAAAD,WAAmC;EAAA;EAG3B,OAAG,GAAWA,MAAM,IAAjB;IAAEE,IAAI,GAAKF,MAAM,KAAX;EACjB,IAAMG,YAAY,GAAGN,eAAe,EAAE;EACtC,IAAMO,WAAW,GAAGT,cAAc,EAAE;EACpC,IAAMU,UAAU,GAAGD,WAAW,CAACE,aAAa,EAAE;EAE9C,OAAOZ,QAAQ,CACX,CACIK,QAAQ,EACR,SAAS,EACT;IACIQ,GAAG,EAAE,CAACA,GAAG,IAAIA,GAAG,CAACC,MAAM,KAAK,CAAC,GAAG,EAAE,GAAGD,GAAG,CAACE,GAAG,CAAC,YAAE;MAAI,aAAM,CAACC,EAAE,CAAC;IAAV,CAAU,CAAC;IAC9DR,IAAI;GACP,CACJ,EACD;IACI,IAAI,CAACK,GAAG,IAAIA,GAAG,CAACC,MAAM,KAAK,CAAC,EAAE;MAC1B;MACA,OAAOG,OAAO,CAACC,OAAO,CAAC,EAAE,CAAC;;IAE9B,OAAOT,YAAY,CACdU,OAAO,CAAad,QAAQ,EAAE;MAAEQ,GAAG;MAAEL,IAAI;IAAA,CAAE,CAAC,CAC5CY,IAAI,CAAC,UAACC,EAAQ;UAANC,IAAI;MAAO,WAAI;IAAJ,CAAI,CAAC;EACjC,CAAC;IAEGC,eAAe,EAAE;MACb,IAAMC,OAAO,GACT,CAACX,GAAG,IAAIA,GAAG,CAACC,MAAM,KAAK,CAAC,GAClB,EAAE,GACFD,GAAG,CAACE,GAAG,CAAC,YAAE;;QACN,IAAMU,SAAS,GAAGvB,YAAY,CAAC,CAC3BG,QAAQ,EACR,QAAQ,EACR;UAAEW,EAAE,EAAEU,MAAM,CAACV,EAAE,CAAC;UAAER,IAAI;QAAA,CAAE,CAC3B,CAAC;QACF,OAAO,sBAAU,CAACmB,GAAG,CAAaF,SAAS,CAAC,0CACtCG,KAAK,0CAAEN,IAAI;MACrB,CAAC,CAAC;MACZ,IAAIE,OAAO,CAACK,IAAI,CAAC,gBAAM;QAAI,aAAM,KAAKC,SAAS;MAApB,CAAoB,CAAC,EAAE;QAC9C,OAAOA,SAAS;OACnB,MAAM;QACH,OAAON,OAAuB;;IAEtC,CAAC;IACDO,SAAS,EAAE,cAAI;MACX;MACAT,IAAI,CAACU,OAAO,CAAC,gBAAM;QACftB,WAAW,CAACuB,YAAY,CACpB,CAAC5B,QAAQ,EAAE,QAAQ,EAAE;UAAEW,EAAE,EAAEU,MAAM,CAACQ,MAAM,CAAClB,EAAE,CAAC;UAAER,IAAI;QAAA,CAAE,CAAC,EACrD,mBAAS;UAAI,gBAAS,aAAT2B,SAAS,cAATA,SAAS,GAAID,MAAM;QAAnB,CAAmB,CACnC;MACL,CAAC,CAAC;IACN,CAAC;IACDE,KAAK,EAAE;EAAK,GACT7B,OAAO,EAEjB;AACL,CAAC","names":["useQuery","useQueryClient","hashQueryKey","useDataProvider","useGetMany","resource","params","options","meta","dataProvider","queryClient","queryCache","getQueryCache","ids","length","map","id","Promise","resolve","getMany","then","_a","data","placeholderData","records","queryHash","String","get","state","some","undefined","onSuccess","forEach","setQueryData","record","oldRecord","retry"],"sources":["/Users/paigedeveau/Desktop/se-diva-docs-frontend/bwmdn-admin-portal/node_modules/ra-core/src/dataProvider/useGetMany.ts"],"sourcesContent":["import {\n    useQuery,\n    UseQueryOptions,\n    UseQueryResult,\n    useQueryClient,\n    hashQueryKey,\n} from 'react-query';\n\nimport { RaRecord, GetManyParams } from '../types';\nimport { useDataProvider } from './useDataProvider';\n\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, refetch }\n * - success: { data: [data from store], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ post }) => {\n *     const { data, isLoading, error } = useGetMany(\n *         'tags',\n *         { ids: post.tags },\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(tag =>\n *         <li key={tag.id}>{tag.name}</li>\n *     )}</ul>;\n * };\n */\nexport const useGetMany = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: Partial<GetManyParams> = {},\n    options?: UseQueryOptions<RecordType[], Error>\n): UseGetManyHookValue<RecordType> => {\n    const { ids, meta } = params;\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const queryCache = queryClient.getQueryCache();\n\n    return useQuery<RecordType[], Error, RecordType[]>(\n        [\n            resource,\n            'getMany',\n            {\n                ids: !ids || ids.length === 0 ? [] : ids.map(id => String(id)),\n                meta,\n            },\n        ],\n        () => {\n            if (!ids || ids.length === 0) {\n                // no need to call the dataProvider\n                return Promise.resolve([]);\n            }\n            return dataProvider\n                .getMany<RecordType>(resource, { ids, meta })\n                .then(({ data }) => data);\n        },\n        {\n            placeholderData: () => {\n                const records =\n                    !ids || ids.length === 0\n                        ? []\n                        : ids.map(id => {\n                              const queryHash = hashQueryKey([\n                                  resource,\n                                  'getOne',\n                                  { id: String(id), meta },\n                              ]);\n                              return queryCache.get<RecordType>(queryHash)\n                                  ?.state?.data;\n                          });\n                if (records.some(record => record === undefined)) {\n                    return undefined;\n                } else {\n                    return records as RecordType[];\n                }\n            },\n            onSuccess: data => {\n                // optimistically populate the getOne cache\n                data.forEach(record => {\n                    queryClient.setQueryData(\n                        [resource, 'getOne', { id: String(record.id), meta }],\n                        oldRecord => oldRecord ?? record\n                    );\n                });\n            },\n            retry: false,\n            ...options,\n        }\n    );\n};\n\nexport type UseGetManyHookValue<\n    RecordType extends RaRecord = any\n> = UseQueryResult<RecordType[], Error>;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}