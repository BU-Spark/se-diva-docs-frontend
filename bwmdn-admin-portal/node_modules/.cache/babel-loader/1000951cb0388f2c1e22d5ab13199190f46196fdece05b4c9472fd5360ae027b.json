{"ast":null,"code":"var isMatchingReferencesError = function (matchingReferences) {\n  return matchingReferences && matchingReferences.error !== undefined;\n};\nexport var getStatusForInput = function (_a) {\n  var field = _a.field,\n    matchingReferences = _a.matchingReferences,\n    referenceRecord = _a.referenceRecord,\n    _b = _a.translate,\n    translate = _b === void 0 ? function (x) {\n      return x;\n    } : _b;\n  var matchingReferencesError = isMatchingReferencesError(matchingReferences) ? translate(matchingReferences.error, {\n    _: matchingReferences.error\n  }) : null;\n  var selectedReferenceError = field.value && !referenceRecord ? translate('ra.input.references.single_missing', {\n    _: 'ra.input.references.single_missing'\n  }) : null;\n  return {\n    waiting: field.value && selectedReferenceError && !matchingReferences || !field.value && !matchingReferences,\n    error: field.value && selectedReferenceError && matchingReferencesError || !field.value && matchingReferencesError ? field.value ? selectedReferenceError : matchingReferencesError : null,\n    warning: selectedReferenceError || matchingReferencesError,\n    choices: Array.isArray(matchingReferences) ? matchingReferences : [referenceRecord].filter(function (choice) {\n      return choice;\n    })\n  };\n};\nexport var REFERENCES_STATUS_READY = 'REFERENCES_STATUS_READY';\nexport var REFERENCES_STATUS_INCOMPLETE = 'REFERENCES_STATUS_INCOMPLETE';\nexport var REFERENCES_STATUS_EMPTY = 'REFERENCES_STATUS_EMPTY';\nexport var getSelectedReferencesStatus = function (field, referenceRecords) {\n  return !field.value || field.value.length === referenceRecords.length ? REFERENCES_STATUS_READY : referenceRecords.length > 0 ? REFERENCES_STATUS_INCOMPLETE : REFERENCES_STATUS_EMPTY;\n};\nexport var getStatusForArrayInput = function (_a) {\n  var field = _a.field,\n    matchingReferences = _a.matchingReferences,\n    referenceRecords = _a.referenceRecords,\n    _b = _a.translate,\n    translate = _b === void 0 ? function (x) {\n      return x;\n    } : _b;\n  // selectedReferencesDataStatus can be \"empty\" (no data was found for references from input.value)\n  // or \"incomplete\" (Not all of the reference data was found)\n  // or \"ready\" (all references data was found or there is no references from input.value)\n  var selectedReferencesDataStatus = getSelectedReferencesStatus(field, referenceRecords);\n  var matchingReferencesError = isMatchingReferencesError(matchingReferences) ? translate(matchingReferences.error, {\n    _: matchingReferences.error\n  }) : null;\n  var choices = Array.isArray(matchingReferences) ? referenceRecords.concat(matchingReferences.filter(function (choice) {\n    return referenceRecords.findIndex(function (c) {\n      return c.id === choice.id;\n    }) === -1;\n  })) : referenceRecords;\n  return {\n    waiting: !matchingReferences && field.value && selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY || !matchingReferences && !field.value,\n    error: matchingReferencesError && (!field.value || field.value && selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY) ? translate('ra.input.references.all_missing', {\n      _: 'ra.input.references.all_missing'\n    }) : null,\n    warning: matchingReferencesError || field.value && selectedReferencesDataStatus !== REFERENCES_STATUS_READY ? matchingReferencesError || translate('ra.input.references.many_missing', {\n      _: 'ra.input.references.many_missing'\n    }) : null,\n    choices: choices\n  };\n};","map":{"version":3,"mappings":"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","names":["isMatchingReferencesError","matchingReferences","error","undefined","getStatusForInput","_a","field","referenceRecord","_b","translate","matchingReferencesError","_","selectedReferenceError","value","waiting","warning","choices","Array","isArray","filter","REFERENCES_STATUS_READY","REFERENCES_STATUS_INCOMPLETE","REFERENCES_STATUS_EMPTY","getSelectedReferencesStatus","referenceRecords","length","getStatusForArrayInput","selectedReferencesDataStatus","concat","findIndex","id","choice"],"sources":["/Users/paigedeveau/node_modules/ra-core/src/controller/input/referenceDataStatus.ts"],"sourcesContent":["import { RaRecord, Translate } from '../../types';\nimport { MatchingReferencesError } from './types';\nimport { ControllerRenderProps } from 'react-hook-form';\n\ninterface GetStatusForInputParams<RecordType extends RaRecord = RaRecord> {\n    field: Pick<ControllerRenderProps, 'value'>;\n    matchingReferences: RecordType[] | MatchingReferencesError;\n    referenceRecord: RecordType;\n    translate: Translate;\n}\n\nconst isMatchingReferencesError = (\n    matchingReferences?: any\n): matchingReferences is MatchingReferencesError =>\n    matchingReferences && matchingReferences.error !== undefined;\n\nexport const getStatusForInput = <RecordType extends RaRecord = RaRecord>({\n    field,\n    matchingReferences,\n    referenceRecord,\n    translate = x => x,\n}: GetStatusForInputParams<RecordType>) => {\n    const matchingReferencesError = isMatchingReferencesError(\n        matchingReferences\n    )\n        ? translate(matchingReferences.error, {\n              _: matchingReferences.error,\n          })\n        : null;\n    const selectedReferenceError =\n        field.value && !referenceRecord\n            ? translate('ra.input.references.single_missing', {\n                  _: 'ra.input.references.single_missing',\n              })\n            : null;\n\n    return {\n        waiting:\n            (field.value && selectedReferenceError && !matchingReferences) ||\n            (!field.value && !matchingReferences),\n        error:\n            (field.value &&\n                selectedReferenceError &&\n                matchingReferencesError) ||\n            (!field.value && matchingReferencesError)\n                ? field.value\n                    ? selectedReferenceError\n                    : matchingReferencesError\n                : null,\n        warning: selectedReferenceError || matchingReferencesError,\n        choices: Array.isArray(matchingReferences)\n            ? matchingReferences\n            : [referenceRecord].filter(choice => choice),\n    };\n};\n\nexport const REFERENCES_STATUS_READY = 'REFERENCES_STATUS_READY';\nexport const REFERENCES_STATUS_INCOMPLETE = 'REFERENCES_STATUS_INCOMPLETE';\nexport const REFERENCES_STATUS_EMPTY = 'REFERENCES_STATUS_EMPTY';\n\nexport const getSelectedReferencesStatus = <RecordType extends RaRecord = any>(\n    field: Pick<ControllerRenderProps, 'value'>,\n    referenceRecords: RecordType[]\n) =>\n    !field.value || field.value.length === referenceRecords.length\n        ? REFERENCES_STATUS_READY\n        : referenceRecords.length > 0\n        ? REFERENCES_STATUS_INCOMPLETE\n        : REFERENCES_STATUS_EMPTY;\n\ninterface GetStatusForArrayInputParams<RecordType extends RaRecord = any> {\n    field: ControllerRenderProps;\n    matchingReferences: RecordType[] | MatchingReferencesError;\n    referenceRecords: RecordType[];\n    translate: Translate;\n}\n\nexport const getStatusForArrayInput = <RecordType extends RaRecord = any>({\n    field,\n    matchingReferences,\n    referenceRecords,\n    translate = x => x,\n}: GetStatusForArrayInputParams<RecordType>) => {\n    // selectedReferencesDataStatus can be \"empty\" (no data was found for references from input.value)\n    // or \"incomplete\" (Not all of the reference data was found)\n    // or \"ready\" (all references data was found or there is no references from input.value)\n    const selectedReferencesDataStatus = getSelectedReferencesStatus(\n        field,\n        referenceRecords\n    );\n\n    const matchingReferencesError = isMatchingReferencesError(\n        matchingReferences\n    )\n        ? translate(matchingReferences.error, {\n              _: matchingReferences.error,\n          })\n        : null;\n\n    const choices = Array.isArray(matchingReferences)\n        ? referenceRecords.concat(\n              matchingReferences.filter(\n                  choice =>\n                      referenceRecords.findIndex(c => c.id === choice.id) === -1\n              )\n          )\n        : referenceRecords;\n\n    return {\n        waiting:\n            (!matchingReferences &&\n                field.value &&\n                selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY) ||\n            (!matchingReferences && !field.value),\n        error:\n            matchingReferencesError &&\n            (!field.value ||\n                (field.value &&\n                    selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY))\n                ? translate('ra.input.references.all_missing', {\n                      _: 'ra.input.references.all_missing',\n                  })\n                : null,\n        warning:\n            matchingReferencesError ||\n            (field.value &&\n                selectedReferencesDataStatus !== REFERENCES_STATUS_READY)\n                ? matchingReferencesError ||\n                  translate('ra.input.references.many_missing', {\n                      _: 'ra.input.references.many_missing',\n                  })\n                : null,\n        choices,\n    };\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}