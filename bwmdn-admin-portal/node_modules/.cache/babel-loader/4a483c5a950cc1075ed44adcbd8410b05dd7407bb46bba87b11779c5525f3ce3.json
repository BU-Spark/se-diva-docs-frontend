{"ast":null,"code":"import inflection from 'inflection';\nimport getValuesFromRecords from './getValuesFromRecords';\nimport { isObject, valuesAreArray, valuesAreBoolean, valuesAreDate, valuesAreDateString, valuesAreHtml, valuesAreInteger, valuesAreNumeric, valuesAreObject, valuesAreString, valuesAreUrl, valuesAreImageUrl, valuesAreEmail } from './assertions';\nexport var InferenceTypes = ['array', 'boolean', 'date', 'email', 'id', 'image', 'number', 'reference', 'referenceChild', 'referenceArray', 'referenceArrayChild', 'richText', 'string', 'url', 'object'];\n/**\n * Guesses an element type based on an array of values\n *\n * @example\n *     inferElementFromValues(\n *         'address',\n *         ['2 Baker Street', '1 Downing street'],\n *     );\n *     // { type: 'string', props: { source: 'address' } }\n *\n * @param {string} name Property name, e.g. 'date_of_birth'\n * @param {any[]} values an array of values from which to determine the type, e.g. [12, 34.4, 43]\n */\nexport var inferTypeFromValues = function (name, values) {\n  if (values === void 0) {\n    values = [];\n  }\n  if (name === 'id') {\n    return {\n      type: 'id',\n      props: {\n        source: name\n      }\n    };\n  }\n  if (name.substr(name.length - 3) === '_id') {\n    return {\n      type: 'reference',\n      props: {\n        source: name,\n        reference: inflection.pluralize(name.substr(0, name.length - 3))\n      },\n      children: {\n        type: 'referenceChild'\n      }\n    };\n  }\n  if (name.substr(name.length - 2) === 'Id') {\n    return {\n      type: 'reference',\n      props: {\n        source: name,\n        reference: inflection.pluralize(name.substr(0, name.length - 2))\n      },\n      children: {\n        type: 'referenceChild'\n      }\n    };\n  }\n  if (name.substr(name.length - 4) === '_ids') {\n    return {\n      type: 'referenceArray',\n      props: {\n        source: name,\n        reference: inflection.pluralize(name.substr(0, name.length - 4))\n      },\n      children: {\n        type: 'referenceArrayChild'\n      }\n    };\n  }\n  if (name.substr(name.length - 3) === 'Ids') {\n    return {\n      type: 'referenceArray',\n      props: {\n        source: name,\n        reference: inflection.pluralize(name.substr(0, name.length - 3))\n      },\n      children: {\n        type: 'referenceArrayChild'\n      }\n    };\n  }\n  if (values.length === 0) {\n    if (name === 'email') {\n      return {\n        type: 'email',\n        props: {\n          source: name\n        }\n      };\n    }\n    if (name === 'url') {\n      return {\n        type: 'url',\n        props: {\n          source: name\n        }\n      };\n    }\n    // FIXME introspect further using name\n    return {\n      type: 'string',\n      props: {\n        source: name\n      }\n    };\n  }\n  if (valuesAreArray(values)) {\n    if (isObject(values[0][0])) {\n      var leafValues_1 = getValuesFromRecords(values.reduce(function (acc, vals) {\n        return acc.concat(vals);\n      }, []));\n      // FIXME bad visual representation\n      return {\n        type: 'array',\n        props: {\n          source: name\n        },\n        children: Object.keys(leafValues_1).map(function (leafName) {\n          return inferTypeFromValues(leafName, leafValues_1[leafName]);\n        })\n      };\n    }\n    // FIXME introspect further\n    return {\n      type: 'string',\n      props: {\n        source: name\n      }\n    };\n  }\n  if (valuesAreBoolean(values)) {\n    return {\n      type: 'boolean',\n      props: {\n        source: name\n      }\n    };\n  }\n  if (valuesAreDate(values)) {\n    return {\n      type: 'date',\n      props: {\n        source: name\n      }\n    };\n  }\n  if (valuesAreString(values)) {\n    if (name === 'email' || valuesAreEmail(values)) {\n      return {\n        type: 'email',\n        props: {\n          source: name\n        }\n      };\n    }\n    if (name === 'url' || valuesAreUrl(values)) {\n      if (valuesAreImageUrl(values)) {\n        return {\n          type: 'image',\n          props: {\n            source: name\n          }\n        };\n      }\n      return {\n        type: 'url',\n        props: {\n          source: name\n        }\n      };\n    }\n    if (valuesAreDateString(values)) {\n      return {\n        type: 'date',\n        props: {\n          source: name\n        }\n      };\n    }\n    if (valuesAreHtml(values)) {\n      return {\n        type: 'richText',\n        props: {\n          source: name\n        }\n      };\n    }\n    if (valuesAreInteger(values) || valuesAreNumeric(values)) {\n      return {\n        type: 'number',\n        props: {\n          source: name\n        }\n      };\n    }\n    return {\n      type: 'string',\n      props: {\n        source: name\n      }\n    };\n  }\n  if (valuesAreInteger(values) || valuesAreNumeric(values)) {\n    return {\n      type: 'number',\n      props: {\n        source: name\n      }\n    };\n  }\n  if (valuesAreObject(values)) {\n    /// Arbitrarily, choose the first prop of the first object\n    var propName_1 = Object.keys(values[0]).shift();\n    if (!propName_1) {\n      return {\n        type: 'object',\n        props: {\n          source: name\n        }\n      };\n    }\n    var leafValues = values.map(function (v) {\n      return v[propName_1];\n    });\n    return inferTypeFromValues(\"\".concat(name, \".\").concat(propName_1), leafValues);\n  }\n  return {\n    type: 'string',\n    props: {\n      source: name\n    }\n  };\n};","map":{"version":3,"mappings":"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","names":["inflection","getValuesFromRecords","isObject","valuesAreArray","valuesAreBoolean","valuesAreDate","valuesAreDateString","valuesAreHtml","valuesAreInteger","valuesAreNumeric","valuesAreObject","valuesAreString","valuesAreUrl","valuesAreImageUrl","valuesAreEmail","InferenceTypes","inferTypeFromValues","name","values","type","props","source","substr","length","reference","pluralize","children","leafValues_1","reduce","acc","vals","concat","Object","keys","map","leafName","propName_1","shift","leafValues"],"sources":["/Users/paigedeveau/node_modules/ra-core/src/inference/inferTypeFromValues.ts"],"sourcesContent":["import inflection from 'inflection';\n\nimport getValuesFromRecords from './getValuesFromRecords';\n\nimport {\n    isObject,\n    valuesAreArray,\n    valuesAreBoolean,\n    valuesAreDate,\n    valuesAreDateString,\n    valuesAreHtml,\n    valuesAreInteger,\n    valuesAreNumeric,\n    valuesAreObject,\n    valuesAreString,\n    valuesAreUrl,\n    valuesAreImageUrl,\n    valuesAreEmail,\n} from './assertions';\n\nexport const InferenceTypes = [\n    'array',\n    'boolean',\n    'date',\n    'email',\n    'id',\n    'image',\n    'number',\n    'reference',\n    'referenceChild',\n    'referenceArray',\n    'referenceArrayChild',\n    'richText',\n    'string',\n    'url',\n    'object',\n] as const;\n\nexport type PossibleInferredElementTypes = typeof InferenceTypes[number];\n\nexport interface InferredElementDescription {\n    type: PossibleInferredElementTypes;\n    props?: any;\n    children?: InferredElementDescription | InferredElementDescription[];\n}\n\n/**\n * Guesses an element type based on an array of values\n *\n * @example\n *     inferElementFromValues(\n *         'address',\n *         ['2 Baker Street', '1 Downing street'],\n *     );\n *     // { type: 'string', props: { source: 'address' } }\n *\n * @param {string} name Property name, e.g. 'date_of_birth'\n * @param {any[]} values an array of values from which to determine the type, e.g. [12, 34.4, 43]\n */\nexport const inferTypeFromValues = (\n    name,\n    values = []\n): InferredElementDescription => {\n    if (name === 'id') {\n        return { type: 'id', props: { source: name } };\n    }\n    if (name.substr(name.length - 3) === '_id') {\n        return {\n            type: 'reference',\n            props: {\n                source: name,\n                reference: inflection.pluralize(\n                    name.substr(0, name.length - 3)\n                ),\n            },\n            children: { type: 'referenceChild' },\n        };\n    }\n    if (name.substr(name.length - 2) === 'Id') {\n        return {\n            type: 'reference',\n            props: {\n                source: name,\n                reference: inflection.pluralize(\n                    name.substr(0, name.length - 2)\n                ),\n            },\n            children: { type: 'referenceChild' },\n        };\n    }\n    if (name.substr(name.length - 4) === '_ids') {\n        return {\n            type: 'referenceArray',\n            props: {\n                source: name,\n                reference: inflection.pluralize(\n                    name.substr(0, name.length - 4)\n                ),\n            },\n            children: { type: 'referenceArrayChild' },\n        };\n    }\n    if (name.substr(name.length - 3) === 'Ids') {\n        return {\n            type: 'referenceArray',\n            props: {\n                source: name,\n                reference: inflection.pluralize(\n                    name.substr(0, name.length - 3)\n                ),\n            },\n            children: { type: 'referenceArrayChild' },\n        };\n    }\n    if (values.length === 0) {\n        if (name === 'email') {\n            return { type: 'email', props: { source: name } };\n        }\n        if (name === 'url') {\n            return { type: 'url', props: { source: name } };\n        }\n        // FIXME introspect further using name\n        return { type: 'string', props: { source: name } };\n    }\n    if (valuesAreArray(values)) {\n        if (isObject(values[0][0])) {\n            const leafValues = getValuesFromRecords(\n                values.reduce((acc, vals) => acc.concat(vals), [])\n            );\n            // FIXME bad visual representation\n            return {\n                type: 'array',\n                props: { source: name },\n                children: Object.keys(leafValues).map(leafName =>\n                    inferTypeFromValues(leafName, leafValues[leafName])\n                ),\n            };\n        }\n        // FIXME introspect further\n        return { type: 'string', props: { source: name } };\n    }\n    if (valuesAreBoolean(values)) {\n        return { type: 'boolean', props: { source: name } };\n    }\n    if (valuesAreDate(values)) {\n        return { type: 'date', props: { source: name } };\n    }\n    if (valuesAreString(values)) {\n        if (name === 'email' || valuesAreEmail(values)) {\n            return { type: 'email', props: { source: name } };\n        }\n        if (name === 'url' || valuesAreUrl(values)) {\n            if (valuesAreImageUrl(values)) {\n                return { type: 'image', props: { source: name } };\n            }\n            return { type: 'url', props: { source: name } };\n        }\n        if (valuesAreDateString(values)) {\n            return { type: 'date', props: { source: name } };\n        }\n        if (valuesAreHtml(values)) {\n            return { type: 'richText', props: { source: name } };\n        }\n        if (valuesAreInteger(values) || valuesAreNumeric(values)) {\n            return { type: 'number', props: { source: name } };\n        }\n        return { type: 'string', props: { source: name } };\n    }\n    if (valuesAreInteger(values) || valuesAreNumeric(values)) {\n        return { type: 'number', props: { source: name } };\n    }\n    if (valuesAreObject(values)) {\n        /// Arbitrarily, choose the first prop of the first object\n        const propName = Object.keys(values[0]).shift();\n        if (!propName) {\n            return { type: 'object', props: { source: name } };\n        }\n        const leafValues = values.map(v => v[propName]);\n        return inferTypeFromValues(`${name}.${propName}`, leafValues);\n    }\n    return { type: 'string', props: { source: name } };\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}