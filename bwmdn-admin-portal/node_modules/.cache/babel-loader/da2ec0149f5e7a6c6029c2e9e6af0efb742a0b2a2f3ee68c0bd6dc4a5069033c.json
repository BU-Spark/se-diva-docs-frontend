{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { useMemo } from 'react';\nimport { useQuery } from 'react-query';\nimport useAuthProvider, { defaultAuthParams } from './useAuthProvider';\nimport useLogout from './useLogout';\nimport { removeDoubleSlashes, useBasename } from '../routing';\nimport { useNotify } from '../notification';\nvar emptyParams = {};\n/**\n * Hook for getting the authentication status\n *\n * Calls the authProvider.checkAuth() method asynchronously.\n *\n * The return value updates according to the authProvider request state:\n *\n * - isLoading: true just after mount, while the authProvider is being called. false once the authProvider has answered.\n * - authenticated: true while loading. then true or false depending on the authProvider response.\n *\n * To avoid rendering a component and force waiting for the authProvider response, use the useAuthState() hook\n * instead of the useAuthenticated() hook.\n *\n * You can render different content depending on the authenticated status.\n *\n * @see useAuthenticated()\n *\n * @param {Object} params Any params you want to pass to the authProvider\n *\n * @param {Boolean} logoutOnFailure: Optional. Whether the user should be logged out if the authProvider fails to authenticate them. False by default.\n *\n * @returns The current auth check state. Destructure as { authenticated, error, isLoading }.\n *\n * @example\n * import { useAuthState, Loading } from 'react-admin';\n *\n * const MyPage = () => {\n *     const { isLoading, authenticated } = useAuthState();\n *     if (isLoading) {\n *         return <Loading />;\n *     }\n *     if (authenticated) {\n *        return <AuthenticatedContent />;\n *     }\n *     return <AnonymousContent />;\n * };\n */\nvar useAuthState = function (params, logoutOnFailure, queryOptions) {\n  if (params === void 0) {\n    params = emptyParams;\n  }\n  if (logoutOnFailure === void 0) {\n    logoutOnFailure = false;\n  }\n  var authProvider = useAuthProvider();\n  var logout = useLogout();\n  var basename = useBasename();\n  var notify = useNotify();\n  var result = useQuery(['auth', 'checkAuth', params], function () {\n    // The authProvider is optional in react-admin\n    return authProvider === null || authProvider === void 0 ? void 0 : authProvider.checkAuth(params).then(function () {\n      return true;\n    });\n  }, __assign({\n    onError: function (error) {\n      var loginUrl = removeDoubleSlashes(\"\".concat(basename, \"/\").concat(defaultAuthParams.loginUrl));\n      if (logoutOnFailure) {\n        logout({}, error && error.redirectTo != null ? error.redirectTo : loginUrl);\n        var shouldSkipNotify = error && error.message === false;\n        !shouldSkipNotify && notify(getErrorMessage(error, 'ra.auth.auth_check_error'), {\n          type: 'error'\n        });\n      }\n    },\n    retry: false\n  }, queryOptions));\n  return useMemo(function () {\n    var _a;\n    return {\n      // If the data is undefined and the query isn't loading anymore, it means the query failed.\n      // In that case, we set authenticated to false unless there's no authProvider.\n      authenticated: ((_a = result.data) !== null && _a !== void 0 ? _a : result.isLoading) ? true : authProvider == null,\n      isLoading: result.isLoading,\n      error: result.error\n    };\n  }, [authProvider, result]);\n};\nexport default useAuthState;\nvar getErrorMessage = function (error, defaultMessage) {\n  return typeof error === 'string' ? error : typeof error === 'undefined' || !error.message ? defaultMessage : error.message;\n};","map":{"version":3,"mappings":";;;;;;;;;;AAAA,SAASA,OAAO,QAAQ,OAAO;AAC/B,SAASC,QAAQ,QAAyB,aAAa;AACvD,OAAOC,eAAe,IAAIC,iBAAiB,QAAQ,mBAAmB;AACtE,OAAOC,SAAS,MAAM,aAAa;AACnC,SAASC,mBAAmB,EAAEC,WAAW,QAAQ,YAAY;AAC7D,SAASC,SAAS,QAAQ,iBAAiB;AAO3C,IAAMC,WAAW,GAAG,EAAE;AAEtB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,IAAMC,YAAY,GAAG,UACjBC,MAAyB,EACzBC,eAAgC,EAChCC,YAA4C;EAF5C;IAAAF,oBAAyB;EAAA;EACzB;IAAAC,uBAAgC;EAAA;EAGhC,IAAME,YAAY,GAAGX,eAAe,EAAE;EACtC,IAAMY,MAAM,GAAGV,SAAS,EAAE;EAC1B,IAAMW,QAAQ,GAAGT,WAAW,EAAE;EAC9B,IAAMU,MAAM,GAAGT,SAAS,EAAE;EAE1B,IAAMU,MAAM,GAAGhB,QAAQ,CACnB,CAAC,MAAM,EAAE,WAAW,EAAES,MAAM,CAAC,EAC7B;IACI;IACA,OAAOG,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEK,SAAS,CAACR,MAAM,EAAES,IAAI,CAAC;MAAM,WAAI;IAAJ,CAAI,CAAC;EAC3D,CAAC;IAEGC,OAAO,EAAE,eAAK;MACV,IAAMC,QAAQ,GAAGhB,mBAAmB,CAChC,UAAGU,QAAQ,cAAIZ,iBAAiB,CAACkB,QAAQ,CAAE,CAC9C;MACD,IAAIV,eAAe,EAAE;QACjBG,MAAM,CACF,EAAE,EACFQ,KAAK,IAAIA,KAAK,CAACC,UAAU,IAAI,IAAI,GAC3BD,KAAK,CAACC,UAAU,GAChBF,QAAQ,CACjB;QACD,IAAMG,gBAAgB,GAAGF,KAAK,IAAIA,KAAK,CAACG,OAAO,KAAK,KAAK;QACzD,CAACD,gBAAgB,IACbR,MAAM,CACFU,eAAe,CAACJ,KAAK,EAAE,0BAA0B,CAAC,EAClD;UAAEK,IAAI,EAAE;QAAO,CAAE,CACpB;;IAEb,CAAC;IACDC,KAAK,EAAE;EAAK,GACThB,YAAY,EAEtB;EAED,OAAOZ,OAAO,CAAC;;IACX,OAAO;MACH;MACA;MACA6B,aAAa,EACT,aAAM,CAACC,IAAI,mCAAIb,MAAM,CAACc,SAAS,IAAG,IAAI,GAAGlB,YAAY,IAAI,IAAI;MACjEkB,SAAS,EAAEd,MAAM,CAACc,SAAS;MAC3BT,KAAK,EAAEL,MAAM,CAACK;KACjB;EACL,CAAC,EAAE,CAACT,YAAY,EAAEI,MAAM,CAAC,CAAC;AAC9B,CAAC;AAED,eAAeR,YAAY;AAE3B,IAAMiB,eAAe,GAAG,UAACJ,KAAK,EAAEU,cAAc;EAC1C,cAAOV,KAAK,KAAK,QAAQ,GACnBA,KAAK,GACL,OAAOA,KAAK,KAAK,WAAW,IAAI,CAACA,KAAK,CAACG,OAAO,GAC9CO,cAAc,GACdV,KAAK,CAACG,OAAO;AAJnB,CAImB","names":["useMemo","useQuery","useAuthProvider","defaultAuthParams","useLogout","removeDoubleSlashes","useBasename","useNotify","emptyParams","useAuthState","params","logoutOnFailure","queryOptions","authProvider","logout","basename","notify","result","checkAuth","then","onError","loginUrl","error","redirectTo","shouldSkipNotify","message","getErrorMessage","type","retry","authenticated","data","isLoading","defaultMessage"],"sources":["/Users/paigedeveau/Desktop/se-diva-docs-frontend/bwmdn-admin-portal/node_modules/ra-core/src/auth/useAuthState.ts"],"sourcesContent":["import { useMemo } from 'react';\nimport { useQuery, UseQueryOptions } from 'react-query';\nimport useAuthProvider, { defaultAuthParams } from './useAuthProvider';\nimport useLogout from './useLogout';\nimport { removeDoubleSlashes, useBasename } from '../routing';\nimport { useNotify } from '../notification';\n\ninterface State {\n    isLoading: boolean;\n    authenticated?: boolean;\n}\n\nconst emptyParams = {};\n\n/**\n * Hook for getting the authentication status\n *\n * Calls the authProvider.checkAuth() method asynchronously.\n *\n * The return value updates according to the authProvider request state:\n *\n * - isLoading: true just after mount, while the authProvider is being called. false once the authProvider has answered.\n * - authenticated: true while loading. then true or false depending on the authProvider response.\n *\n * To avoid rendering a component and force waiting for the authProvider response, use the useAuthState() hook\n * instead of the useAuthenticated() hook.\n *\n * You can render different content depending on the authenticated status.\n *\n * @see useAuthenticated()\n *\n * @param {Object} params Any params you want to pass to the authProvider\n *\n * @param {Boolean} logoutOnFailure: Optional. Whether the user should be logged out if the authProvider fails to authenticate them. False by default.\n *\n * @returns The current auth check state. Destructure as { authenticated, error, isLoading }.\n *\n * @example\n * import { useAuthState, Loading } from 'react-admin';\n *\n * const MyPage = () => {\n *     const { isLoading, authenticated } = useAuthState();\n *     if (isLoading) {\n *         return <Loading />;\n *     }\n *     if (authenticated) {\n *        return <AuthenticatedContent />;\n *     }\n *     return <AnonymousContent />;\n * };\n */\nconst useAuthState = (\n    params: any = emptyParams,\n    logoutOnFailure: boolean = false,\n    queryOptions?: UseQueryOptions<boolean, any>\n): State => {\n    const authProvider = useAuthProvider();\n    const logout = useLogout();\n    const basename = useBasename();\n    const notify = useNotify();\n\n    const result = useQuery<boolean, any>(\n        ['auth', 'checkAuth', params],\n        () => {\n            // The authProvider is optional in react-admin\n            return authProvider?.checkAuth(params).then(() => true);\n        },\n        {\n            onError: error => {\n                const loginUrl = removeDoubleSlashes(\n                    `${basename}/${defaultAuthParams.loginUrl}`\n                );\n                if (logoutOnFailure) {\n                    logout(\n                        {},\n                        error && error.redirectTo != null\n                            ? error.redirectTo\n                            : loginUrl\n                    );\n                    const shouldSkipNotify = error && error.message === false;\n                    !shouldSkipNotify &&\n                        notify(\n                            getErrorMessage(error, 'ra.auth.auth_check_error'),\n                            { type: 'error' }\n                        );\n                }\n            },\n            retry: false,\n            ...queryOptions,\n        }\n    );\n\n    return useMemo(() => {\n        return {\n            // If the data is undefined and the query isn't loading anymore, it means the query failed.\n            // In that case, we set authenticated to false unless there's no authProvider.\n            authenticated:\n                result.data ?? result.isLoading ? true : authProvider == null, // Optimisic\n            isLoading: result.isLoading,\n            error: result.error,\n        };\n    }, [authProvider, result]);\n};\n\nexport default useAuthState;\n\nconst getErrorMessage = (error, defaultMessage) =>\n    typeof error === 'string'\n        ? error\n        : typeof error === 'undefined' || !error.message\n        ? defaultMessage\n        : error.message;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}