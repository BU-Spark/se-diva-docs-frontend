{"ast":null,"code":"import { useQuery } from 'react-query';\nimport { useDataProvider } from './useDataProvider';\n/**\n * Call the dataProvider.getOne() method and return the resolved value\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, isFetching: true, refetch }\n * - success: { data: [data from response], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getOne parameters { id, meta }, e.g. { id: 123 }\n * @param {Options} options Options object to pass to the react-query queryClient.\n *\n * @typedef Params\n * @prop id a resource identifier, e.g. 123\n *\n * @typedef Options\n * @prop enabled Flag to conditionally run the query. If it's false, the query will not run\n * @prop onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @prop onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetOne, useRecordContext } from 'react-admin';\n *\n * const UserProfile = () => {\n *     const record = useRecordContext();\n *     const { data, isLoading, error } = useGetOne('users', { id: record.id });\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <div>User {data.username}</div>;\n * };\n */\nexport var useGetOne = function (resource, _a, options) {\n  var id = _a.id,\n    meta = _a.meta;\n  var dataProvider = useDataProvider();\n  return useQuery(\n  // Sometimes the id comes as a string (e.g. when read from the URL in a Show view).\n  // Sometimes the id comes as a number (e.g. when read from a Record in useGetList response).\n  // As the react-query cache is type-sensitive, we always stringify the identifier to get a match\n  [resource, 'getOne', {\n    id: String(id),\n    meta: meta\n  }], function () {\n    return dataProvider.getOne(resource, {\n      id: id,\n      meta: meta\n    }).then(function (_a) {\n      var data = _a.data;\n      return data;\n    });\n  }, options);\n};","map":{"version":3,"mappings":"AACA,SAASA,QAAQ,QAAyC,aAAa;AACvE,SAASC,eAAe,QAAQ,mBAAmB;AAEnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA,OAAO,IAAMC,SAAS,GAAG,UACrBC,QAAgB,EAChBC,EAAsC,EACtCC,OAAqC;MADnCC,EAAE;IAAEC,IAAI;EAGV,IAAMC,YAAY,GAAGP,eAAe,EAAE;EACtC,OAAOD,QAAQ;EACX;EACA;EACA;EACA,CAACG,QAAQ,EAAE,QAAQ,EAAE;IAAEG,EAAE,EAAEG,MAAM,CAACH,EAAE,CAAC;IAAEC,IAAI;EAAA,CAAE,CAAC,EAC9C;IACI,mBAAY,CACPG,MAAM,CAAaP,QAAQ,EAAE;MAAEG,EAAE;MAAEC,IAAI;IAAA,CAAE,CAAC,CAC1CI,IAAI,CAAC,UAACP,EAAQ;UAANQ,IAAI;MAAO,WAAI;IAAJ,CAAI,CAAC;EAF7B,CAE6B,EACjCP,OAAO,CACV;AACL,CAAC","names":["useQuery","useDataProvider","useGetOne","resource","_a","options","id","meta","dataProvider","String","getOne","then","data"],"sourceRoot":"","sources":["../../../src/dataProvider/useGetOne.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}