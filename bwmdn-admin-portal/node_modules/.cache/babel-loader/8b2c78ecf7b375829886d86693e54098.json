{"ast":null,"code":"import { useEffect } from 'react';\nimport isEqual from 'lodash/isEqual';\nimport useGetPermissions from './useGetPermissions';\nimport { useSafeSetState } from '../util/hooks';\nvar emptyParams = {};\n// keep a cache of already fetched permissions to initialize state for new\n// components and avoid a useless rerender if the permissions haven't changed\nvar alreadyFetchedPermissions = {\n  '{}': undefined\n};\n/**\n * Hook for getting user permissions without the loading state.\n *\n * When compared to usePermissions, this hook doesn't cause a re-render\n * when the permissions haven't changed since the last call.\n *\n * This hook doesn't handle the loading state.\n *\n * @see usePermissions\n *\n * Calls the authProvider.getPermissions() method asynchronously.\n * If the authProvider returns a rejected promise, returns empty permissions.\n *\n * The return value updates according to the request state:\n *\n * - start:   { permissions: [previously fetched permissions for these params] }\n * - success: { permissions: [permissions returned by the authProvider (usually the same as on start)] }\n * - error:   { error: [error from provider] }\n *\n * Useful to enable features based on user permissions\n *\n * @param {Object} params Any params you want to pass to the authProvider\n *\n * @returns The current auth check state. Destructure as { permissions, error }.\n *\n * @example\n *     import { usePermissionsOptimized } from 'react-admin';\n *\n *     const PostDetail = props => {\n *         const { permissions } = usePermissionsOptimized();\n *         if (permissions !== 'editor') {\n *             return <Redirect to={`posts/${props.id}/show`} />\n *         } else {\n *             return <PostEdit {...props} />\n *         }\n *     };\n */\nvar usePermissionsOptimized = function (params) {\n  if (params === void 0) {\n    params = emptyParams;\n  }\n  var key = JSON.stringify(params);\n  var _a = useSafeSetState({\n      permissions: alreadyFetchedPermissions[key]\n    }),\n    state = _a[0],\n    setState = _a[1];\n  var getPermissions = useGetPermissions();\n  useEffect(function () {\n    getPermissions(params).then(function (permissions) {\n      if (!isEqual(permissions, state.permissions)) {\n        alreadyFetchedPermissions[key] = permissions;\n        setState({\n          permissions: permissions\n        });\n      }\n    }).catch(function (error) {\n      setState({\n        error: error\n      });\n    });\n  }, [getPermissions, key]); // eslint-disable-line react-hooks/exhaustive-deps\n  return state;\n};\nexport default usePermissionsOptimized;","map":{"version":3,"mappings":"AAAA,SAASA,SAAS,QAAQ,OAAO;AACjC,OAAOC,OAAO,MAAM,gBAAgB;AAEpC,OAAOC,iBAAiB,MAAM,qBAAqB;AACnD,SAASC,eAAe,QAAQ,eAAe;AAO/C,IAAMC,WAAW,GAAG,EAAE;AAEtB;AACA;AACA,IAAMC,yBAAyB,GAAG;EAAE,IAAI,EAAEC;AAAS,CAAE;AAErD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,IAAMC,uBAAuB,GAAG,UAACC,MAAoB;EAApB;IAAAA,oBAAoB;EAAA;EACjD,IAAMC,GAAG,GAAGC,IAAI,CAACC,SAAS,CAACH,MAAM,CAAC;EAC5B,SAAoBL,eAAe,CAAQ;MAC7CS,WAAW,EAAEP,yBAAyB,CAACI,GAAG;KAC7C,CAAC;IAFKI,KAAK;IAAEC,QAAQ,QAEpB;EACF,IAAMC,cAAc,GAAGb,iBAAiB,EAAE;EAC1CF,SAAS,CAAC;IACNe,cAAc,CAACP,MAAM,CAAC,CACjBQ,IAAI,CAAC,qBAAW;MACb,IAAI,CAACf,OAAO,CAACW,WAAW,EAAEC,KAAK,CAACD,WAAW,CAAC,EAAE;QAC1CP,yBAAyB,CAACI,GAAG,CAAC,GAAGG,WAAW;QAC5CE,QAAQ,CAAC;UAAEF,WAAW;QAAA,CAAE,CAAC;;IAEjC,CAAC,CAAC,CACDK,KAAK,CAAC,eAAK;MACRH,QAAQ,CAAC;QACLI,KAAK;OACR,CAAC;IACN,CAAC,CAAC;EACV,CAAC,EAAE,CAACH,cAAc,EAAEN,GAAG,CAAC,CAAC,CAAC,CAAC;EAE3B,OAAOI,KAAK;AAChB,CAAC;AAED,eAAeN,uBAAuB","names":["useEffect","isEqual","useGetPermissions","useSafeSetState","emptyParams","alreadyFetchedPermissions","undefined","usePermissionsOptimized","params","key","JSON","stringify","permissions","state","setState","getPermissions","then","catch","error"],"sourceRoot":"","sources":["../../../src/auth/usePermissionsOptimized.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}