{"ast":null,"code":"import { useCallback, useEffect, useRef } from 'react';\nimport { useLocation, useNavigate } from 'react-router-dom';\nimport { useQueryClient } from 'react-query';\nimport useAuthProvider, { defaultAuthParams } from './useAuthProvider';\nimport { useResetStore } from '../store';\nimport { useBasename } from '../routing';\nimport { removeDoubleSlashes } from '../routing/useCreatePath';\n/**\n * Get a callback for calling the authProvider.logout() method,\n * redirect to the login page, and clear the store.\n *\n * @see useAuthProvider\n *\n * @returns {Function} logout callback\n *\n * @example\n *\n * import { useLogout } from 'react-admin';\n *\n * const LogoutButton = () => {\n *     const logout = useLogout();\n *     const handleClick = () => logout();\n *     return <button onClick={handleClick}>Logout</button>;\n * }\n */\nvar useLogout = function () {\n  var authProvider = useAuthProvider();\n  var queryClient = useQueryClient();\n  var resetStore = useResetStore();\n  var navigate = useNavigate();\n  // useNavigate forces rerenders on every navigation, even if we don't use the result\n  // see https://github.com/remix-run/react-router/issues/7634\n  // so we use a ref to bail out of rerenders when we don't need to\n  var navigateRef = useRef(navigate);\n  var location = useLocation();\n  var locationRef = useRef(location);\n  var basename = useBasename();\n  var loginUrl = removeDoubleSlashes(\"\".concat(basename, \"/\").concat(defaultAuthParams.loginUrl));\n  /*\n   * We need the current location to pass in the router state\n   * so that the login hook knows where to redirect to as next route after login.\n   *\n   * But if we used the location from useLocation as a dependency of the logout\n   * function, it would be rebuilt each time the user changes location.\n   * Consequently, that would force a rerender of all components using this hook\n   * upon navigation (CoreAdminRouter for example).\n   *\n   * To avoid that, we store the location in a ref.\n   */\n  useEffect(function () {\n    locationRef.current = location;\n    navigateRef.current = navigate;\n  }, [location, navigate]);\n  var logout = useCallback(function (params, redirectTo, redirectToCurrentLocationAfterLogin) {\n    if (params === void 0) {\n      params = {};\n    }\n    if (redirectTo === void 0) {\n      redirectTo = loginUrl;\n    }\n    if (redirectToCurrentLocationAfterLogin === void 0) {\n      redirectToCurrentLocationAfterLogin = true;\n    }\n    return authProvider.logout(params).then(function (redirectToFromProvider) {\n      if (redirectToFromProvider === false || redirectTo === false) {\n        resetStore();\n        queryClient.clear();\n        // do not redirect\n        return;\n      }\n      var finalRedirectTo = redirectToFromProvider || redirectTo;\n      if (finalRedirectTo === null || finalRedirectTo === void 0 ? void 0 : finalRedirectTo.startsWith('http')) {\n        // absolute link (e.g. https://my.oidc.server/login)\n        resetStore();\n        queryClient.clear();\n        window.location.href = finalRedirectTo;\n        return finalRedirectTo;\n      }\n      // redirectTo is an internal location that may contain a query string, e.g. '/login?foo=bar'\n      // we must split it to pass a structured location to navigate()\n      var redirectToParts = finalRedirectTo.split('?');\n      var newLocation = {\n        pathname: redirectToParts[0]\n      };\n      var newLocationOptions = {};\n      if (redirectToCurrentLocationAfterLogin && locationRef.current && locationRef.current.pathname) {\n        newLocationOptions = {\n          state: {\n            nextPathname: locationRef.current.pathname,\n            nextSearch: locationRef.current.search\n          }\n        };\n      }\n      if (redirectToParts[1]) {\n        newLocation.search = redirectToParts[1];\n      }\n      navigateRef.current(newLocation, newLocationOptions);\n      resetStore();\n      queryClient.clear();\n      return redirectToFromProvider;\n    });\n  }, [authProvider, resetStore, loginUrl, queryClient]);\n  var logoutWithoutProvider = useCallback(function (_) {\n    navigate({\n      pathname: loginUrl\n    }, {\n      state: {\n        nextPathname: location && location.pathname\n      }\n    });\n    resetStore();\n    queryClient.clear();\n    return Promise.resolve();\n  }, [resetStore, location, navigate, loginUrl, queryClient]);\n  return authProvider ? logout : logoutWithoutProvider;\n};\nexport default useLogout;","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useRef","useLocation","useNavigate","useQueryClient","useAuthProvider","defaultAuthParams","useResetStore","useBasename","removeDoubleSlashes","useLogout","authProvider","queryClient","resetStore","navigate","navigateRef","location","locationRef","basename","loginUrl","current","logout","params","redirectTo","redirectToCurrentLocationAfterLogin","then","redirectToFromProvider","clear","finalRedirectTo","startsWith","window","href","redirectToParts","split","newLocation","pathname","newLocationOptions","state","nextPathname","nextSearch","search","logoutWithoutProvider","Promise","resolve"],"sources":["/Users/paigedeveau/Desktop/se-diva-docs-frontend/bwmdn-admin-portal/node_modules/ra-core/src/auth/useLogout.ts"],"sourcesContent":["import { useCallback, useEffect, useRef } from 'react';\nimport { useLocation, useNavigate, Path } from 'react-router-dom';\nimport { useQueryClient } from 'react-query';\n\nimport useAuthProvider, { defaultAuthParams } from './useAuthProvider';\nimport { useResetStore } from '../store';\nimport { useBasename } from '../routing';\nimport { removeDoubleSlashes } from '../routing/useCreatePath';\n\n/**\n * Get a callback for calling the authProvider.logout() method,\n * redirect to the login page, and clear the store.\n *\n * @see useAuthProvider\n *\n * @returns {Function} logout callback\n *\n * @example\n *\n * import { useLogout } from 'react-admin';\n *\n * const LogoutButton = () => {\n *     const logout = useLogout();\n *     const handleClick = () => logout();\n *     return <button onClick={handleClick}>Logout</button>;\n * }\n */\nconst useLogout = (): Logout => {\n    const authProvider = useAuthProvider();\n    const queryClient = useQueryClient();\n    const resetStore = useResetStore();\n    const navigate = useNavigate();\n    // useNavigate forces rerenders on every navigation, even if we don't use the result\n    // see https://github.com/remix-run/react-router/issues/7634\n    // so we use a ref to bail out of rerenders when we don't need to\n    const navigateRef = useRef(navigate);\n    const location = useLocation();\n    const locationRef = useRef(location);\n    const basename = useBasename();\n    const loginUrl = removeDoubleSlashes(\n        `${basename}/${defaultAuthParams.loginUrl}`\n    );\n\n    /*\n     * We need the current location to pass in the router state\n     * so that the login hook knows where to redirect to as next route after login.\n     *\n     * But if we used the location from useLocation as a dependency of the logout\n     * function, it would be rebuilt each time the user changes location.\n     * Consequently, that would force a rerender of all components using this hook\n     * upon navigation (CoreAdminRouter for example).\n     *\n     * To avoid that, we store the location in a ref.\n     */\n    useEffect(() => {\n        locationRef.current = location;\n        navigateRef.current = navigate;\n    }, [location, navigate]);\n\n    const logout: Logout = useCallback(\n        (\n            params = {},\n            redirectTo = loginUrl,\n            redirectToCurrentLocationAfterLogin = true\n        ) =>\n            authProvider.logout(params).then(redirectToFromProvider => {\n                if (redirectToFromProvider === false || redirectTo === false) {\n                    resetStore();\n                    queryClient.clear();\n                    // do not redirect\n                    return;\n                }\n\n                const finalRedirectTo = redirectToFromProvider || redirectTo;\n\n                if (finalRedirectTo?.startsWith('http')) {\n                    // absolute link (e.g. https://my.oidc.server/login)\n                    resetStore();\n                    queryClient.clear();\n                    window.location.href = finalRedirectTo;\n                    return finalRedirectTo;\n                }\n\n                // redirectTo is an internal location that may contain a query string, e.g. '/login?foo=bar'\n                // we must split it to pass a structured location to navigate()\n                const redirectToParts = finalRedirectTo.split('?');\n                const newLocation: Partial<Path> = {\n                    pathname: redirectToParts[0],\n                };\n                let newLocationOptions = {};\n\n                if (\n                    redirectToCurrentLocationAfterLogin &&\n                    locationRef.current &&\n                    locationRef.current.pathname\n                ) {\n                    newLocationOptions = {\n                        state: {\n                            nextPathname: locationRef.current.pathname,\n                            nextSearch: locationRef.current.search,\n                        },\n                    };\n                }\n                if (redirectToParts[1]) {\n                    newLocation.search = redirectToParts[1];\n                }\n                navigateRef.current(newLocation, newLocationOptions);\n                resetStore();\n                queryClient.clear();\n\n                return redirectToFromProvider;\n            }),\n        [authProvider, resetStore, loginUrl, queryClient]\n    );\n\n    const logoutWithoutProvider = useCallback(\n        _ => {\n            navigate(\n                {\n                    pathname: loginUrl,\n                },\n                {\n                    state: {\n                        nextPathname: location && location.pathname,\n                    },\n                }\n            );\n            resetStore();\n            queryClient.clear();\n            return Promise.resolve();\n        },\n        [resetStore, location, navigate, loginUrl, queryClient]\n    );\n\n    return authProvider ? logout : logoutWithoutProvider;\n};\n\n/**\n * Log the current user out by calling the authProvider.logout() method,\n * and redirect them to the login screen.\n *\n * @param {Object} params The parameters to pass to the authProvider\n * @param {string} redirectTo The path name to redirect the user to (optional, defaults to login)\n * @param {boolean} redirectToCurrentLocationAfterLogin Whether the button shall record the current location to redirect to it after login. true by default.\n *\n * @return {Promise} The authProvider response\n */\ntype Logout = (\n    params?: any,\n    redirectTo?: string | false,\n    redirectToCurrentLocationAfterLogin?: boolean\n) => Promise<any>;\n\nexport default useLogout;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}