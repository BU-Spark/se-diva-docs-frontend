{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { useInfiniteQuery, useQueryClient } from 'react-query';\nimport { useDataProvider } from './useDataProvider';\n/**\n * Call the dataProvider.getList() method and return the resolved result\n * as well as the loading state. The return from useInfiniteGetList is equivalent to the return from react-hook form useInfiniteQuery.\n *\n * @see https://react-query-v3.tanstack.com/reference/useInfiniteQuery\n *\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getList parameters { pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { fetchNextPage(); } }\n *\n * @typedef Params\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, total, error, isLoading, isSuccess, hasNextPage, fetchNextPage }.\n *\n * @example\n *\n * import { useInfinteGetList } from 'react-admin';\n *\n * const LatestNews = () => {\n *     const { data, total, isLoading, error, hasNextPage, fetchNextPage } = useInfiniteGetList(\n *         'posts',\n *         { pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *        <>\n *            <ul>\n *                {data?.pages.map(page => {\n *                    return page.data.map(post => (\n *                        <li key={post.id}>{post.title}</li>\n *                    ));\n *                })}\n *            </ul>\n *            <div>\n *                <button disabled={!hasNextPage} onClick={() => fetchNextPage()}>\n *                    Fetch next page\n *                </button>\n *            </div>\n *        </>\n *    );\n * };\n */\nexport var useInfiniteGetList = function (resource, params, options) {\n  var _a, _b;\n  if (params === void 0) {\n    params = {};\n  }\n  var _c = params.pagination,\n    pagination = _c === void 0 ? {\n      page: 1,\n      perPage: 25\n    } : _c,\n    _d = params.sort,\n    sort = _d === void 0 ? {\n      field: 'id',\n      order: 'DESC'\n    } : _d,\n    _e = params.filter,\n    filter = _e === void 0 ? {} : _e,\n    meta = params.meta;\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var result = useInfiniteQuery([resource, 'getList', {\n    pagination: pagination,\n    sort: sort,\n    filter: filter,\n    meta: meta\n  }], function (_a) {\n    var _b = _a.pageParam,\n      pageParam = _b === void 0 ? pagination.page : _b;\n    return dataProvider.getList(resource, {\n      pagination: {\n        page: pageParam,\n        perPage: pagination.perPage\n      },\n      sort: sort,\n      filter: filter,\n      meta: meta\n    }).then(function (_a) {\n      var data = _a.data,\n        pageInfo = _a.pageInfo,\n        total = _a.total;\n      return {\n        data: data,\n        total: total,\n        pageParam: pageParam,\n        pageInfo: pageInfo\n      };\n    });\n  }, __assign(__assign({\n    onSuccess: function (data) {\n      // optimistically populate the getOne cache\n      data.pages.forEach(function (page) {\n        page.data.forEach(function (record) {\n          queryClient.setQueryData([resource, 'getOne', {\n            id: String(record.id),\n            meta: meta\n          }], function (oldRecord) {\n            return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;\n          });\n        });\n      });\n    }\n  }, options), {\n    getNextPageParam: function (lastLoadedPage) {\n      if (lastLoadedPage.pageInfo) {\n        return lastLoadedPage.pageInfo.hasNextPage ? lastLoadedPage.pageParam + 1 : undefined;\n      }\n      var totalPages = Math.ceil((lastLoadedPage.total || 0) / pagination.perPage);\n      return lastLoadedPage.pageParam < totalPages ? Number(lastLoadedPage.pageParam) + 1 : undefined;\n    },\n    getPreviousPageParam: function (lastLoadedPage) {\n      if (lastLoadedPage.pageInfo) {\n        return lastLoadedPage.pageInfo.hasPreviousPage ? lastLoadedPage.pageParam - 1 : undefined;\n      }\n      return lastLoadedPage.pageParam === 1 ? undefined : lastLoadedPage.pageParam - 1;\n    }\n  }));\n  return result.data ? __assign(__assign({}, result), {\n    data: result.data,\n    total: ((_b = (_a = result.data) === null || _a === void 0 ? void 0 : _a.pages[0]) === null || _b === void 0 ? void 0 : _b.total) || 0\n  }) : result;\n};","map":{"version":3,"mappings":"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","names":["useInfiniteQuery","useQueryClient","useDataProvider","useInfiniteGetList","resource","params","options","pagination","page","perPage","_d","sort","field","order","_e","filter","meta","dataProvider","queryClient","result","_a","_b","pageParam","getList","then","data","pageInfo","total","onSuccess","pages","forEach","setQueryData","id","String","record","oldRecord","getNextPageParam","lastLoadedPage","hasNextPage","undefined","totalPages","Math","ceil","Number","getPreviousPageParam","hasPreviousPage","__assign"],"sources":["/Users/paigedeveau/node_modules/ra-core/src/dataProvider/useInfiniteGetList.ts"],"sourcesContent":["import {\n    useInfiniteQuery,\n    UseInfiniteQueryOptions,\n    UseInfiniteQueryResult,\n    useQueryClient,\n} from 'react-query';\n\nimport { RaRecord, GetListParams, GetInfiniteListResult } from '../types';\nimport { useDataProvider } from './useDataProvider';\n\n/**\n * Call the dataProvider.getList() method and return the resolved result\n * as well as the loading state. The return from useInfiniteGetList is equivalent to the return from react-hook form useInfiniteQuery.\n *\n * @see https://react-query-v3.tanstack.com/reference/useInfiniteQuery\n *\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getList parameters { pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { fetchNextPage(); } }\n *\n * @typedef Params\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, total, error, isLoading, isSuccess, hasNextPage, fetchNextPage }.\n *\n * @example\n *\n * import { useInfinteGetList } from 'react-admin';\n *\n * const LatestNews = () => {\n *     const { data, total, isLoading, error, hasNextPage, fetchNextPage } = useInfiniteGetList(\n *         'posts',\n *         { pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *        <>\n *            <ul>\n *                {data?.pages.map(page => {\n *                    return page.data.map(post => (\n *                        <li key={post.id}>{post.title}</li>\n *                    ));\n *                })}\n *            </ul>\n *            <div>\n *                <button disabled={!hasNextPage} onClick={() => fetchNextPage()}>\n *                    Fetch next page\n *                </button>\n *            </div>\n *        </>\n *    );\n * };\n */\n\nexport const useInfiniteGetList = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: Partial<GetListParams> = {},\n    options?: UseInfiniteQueryOptions<GetInfiniteListResult<RecordType>, Error>\n): UseInfiniteGetListHookValue<RecordType> => {\n    const {\n        pagination = { page: 1, perPage: 25 },\n        sort = { field: 'id', order: 'DESC' },\n        filter = {},\n        meta,\n    } = params;\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n\n    const result = useInfiniteQuery<\n        GetInfiniteListResult<RecordType>,\n        Error,\n        GetInfiniteListResult<RecordType>\n    >(\n        [resource, 'getList', { pagination, sort, filter, meta }],\n        ({ pageParam = pagination.page }) =>\n            dataProvider\n                .getList<RecordType>(resource, {\n                    pagination: {\n                        page: pageParam,\n                        perPage: pagination.perPage,\n                    },\n                    sort,\n                    filter,\n                    meta,\n                })\n                .then(({ data, pageInfo, total }) => ({\n                    data,\n                    total,\n                    pageParam,\n                    pageInfo,\n                })),\n        {\n            onSuccess: data => {\n                // optimistically populate the getOne cache\n                data.pages.forEach(page => {\n                    page.data.forEach(record => {\n                        queryClient.setQueryData(\n                            [\n                                resource,\n                                'getOne',\n                                { id: String(record.id), meta },\n                            ],\n                            oldRecord => oldRecord ?? record\n                        );\n                    });\n                });\n            },\n            ...options,\n            getNextPageParam: lastLoadedPage => {\n                if (lastLoadedPage.pageInfo) {\n                    return lastLoadedPage.pageInfo.hasNextPage\n                        ? lastLoadedPage.pageParam + 1\n                        : undefined;\n                }\n                const totalPages = Math.ceil(\n                    (lastLoadedPage.total || 0) / pagination.perPage\n                );\n\n                return lastLoadedPage.pageParam < totalPages\n                    ? Number(lastLoadedPage.pageParam) + 1\n                    : undefined;\n            },\n            getPreviousPageParam: lastLoadedPage => {\n                if (lastLoadedPage.pageInfo) {\n                    return lastLoadedPage.pageInfo.hasPreviousPage\n                        ? lastLoadedPage.pageParam - 1\n                        : undefined;\n                }\n\n                return lastLoadedPage.pageParam === 1\n                    ? undefined\n                    : lastLoadedPage.pageParam - 1;\n            },\n        }\n    );\n\n    return (result.data\n        ? {\n              ...result,\n              data: result.data,\n              total: result.data?.pages[0]?.total || 0,\n          }\n        : result) as UseInfiniteQueryResult<\n        GetInfiniteListResult<RecordType>,\n        Error\n    > & {\n        total?: number;\n    };\n};\n\nexport type UseInfiniteGetListHookValue<\n    RecordType extends RaRecord = any\n> = UseInfiniteQueryResult<GetInfiniteListResult<RecordType>, Error> & {\n    total?: number;\n    pageParam?: number;\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}