{"ast":null,"code":"import { useState, useEffect } from 'react';\nimport isEqual from 'lodash/isEqual';\nimport { useEventCallback } from '../util';\nimport { useStoreContext } from './useStoreContext';\n/**\n * Read and write a value from the Store\n *\n * useState-like hook using the global Store for persistence.\n * Each time a store value is changed, all components using this value will be re-rendered.\n *\n * @param {string} key Name of the store key. Separate with dots to namespace, e.g. 'posts.list.columns'.\n * @param {any} defaultValue Default value\n *\n * @return {Object} A value and a setter for the value, in an array - just like for useState()\n *\n * @example\n * import { useStore } from 'react-admin';\n *\n * const PostList = props => {\n *     const [density] = useStore('posts.list.density', 'small');\n *\n *     return (\n *         <List {...props}>\n *             <Datagrid size={density}>\n *                 ...\n *             </Datagrid>\n *         </List>\n *     );\n * }\n *\n * // Clicking on this button will trigger a rerender of the PostList!\n * const ChangeDensity: FC<any> = () => {\n *     const [density, setDensity] = useStore('posts.list.density', 'small');\n *\n *     const changeDensity = (): void => {\n *         setDensity(density === 'small' ? 'medium' : 'small');\n *     };\n *\n *     return (\n *         <Button onClick={changeDensity}>\n *             {`Change density (current ${density})`}\n *         </Button>\n *     );\n * };\n */\nexport var useStore = function (key, defaultValue) {\n  var _a = useStoreContext(),\n    getItem = _a.getItem,\n    setItem = _a.setItem,\n    subscribe = _a.subscribe;\n  var _b = useState(function () {\n      return getItem(key, defaultValue);\n    }),\n    value = _b[0],\n    setValue = _b[1];\n  // subscribe to changes on this key, and change the state when they happen\n  useEffect(function () {\n    var storedValue = getItem(key, defaultValue);\n    if (!isEqual(value, storedValue)) {\n      setValue(storedValue);\n    }\n    var unsubscribe = subscribe(key, function (newValue) {\n      setValue(typeof newValue === 'undefined' ? defaultValue : newValue);\n    });\n    return function () {\n      return unsubscribe();\n    };\n  }, [key, subscribe, defaultValue, getItem, value]);\n  var set = useEventCallback(function (valueParam, runtimeDefaultValue) {\n    var newValue = typeof valueParam === 'function' ? valueParam(value) : valueParam;\n    // we only set the value in the Store;\n    // the value in the local state will be updated\n    // by the useEffect during the next render\n    setItem(key, typeof newValue === 'undefined' ? typeof runtimeDefaultValue === 'undefined' ? defaultValue : runtimeDefaultValue : newValue);\n  }, [key, setItem, defaultValue, value]);\n  return [value, set];\n};","map":{"version":3,"mappings":"AAAA,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC3C,OAAOC,OAAO,MAAM,gBAAgB;AAEpC,SAASC,gBAAgB,QAAQ,SAAS;AAC1C,SAASC,eAAe,QAAQ,mBAAmB;AAEnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCA,OAAO,IAAMC,QAAQ,GAAG,UACpBC,GAAW,EACXC,YAAgB;EAEV,SAAkCH,eAAe,EAAE;IAAjDI,OAAO;IAAEC,OAAO;IAAEC,SAAS,eAAsB;EACnD,SAAoBV,QAAQ,CAAC;MAAM,cAAO,CAACM,GAAG,EAAEC,YAAY,CAAC;IAA1B,CAA0B,CAAC;IAA7DI,KAAK;IAAEC,QAAQ,QAA8C;EAEpE;EACAX,SAAS,CAAC;IACN,IAAMY,WAAW,GAAGL,OAAO,CAACF,GAAG,EAAEC,YAAY,CAAC;IAC9C,IAAI,CAACL,OAAO,CAACS,KAAK,EAAEE,WAAW,CAAC,EAAE;MAC9BD,QAAQ,CAACC,WAAW,CAAC;;IAEzB,IAAMC,WAAW,GAAGJ,SAAS,CAACJ,GAAG,EAAE,kBAAQ;MACvCM,QAAQ,CAAC,OAAOG,QAAQ,KAAK,WAAW,GAAGR,YAAY,GAAGQ,QAAQ,CAAC;IACvE,CAAC,CAAC;IACF,OAAO;MAAM,kBAAW,EAAE;IAAb,CAAa;EAC9B,CAAC,EAAE,CAACT,GAAG,EAAEI,SAAS,EAAEH,YAAY,EAAEC,OAAO,EAAEG,KAAK,CAAC,CAAC;EAElD,IAAMK,GAAG,GAAGb,gBAAgB,CACxB,UAACc,UAAa,EAAEC,mBAAsB;IAClC,IAAMH,QAAQ,GACV,OAAOE,UAAU,KAAK,UAAU,GAC1BA,UAAU,CAACN,KAAK,CAAC,GACjBM,UAAU;IACpB;IACA;IACA;IACAR,OAAO,CACHH,GAAG,EACH,OAAOS,QAAQ,KAAK,WAAW,GACzB,OAAOG,mBAAmB,KAAK,WAAW,GACtCX,YAAY,GACZW,mBAAmB,GACvBH,QAAQ,CACjB;EACL,CAAC,EACD,CAACT,GAAG,EAAEG,OAAO,EAAEF,YAAY,EAAEI,KAAK,CAAC,CACtC;EACD,OAAO,CAACA,KAAK,EAAEK,GAAG,CAAC;AACvB,CAAC","names":["useState","useEffect","isEqual","useEventCallback","useStoreContext","useStore","key","defaultValue","getItem","setItem","subscribe","value","setValue","storedValue","unsubscribe","newValue","set","valueParam","runtimeDefaultValue"],"sources":["/Users/paigedeveau/node_modules/ra-core/src/store/useStore.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport isEqual from 'lodash/isEqual';\n\nimport { useEventCallback } from '../util';\nimport { useStoreContext } from './useStoreContext';\n\n/**\n * Read and write a value from the Store\n *\n * useState-like hook using the global Store for persistence.\n * Each time a store value is changed, all components using this value will be re-rendered.\n *\n * @param {string} key Name of the store key. Separate with dots to namespace, e.g. 'posts.list.columns'.\n * @param {any} defaultValue Default value\n *\n * @return {Object} A value and a setter for the value, in an array - just like for useState()\n *\n * @example\n * import { useStore } from 'react-admin';\n *\n * const PostList = props => {\n *     const [density] = useStore('posts.list.density', 'small');\n *\n *     return (\n *         <List {...props}>\n *             <Datagrid size={density}>\n *                 ...\n *             </Datagrid>\n *         </List>\n *     );\n * }\n *\n * // Clicking on this button will trigger a rerender of the PostList!\n * const ChangeDensity: FC<any> = () => {\n *     const [density, setDensity] = useStore('posts.list.density', 'small');\n *\n *     const changeDensity = (): void => {\n *         setDensity(density === 'small' ? 'medium' : 'small');\n *     };\n *\n *     return (\n *         <Button onClick={changeDensity}>\n *             {`Change density (current ${density})`}\n *         </Button>\n *     );\n * };\n */\nexport const useStore = <T = any>(\n    key: string,\n    defaultValue?: T\n): useStoreResult<T> => {\n    const { getItem, setItem, subscribe } = useStoreContext();\n    const [value, setValue] = useState(() => getItem(key, defaultValue));\n\n    // subscribe to changes on this key, and change the state when they happen\n    useEffect(() => {\n        const storedValue = getItem(key, defaultValue);\n        if (!isEqual(value, storedValue)) {\n            setValue(storedValue);\n        }\n        const unsubscribe = subscribe(key, newValue => {\n            setValue(typeof newValue === 'undefined' ? defaultValue : newValue);\n        });\n        return () => unsubscribe();\n    }, [key, subscribe, defaultValue, getItem, value]);\n\n    const set = useEventCallback(\n        (valueParam: T, runtimeDefaultValue: T) => {\n            const newValue =\n                typeof valueParam === 'function'\n                    ? valueParam(value)\n                    : valueParam;\n            // we only set the value in the Store;\n            // the value in the local state will be updated\n            // by the useEffect during the next render\n            setItem(\n                key,\n                typeof newValue === 'undefined'\n                    ? typeof runtimeDefaultValue === 'undefined'\n                        ? defaultValue\n                        : runtimeDefaultValue\n                    : newValue\n            );\n        },\n        [key, setItem, defaultValue, value]\n    );\n    return [value, set];\n};\n\nexport type useStoreResult<T = any> = [\n    T,\n    (value: T | ((value: T) => void), defaultValue?: T) => void\n];\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}