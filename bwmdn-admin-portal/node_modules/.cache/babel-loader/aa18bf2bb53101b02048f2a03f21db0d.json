{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, useMemo, useRef } from 'react';\n/**\n * Internal hook used to handle mutation middlewares.\n *\n * @example\n * // We have a form creating an order for a new customer.\n * // The form contains the customer fields in addition to the order fields\n * // but they should be saved as a new customer resource record\n * // and the order should only reference this new customer\n * type Order = { id: string; reference: string };\n * type OrderCreateFormData = { id: string; reference: string; customer: Customer };\n * type Customer = { id: string; email: string; firstName: string; lastName: string };\n *\n * const CustomerForm = props => {\n *     const [createCustomer] = useCreate<Customer>();\n *     const middleware: Middleware<UseCreateResult<OrderCreateFormData>[0]> = useCallback(async (resource, params, options, next) => {\n *         const { data } = params;\n *         const { user, ...orderData } = data;\n *         await createCustomer(\n *             'customers',\n *             { data: user },\n *             {\n *                 onSuccess: (newCustomer) => {\n *                     const orderDataWithCustomer = { ...orderData, customerId: newCustomer.id };\n *                     next(resource, { data: orderDataWithCustomer }, options);\n *                 },\n *             }\n *         });\n *     }, [createCustomer]);\n *     useRegisterMutationMiddleware(middleware);\n *\n *     return (\n *         <>\n *             <TextInput source=\"user.email\" />\n *             <TextInput source=\"user.firstName\" />\n *             <TextInput source=\"user.lastName\" />\n *         </>\n *     );\n * }\n */\nexport var useMutationMiddlewares = function () {\n  var callbacks = useRef([]);\n  var registerMutationMiddleware = useCallback(function (callback) {\n    callbacks.current.push(callback);\n  }, []);\n  var unregisterMutationMiddleware = useCallback(function (callback) {\n    callbacks.current = callbacks.current.filter(function (cb) {\n      return cb !== callback;\n    });\n  }, []);\n  var getMutateWithMiddlewares = useCallback(function (fn) {\n    return function () {\n      var _a;\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var index = callbacks.current.length - 1;\n      // Called by middlewares to call the next middleware function\n      // Should take the same arguments as the original mutation function\n      var next = function () {\n        var _a;\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          newArgs[_i] = arguments[_i];\n        }\n        // Decrement the middlewares counter so that when next is called again, we\n        // call the next middleware\n        index--;\n        // If there are no more middlewares, we call the original mutation function\n        if (index >= 0) {\n          return (_a = callbacks.current)[index].apply(_a, __spreadArray(__spreadArray([], newArgs, false), [next], false));\n        } else {\n          return fn.apply(void 0, newArgs);\n        }\n      };\n      if (callbacks.current.length > 0) {\n        // Call the first middleware with the same args as the original mutation function\n        // with an additional next function\n        return (_a = callbacks.current)[index].apply(_a, __spreadArray(__spreadArray([], args, false), [next], false));\n      }\n      return fn.apply(void 0, args);\n    };\n  }, []);\n  var functions = useMemo(function () {\n    return {\n      registerMutationMiddleware: registerMutationMiddleware,\n      getMutateWithMiddlewares: getMutateWithMiddlewares,\n      unregisterMutationMiddleware: unregisterMutationMiddleware\n    };\n  }, [registerMutationMiddleware, getMutateWithMiddlewares, unregisterMutationMiddleware]);\n  return functions;\n};","map":{"version":3,"mappings":";;;;;;;;;AAAA,SAASA,WAAW,EAAEC,OAAO,EAAEC,MAAM,QAAQ,OAAO;AAEpD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA,OAAO,IAAMC,sBAAsB,GAAG;EAGlC,IAAMC,SAAS,GAAGF,MAAM,CAA2B,EAAE,CAAC;EAEtD,IAAMG,0BAA0B,GAAGL,WAAW,CAC1C,UAACM,QAAgC;IAC7BF,SAAS,CAACG,OAAO,CAACC,IAAI,CAACF,QAAQ,CAAC;EACpC,CAAC,EACD,EAAE,CACL;EAED,IAAMG,4BAA4B,GAAGT,WAAW,CAC5C,UAACM,QAAgC;IAC7BF,SAAS,CAACG,OAAO,GAAGH,SAAS,CAACG,OAAO,CAACG,MAAM,CAAC,YAAE;MAAI,SAAE,KAAKJ,QAAQ;IAAf,CAAe,CAAC;EACvE,CAAC,EACD,EAAE,CACL;EAED,IAAMK,wBAAwB,GAAGX,WAAW,CAAC,UAACY,EAAc;IACxD,OAAO;;MAAC;WAAA,UAA+B,EAA/BC,qBAA+B,EAA/BA,IAA+B;QAA/BC;;MACJ,IAAIC,KAAK,GAAGX,SAAS,CAACG,OAAO,CAACS,MAAM,GAAG,CAAC;MAExC;MACA;MACA,IAAMC,IAAI,GAAG;;QAAC;aAAA,UAAe,EAAfJ,qBAAe,EAAfA,IAAe;UAAfK;;QACV;QACA;QACAH,KAAK,EAAE;QAEP;QACA,IAAIA,KAAK,IAAI,CAAC,EAAE;UACZ,OAAO,eAAS,CAACR,OAAO,EAACQ,KAAK,CAAC,2CAAIG,OAAO,WAAED,IAAI;SACnD,MAAM;UACH,OAAOL,EAAE,eAAIM,OAAO;;MAE5B,CAAC;MAED,IAAId,SAAS,CAACG,OAAO,CAACS,MAAM,GAAG,CAAC,EAAE;QAC9B;QACA;QACA,OAAO,eAAS,CAACT,OAAO,EAACQ,KAAK,CAAC,2CAAID,IAAI,WAAEG,IAAI;;MAGjD,OAAOL,EAAE,eAAIE,IAAI;IACrB,CAAC;EACL,CAAC,EAAE,EAAE,CAAC;EAEN,IAAMK,SAAS,GAAGlB,OAAO,CACrB;IAAM,OAAC;MACHI,0BAA0B;MAC1BM,wBAAwB;MACxBF,4BAA4B;KAC/B;EAJK,CAIJ,EACF,CACIJ,0BAA0B,EAC1BM,wBAAwB,EACxBF,4BAA4B,CAC/B,CACJ;EAED,OAAOU,SAAS;AACpB,CAAC","names":["useCallback","useMemo","useRef","useMutationMiddlewares","callbacks","registerMutationMiddleware","callback","current","push","unregisterMutationMiddleware","filter","getMutateWithMiddlewares","fn","_i","args","index","length","next","newArgs","functions"],"sourceRoot":"","sources":["../../../../src/controller/saveContext/useMutationMiddlewares.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}