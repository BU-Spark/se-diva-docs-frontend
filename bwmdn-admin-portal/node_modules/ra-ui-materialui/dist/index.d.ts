import * as React from 'react';
import React__default, { HtmlHTMLAttributes, ReactNode, FunctionComponent, ReactElement, ElementType, ReactEventHandler, MouseEvent as MouseEvent$1, ComponentType, FC, AnchorHTMLAttributes, ChangeEvent, MouseEventHandler, ErrorInfo } from 'react';
import * as PropTypes from 'prop-types';
import PropTypes__default, { ReactComponentLike } from 'prop-types';
import * as _mui_material from '@mui/material';
import { SxProps, ButtonProps as ButtonProps$1, PropTypes as PropTypes$1, IconButtonProps, ThemeOptions, TabProps as TabProps$1, StackProps, ToolbarProps as ToolbarProps$1, TypographyProps, LinkProps as LinkProps$1, Theme, FormControlProps, AutocompleteProps, TextFieldProps as TextFieldProps$1, TableRowProps, TableBodyProps, TableProps, AppBarProps as AppBarProps$1, TooltipProps, MenuItemProps as MenuItemProps$1, SnackbarProps, DrawerProps, TabsProps as TabsProps$1, BoxProps, ListItemProps, TablePaginationBaseProps, PaginationProps as PaginationProps$1, ListProps as ListProps$1 } from '@mui/material';
import { MenuItemProps } from '@mui/material/MenuItem';
import * as ra_core from 'ra-core';
import { RedirectionSideEffect, RaRecord, MutationMode, Identifier, UseUpdateMutateParams, TransformData, UseCreateMutateParams, Exporter, SaveContextValue, DeleteParams, FilterPayload, SortPayload, CreateParams, UpdateParams, CreateControllerProps, InferredTypeMap, EditControllerProps, FormProps, ListControllerProps, LinkToType, UseReferenceResult, ChoicesProps, UseTranslatableOptions, InputProps, OptionText, UseSuggestionsOptions, ValidationErrorMessage, TitleComponent, CoreLayoutProps, ListFilterContextValue, CoreAdminUIProps, CoreAdminContextProps } from 'ra-core';
import { Path } from 'react-router';
import * as _mui_system from '@mui/system';
import { SxProps as SxProps$1, ResponsiveStyleValue } from '@mui/system';
import { UseQueryOptions, UseMutationOptions } from 'react-query';
import { ButtonProps as ButtonProps$2 } from '@mui/material/Button';
import { IconButtonProps as IconButtonProps$1 } from '@mui/material/IconButton';
import { TabsProps } from '@mui/material/Tabs';
import { TableCellProps } from '@mui/material/TableCell';
import { SvgIconComponent } from '@mui/icons-material';
import { ChipProps } from '@mui/material/Chip';
import { TypographyProps as TypographyProps$1 } from '@mui/material/Typography';
import { TabProps as TabProps$2 } from '@mui/material/Tab';
import { Property } from 'csstype';
import { UseFieldArrayReturn, FieldValues } from 'react-hook-form';
import { FormGroupProps } from '@mui/material/FormGroup';
import { SwitchProps } from '@mui/material/Switch';
import { FormControlProps as FormControlProps$1 } from '@mui/material/FormControl';
import { CheckboxProps } from '@mui/material/Checkbox';
import { TextFieldProps as TextFieldProps$2 } from '@mui/material/TextField';
import { DropzoneOptions } from 'react-dropzone';
import { RadioGroupProps } from '@mui/material/RadioGroup';
import { FallbackProps } from 'react-error-boundary';
import { LinearProgressProps as LinearProgressProps$1 } from '@mui/material/LinearProgress';
import * as _mui_material_OverridableComponent from '@mui/material/OverridableComponent';
import * as _mui_material_ButtonBase_TouchRipple from '@mui/material/ButtonBase/TouchRipple';
import { LinkProps as LinkProps$2 } from 'react-router-dom';
import { ToolbarProps as ToolbarProps$2 } from '@mui/material/Toolbar';
import * as _emotion_styled from '@emotion/styled';
import { ListProps as ListProps$2 } from '@mui/material/List';

/**
 * A standalone login page, to serve as authentication gate to the admin
 *
 * Expects the user to enter a login and a password, which will be checked
 * by the `authProvider.login()` method. Redirects to the root page (/)
 * upon success, otherwise displays an authentication error message.
 *
 * Copy and adapt this component to implement your own login logic
 * (e.g. to authenticate via email or facebook or anything else).
 *
 * @example
 *     import MyLoginPage from './MyLoginPage';
 *     const App = () => (
 *         <Admin loginPage={MyLoginPage} authProvider={authProvider}>
 *             ...
 *        </Admin>
 *     );
 */
declare const Login: {
    (props: LoginProps): JSX.Element;
    propTypes: {
        backgroundImage: PropTypes__default.Requireable<string>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        className: PropTypes__default.Requireable<string>;
    };
    defaultProps: {
        children: JSX.Element;
    };
};
interface LoginProps extends HtmlHTMLAttributes<HTMLDivElement> {
    backgroundImage?: string;
    children?: ReactNode;
    className?: string;
    sx?: SxProps;
}
declare const LoginClasses: {
    card: string;
    avatar: string;
    icon: string;
};

declare const LoginForm: {
    (props: LoginFormProps): JSX.Element;
    propTypes: {
        redirectTo: PropTypes__default.Requireable<string>;
    };
};
declare const LoginFormClasses: {
    content: string;
    button: string;
    icon: string;
};
interface LoginFormProps {
    redirectTo?: string;
    className?: string;
}

/**
 * Logout button component, to be passed to the Admin component
 *
 * Used for the Logout Menu item in the sidebar
 */
declare const Logout: FunctionComponent<LogoutProps & MenuItemProps<'li'>>;
declare const LogoutClasses: {
    icon: string;
};
interface LogoutProps {
    className?: string;
    redirectTo?: string;
    icon?: ReactElement;
}

declare type LocationDescriptor = Partial<Path> & {
    redirect?: boolean;
    state?: any;
    replace?: boolean;
};
/**
 * A generic Button with side icon. Only the icon is displayed on small screens.
 *
 * The component translates the label. Pass the icon as child.
 * The icon displays on the left side of the button by default. Set alignIcon prop to 'right' to inverse.
 *
 * @example
 *
 * <Button label="Edit" color="secondary" onClick={doEdit}>
 *   <ContentCreate />
 * </Button>
 *
 */
declare const Button: {
    (props: ButtonProps): JSX.Element;
    propTypes: {
        alignIcon: PropTypes__default.Requireable<string>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        className: PropTypes__default.Requireable<string>;
        color: PropTypes__default.Requireable<string>;
        disabled: PropTypes__default.Requireable<boolean>;
        label: PropTypes__default.Requireable<string>;
        size: PropTypes__default.Requireable<string>;
    };
};
interface Props$f {
    alignIcon?: 'left' | 'right';
    children?: ReactElement;
    className?: string;
    color?: PropTypes$1.Color;
    component?: ElementType;
    to?: string | LocationDescriptor;
    disabled?: boolean;
    label?: string;
    size?: 'small' | 'medium' | 'large';
    redirect?: RedirectionSideEffect;
    variant?: string;
    record?: RaRecord;
    resource?: string;
    mutationMode?: MutationMode;
}
declare type ButtonProps = Props$f & ButtonProps$1;
declare const sanitizeButtonRestProps: ({ invalid, pristine, record, redirect, resource, mutationMode, hasCreate, ...rest }: any) => any;

interface Props$e {
    record?: Partial<RaRecord>;
    icon?: ReactElement;
    scrollToTop?: boolean;
}
declare type CloneButtonProps = Props$e & Omit<ButtonProps, 'record'>;
declare const _default$5: React.MemoExoticComponent<{
    (props: CloneButtonProps): JSX.Element;
    propTypes: {
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        label: PropTypes__default.Requireable<string>;
        record: PropTypes__default.Requireable<any>;
    };
}>;

interface Props$d {
    resource?: string;
    icon?: ReactElement;
    scrollToTop?: boolean;
}
declare type CreateButtonProps = Props$d & ButtonProps;
declare const CreateButtonClasses: {
    floating: string;
};
declare const _default$4: React.MemoExoticComponent<{
    (props: CreateButtonProps): JSX.Element;
    propTypes: {
        resource: PropTypes__default.Requireable<string>;
        className: PropTypes__default.Requireable<string>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        label: PropTypes__default.Requireable<string>;
    };
}>;

interface Props$c {
    icon?: ReactElement;
    label?: string;
    record?: RaRecord;
    scrollToTop?: boolean;
}
declare type ShowButtonProps = Props$c & ButtonProps;
declare const PureShowButton: React.MemoExoticComponent<{
    (props: ShowButtonProps): JSX.Element;
    propTypes: {
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        label: PropTypes__default.Requireable<string>;
        record: PropTypes__default.Requireable<any>;
        scrollToTop: PropTypes__default.Requireable<boolean>;
    };
}>;

interface SortButtonProps {
    fields: string[];
    label?: string;
    icon?: ReactElement;
}
declare const _default$3: React.MemoExoticComponent<(props: SortButtonProps) => JSX.Element>;

interface EditProps<RecordType extends RaRecord = any> {
    actions?: ReactElement | false;
    aside?: ReactElement;
    className?: string;
    component?: ElementType;
    disableAuthentication?: boolean;
    id?: Identifier;
    mutationMode?: MutationMode;
    queryOptions?: UseQueryOptions<RecordType>;
    mutationOptions?: UseMutationOptions<RecordType, unknown, UseUpdateMutateParams<RecordType>>;
    redirect?: RedirectionSideEffect;
    resource?: string;
    transform?: TransformData;
    title?: string | ReactElement;
    sx?: SxProps$1;
}
interface CreateProps<RecordType extends RaRecord = any> {
    actions?: ReactElement | false;
    aside?: ReactElement;
    className?: string;
    component?: ElementType;
    disableAuthentication?: boolean;
    hasEdit?: boolean;
    hasShow?: boolean;
    record?: Partial<RecordType>;
    redirect?: RedirectionSideEffect;
    resource?: string;
    mutationOptions?: UseMutationOptions<RecordType, unknown, UseCreateMutateParams<RecordType>>;
    transform?: TransformData;
    title?: string | ReactElement;
    sx?: SxProps$1;
}
interface ShowProps<RecordType extends RaRecord = any> {
    actions?: ReactElement | false;
    aside?: ReactElement;
    children: ReactNode;
    className?: string;
    component?: ElementType;
    emptyWhileLoading?: boolean;
    id?: Identifier;
    queryOptions?: UseQueryOptions<RecordType>;
    resource?: string;
    title?: string | ReactElement;
    sx?: SxProps$1;
}
interface BulkActionProps {
    filterValues?: any;
    resource?: string;
    selectedIds?: Identifier[];
}

declare const BulkDeleteWithConfirmButton: {
    (props: BulkDeleteWithConfirmButtonProps): JSX.Element;
    propTypes: {
        confirmTitle: PropTypes__default.Requireable<string>;
        confirmContent: PropTypes__default.Requireable<string>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        label: PropTypes__default.Requireable<string>;
        mutationMode: PropTypes__default.Requireable<string>;
        resource: PropTypes__default.Requireable<string>;
        selectedIds: PropTypes__default.Requireable<any[]>;
    };
};
interface BulkDeleteWithConfirmButtonProps extends BulkActionProps, ButtonProps {
    confirmContent?: React.ReactNode;
    confirmTitle?: string;
    icon?: ReactElement;
    mutationMode: MutationMode;
}

declare const BulkDeleteWithUndoButton: {
    (props: BulkDeleteWithUndoButtonProps): JSX.Element;
    propTypes: {
        label: PropTypes__default.Requireable<string>;
        resource: PropTypes__default.Requireable<string>;
        selectedIds: PropTypes__default.Requireable<any[]>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
    };
};
interface BulkDeleteWithUndoButtonProps extends BulkActionProps, ButtonProps {
    icon?: ReactElement;
}

/**
 * Deletes the selected rows.
 *
 * To be used inside the <List bulkActionButtons> prop (where it's enabled by default).
 *
 * @example // basic usage
 * import * as React from 'react';
 * import { Fragment } from 'react';
 * import { BulkDeleteButton, BulkExportButton } from 'react-admin';
 *
 * const PostBulkActionButtons = () => (
 *     <Fragment>
 *         <BulkExportButton />
 *         <BulkDeleteButton />
 *     </Fragment>
 * );
 *
 * export const PostList = (props) => (
 *     <List {...props} bulkActionButtons={<PostBulkActionButtons />}>
 *         ...
 *     </List>
 * );
 */
declare const BulkDeleteButton: {
    ({ mutationMode, ...props }: BulkDeleteButtonProps): JSX.Element;
    propTypes: {
        label: PropTypes__default.Requireable<string>;
        resource: PropTypes__default.Requireable<string>;
        selectedIds: PropTypes__default.Requireable<any[]>;
        mutationMode: PropTypes__default.Requireable<string>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
    };
};
interface Props$b {
    mutationMode?: MutationMode;
}
declare type BulkDeleteButtonProps = Props$b & (BulkDeleteWithUndoButtonProps | BulkDeleteWithConfirmButtonProps);

/**
 * Export the selected rows
 *
 * To be used inside the <List bulkActionButtons> prop.
 *
 * @example // basic usage
 * import * as React from 'react';
 * import { Fragment } from 'react';
 * import { BulkDeleteButton, BulkExportButton } from 'react-admin';
 *
 * const PostBulkActionButtons = () => (
 *     <Fragment>
 *         <BulkExportButton />
 *         <BulkDeleteButton />
 *     </Fragment>
 * );
 *
 * export const PostList = (props) => (
 *     <List {...props} bulkActionButtons={<PostBulkActionButtons />}>
 *         ...
 *     </List>
 * );
 */
declare const BulkExportButton: {
    (props: BulkExportButtonProps): JSX.Element;
    propTypes: {
        exporter: PropTypes__default.Requireable<(...args: any[]) => any>;
        label: PropTypes__default.Requireable<string>;
        resource: PropTypes__default.Requireable<string>;
        selectedIds: PropTypes__default.Requireable<any[]>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
    };
};
interface Props$a {
    exporter?: Exporter;
    filterValues?: any;
    icon?: JSX.Element;
    label?: string;
    onClick?: (e: Event) => void;
    selectedIds?: Identifier[];
    resource?: string;
}
declare type BulkExportButtonProps = Props$a & ButtonProps;

declare const BulkUpdateWithConfirmButton: {
    (props: BulkUpdateWithConfirmButtonProps): JSX.Element;
    propTypes: {
        confirmTitle: PropTypes__default.Requireable<string>;
        confirmContent: PropTypes__default.Requireable<string>;
        label: PropTypes__default.Requireable<string>;
        resource: PropTypes__default.Requireable<string>;
        selectedIds: PropTypes__default.Requireable<any[]>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        data: PropTypes__default.Validator<any>;
        mutationMode: PropTypes__default.Requireable<string>;
    };
};
interface BulkUpdateWithConfirmButtonProps extends BulkActionProps, ButtonProps {
    confirmContent?: React.ReactNode;
    confirmTitle?: string;
    icon?: ReactElement;
    data: any;
    onSuccess?: () => void;
    onError?: (error: any) => void;
    mutationMode?: MutationMode;
}

declare const BulkUpdateWithUndoButton: {
    (props: BulkUpdateWithUndoButtonProps): JSX.Element;
    propTypes: {
        label: PropTypes__default.Requireable<string>;
        resource: PropTypes__default.Requireable<string>;
        selectedIds: PropTypes__default.Requireable<any[]>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        data: PropTypes__default.Validator<any>;
    };
};
interface BulkUpdateWithUndoButtonProps extends BulkActionProps, ButtonProps {
    icon?: ReactElement;
    data: any;
    onSuccess?: () => void;
    onError?: (error: any) => void;
}

/**
 * Updates the selected rows.
 *
 * To be used inside the <List bulkActionButtons> prop (where it's enabled by default).
 *
 * @example // basic usage
 * import * as React from 'react';
 * import { Fragment } from 'react';
 * import { BulkUpdateButton, BulkExportButton } from 'react-admin';
 *
 * const PostBulkActionButtons = () => (
 *     <Fragment>
 *         <BulkExportButton />
 *         <BulkUpdateButton label="Reset Views" data={{ views: 0 }} />
 *     </Fragment>
 * );
 *
 * export const PostList = (props) => (
 *     <List {...props} bulkActionButtons={<PostBulkActionButtons />}>
 *         ...
 *     </List>
 * );
 */
declare const BulkUpdateButton: {
    (props: BulkUpdateButtonProps): JSX.Element;
    propTypes: {
        label: PropTypes__default.Requireable<string>;
        resource: PropTypes__default.Requireable<string>;
        selectedIds: PropTypes__default.Requireable<any[]>;
        mutationMode: PropTypes__default.Requireable<string>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
    };
    defaultProps: {
        mutationMode: string;
        data: any[];
    };
};
interface Props$9 {
    mutationMode?: MutationMode;
}
declare type BulkUpdateButtonProps = Props$9 & (BulkUpdateWithUndoButtonProps | BulkUpdateWithConfirmButtonProps);

/**
 * Button used to delete a single record. Added by default by the <Toolbar> of edit and show views.
 *
 * @typedef {Object} Props The props you can use (other props are injected if you used it in the <Toolbar>)
 * @prop {boolean} mutationMode Either 'pessimistic', 'optimistic' or 'undoable'. Determine whether the deletion uses an undo button in a notification or a confirmation dialog. Defaults to 'undoable'.
 * @prop {Object} record The current resource record
 * @prop {string} className
 * @prop {string} label Button label. Defaults to 'ra.action.delete, translated.
 * @prop {boolean} disabled Disable the button.
 * @prop {string} variant MUI variant for the button. Defaults to 'contained'.
 * @prop {ReactElement} icon Override the icon. Defaults to the Delete icon from MUI.
 *
 * @param {Props} props
 *
 * @example Usage in the <TopToolbar> of an <Edit> form
 *
 * import * as React from 'react';
 * import { Edit, DeleteButton, TopToolbar } from 'react-admin';
 *
 * const EditActions = props => {
 *     const { data, resource } = props;
 *     return (
 *         <TopToolbar>
 *             <DeleteButton
 *                 mutationMode="pessimistic" // Renders the <DeleteWithConfirmButton>
 *             />
 *         </TopToolbar>
 *     );
 * };
 *
 * const Edit = props => {
 *     return <Edit actions={<EditActions />} {...props} />;
 * };
 */
declare const DeleteButton: {
    <RecordType extends RaRecord = any>(props: DeleteButtonProps<RecordType>): JSX.Element;
    propTypes: {
        label: PropTypes__default.Requireable<string>;
        mutationMode: PropTypes__default.Requireable<string>;
        record: PropTypes__default.Requireable<any>;
        redirect: PropTypes__default.Requireable<string | boolean | ((...args: any[]) => any)>;
        resource: PropTypes__default.Requireable<string>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
    };
};
interface DeleteButtonProps<RecordType extends RaRecord = any> extends Omit<ButtonProps, 'record'>, SaveContextValue {
    className?: string;
    confirmTitle?: string;
    confirmContent?: string;
    icon?: ReactElement;
    label?: string;
    mutationMode?: MutationMode;
    record?: RecordType;
    redirect?: RedirectionSideEffect;
    resource?: string;
    mutationOptions?: UseMutationOptions<RecordType, unknown, DeleteParams<RecordType>>;
}

declare const DeleteWithConfirmButton: {
    <RecordType extends RaRecord = any>(props: DeleteWithConfirmButtonProps<RecordType>): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        confirmTitle: PropTypes__default.Requireable<string>;
        confirmContent: PropTypes__default.Requireable<string>;
        label: PropTypes__default.Requireable<string>;
        mutationMode: PropTypes__default.Requireable<string>;
        record: PropTypes__default.Requireable<any>;
        redirect: PropTypes__default.Requireable<string | boolean | ((...args: any[]) => any)>;
        resource: PropTypes__default.Requireable<string>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        translateOptions: PropTypes__default.Requireable<object>;
    };
};
interface DeleteWithConfirmButtonProps<RecordType extends RaRecord = any> extends Omit<ButtonProps, 'record'> {
    className?: string;
    confirmTitle?: string;
    confirmContent?: React__default.ReactNode;
    icon?: ReactElement;
    label?: string;
    mutationMode?: MutationMode;
    onClick?: ReactEventHandler<any>;
    record?: RecordType;
    redirect?: RedirectionSideEffect;
    resource?: string;
    translateOptions?: object;
    mutationOptions?: UseMutationOptions<RecordType, unknown, DeleteParams<RecordType>>;
}

declare const DeleteWithUndoButton: {
    <RecordType extends RaRecord = any>(props: DeleteWithUndoButtonProps<RecordType>): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        label: PropTypes__default.Requireable<string>;
        record: PropTypes__default.Requireable<any>;
        redirect: PropTypes__default.Requireable<string | boolean | ((...args: any[]) => any)>;
        resource: PropTypes__default.Requireable<string>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
    };
};
interface DeleteWithUndoButtonProps<RecordType extends RaRecord = any> extends Omit<ButtonProps, 'record'> {
    className?: string;
    icon?: ReactElement;
    label?: string;
    onClick?: ReactEventHandler<any>;
    record?: RecordType;
    redirect?: RedirectionSideEffect;
    resource?: string;
    mutationOptions?: UseMutationOptions<RecordType, unknown, DeleteParams<RecordType>>;
}

/**
 * Opens the Edit view for the current record.
 *
 * Reads the record and resource from the context.
 *
 * @example // basic usage
 * import { EditButton } from 'react-admin';
 *
 * const CommentEditButton = () => (
 *     <EditButton label="Edit comment" />
 * );
 */
declare const EditButton: {
    (props: EditButtonProps): JSX.Element;
    propTypes: {
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        label: PropTypes__default.Requireable<string>;
        record: PropTypes__default.Requireable<any>;
        scrollToTop: PropTypes__default.Requireable<boolean>;
    };
};
interface Props$8 {
    icon?: ReactElement;
    label?: string;
    record?: RaRecord;
    scrollToTop?: boolean;
}
declare type EditButtonProps = Props$8 & ButtonProps & ButtonProps$2;

declare const ExportButton: {
    (props: ExportButtonProps): JSX.Element;
    propTypes: {
        exporter: PropTypes__default.Requireable<(...args: any[]) => any>;
        filterValues: PropTypes__default.Requireable<object>;
        label: PropTypes__default.Requireable<string>;
        maxResults: PropTypes__default.Requireable<number>;
        resource: PropTypes__default.Requireable<string>;
        sort: PropTypes__default.Requireable<Required<PropTypes__default.InferProps<{
            field: PropTypes__default.Requireable<string>;
            order: PropTypes__default.Requireable<string>;
        }>>>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
    };
};
interface Props$7 {
    exporter?: Exporter;
    filterValues?: FilterPayload;
    icon?: JSX.Element;
    label?: string;
    maxResults?: number;
    onClick?: (e: Event) => void;
    resource?: string;
    sort?: SortPayload;
}
declare type ExportButtonProps = Props$7 & ButtonProps;

/**
 * An IconButton with a tooltip which ensures the tooltip is closed on click to avoid ghost tooltips
 * when the button position changes.
 */
declare const IconButtonWithTooltip: ({ label, onClick, ...props }: IconButtonWithTooltipProps) => JSX.Element;
interface IconButtonWithTooltipProps extends IconButtonProps {
    label: string;
}

/**
 * Language selector. Changes the locale in the app and persists it in
 * preferences so that the app opens with the right locale in the future.
 *
 * @example
 *
 *     const MyAppBar: FC = props => (
 *         <AppBar {...props}>
 *             <Box flex="1">
 *                 <Typography variant="h6" id="react-admin-title"></Typography>
 *             </Box>
 *             <LocalesMenuButton
 *                 languages={[
 *                     { locale: 'en', name: 'English' },
 *                     { locale: 'fr', name: 'FranÃ§ais' },
 *                 ]}
 *             />
 *         </AppBar>
 *     );
 */
declare const LocalesMenuButton: (props: LocalesMenuButtonProps) => JSX.Element;
declare const LocalesMenuButtonClasses: {
    selectedLanguage: string;
};
interface LocalesMenuButtonProps {
    languages?: {
        locale: string;
        name: string;
    }[];
}

/**
 * Opens the List view of a given resource
 *
 * @example // basic usage
 * import { ListButton } from 'react-admin';
 *
 * const CommentListButton = () => (
 *     <ListButton label="Comments" />
 * );
 *
 * @example // linking back to the list from the Edit view
 * import { TopToolbar, ListButton, ShowButton, Edit } from 'react-admin';
 *
 * const PostEditActions = () => (
 *     <TopToolbar>
 *         <ListButton />
 *         <ShowButton />
 *     </TopToolbar>
 * );
 *
 * export const PostEdit = (props) => (
 *     <Edit actions={<PostEditActions />} {...props}>
 *         ...
 *     </Edit>
 * );
 */
declare const ListButton: {
    (props: ListButtonProps): JSX.Element;
    propTypes: {
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        label: PropTypes__default.Requireable<string>;
    };
};
interface Props$6 {
    icon?: ReactElement;
    label?: string;
    scrollToTop?: boolean;
}
declare type ListButtonProps = Props$6 & ButtonProps;

declare const RefreshButton: {
    (props: RefreshButtonProps): JSX.Element;
    propTypes: {
        label: PropTypes__default.Requireable<string>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        onClick: PropTypes__default.Requireable<(...args: any[]) => any>;
    };
};
interface Props$5 {
    label?: string;
    icon?: ReactElement;
    onClick?: (e: MouseEvent$1) => void;
}
declare type RefreshButtonProps = Props$5 & ButtonProps;

declare const RefreshIconButton: {
    (props: RefreshIconButtonProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        label: PropTypes__default.Requireable<string>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
    };
};
interface Props$4 {
    className?: string;
    icon?: ReactElement;
    label?: string;
    onClick?: (e: MouseEvent) => void;
}
declare type RefreshIconButtonProps = Props$4 & IconButtonProps$1;

/**
 * Submit button for resource forms (Edit and Create).
 *
 * @typedef {Object} Props the props you can use (other props are injected by the <Toolbar>)
 * @prop {string} className
 * @prop {string} label Button label. Defaults to 'ra.action.save', translated.
 * @prop {boolean} disabled Disable the button.
 * @prop {string} variant MUI variant for the button. Defaults to 'contained'.
 * @prop {ReactElement} icon
 * @prop {function} mutationOptions Object of options passed to react-query.
 * @prop {function} transform Callback to execute before calling the dataProvider. Receives the data from the form, must return that transformed data. Can be asynchronous (and return a Promise)
 * @prop {boolean} alwaysEnable Force enabling the <SaveButton>. If it's not defined, the `<SaveButton>` will be enabled using `react-hook-form`'s `isValidating` state props and form context's `saving` prop (disabled if isValidating or saving, enabled otherwise).
 *
 * @param {Props} props
 *
 * @example // with custom success side effect
 *
 * const MySaveButton = props => {
 *     const notify = useNotify();
 *     const redirect = useRedirect();
 *     const onSuccess = (response) => {
 *         notify(`Post "${response.data.title}" saved!`);
 *         redirect('/posts');
 *     };
 *     return <SaveButton {...props} mutationOptions={{ onSuccess }} />;
 * }
 */
declare const SaveButton: {
    <RecordType extends RaRecord = any>(props: SaveButtonProps<RecordType>): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        invalid: PropTypes__default.Requireable<boolean>;
        label: PropTypes__default.Requireable<string>;
        saving: PropTypes__default.Requireable<boolean>;
        variant: PropTypes__default.Requireable<string>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        alwaysEnable: PropTypes__default.Requireable<boolean>;
    };
};
interface Props$3<RecordType extends RaRecord = any> {
    className?: string;
    disabled?: boolean;
    icon?: ReactElement;
    invalid?: boolean;
    label?: string;
    mutationOptions?: UseMutationOptions<RecordType, unknown, CreateParams<RecordType> | UpdateParams<RecordType>>;
    transform?: TransformData;
    saving?: boolean;
    variant?: string;
    record?: RaRecord;
    resource?: string;
    mutationMode?: MutationMode;
}
declare type SaveButtonProps<RecordType extends RaRecord = any> = Props$3<RecordType> & ButtonProps$1 & {
    alwaysEnable?: boolean;
};

declare const SkipNavigationButton: () => JSX.Element;

/**
 * Button toggling the theme (light or dark).
 *
 * @example
 *
 * const MyAppBar = props => (
 *     <AppBar {...props}>
 *         <Box flex="1">
 *             <Typography variant="h6" id="react-admin-title"></Typography>
 *         </Box>
 *         <ToggleThemeButton lightTheme={lightTheme} darkTheme={darkTheme} />
 *     </AppBar>
 * );
 *
 * const MyLayout = props => <Layout {...props} appBar={MyAppBar} />;
 */
declare const ToggleThemeButton: (props: ToggleThemeButtonProps) => JSX.Element;
interface ToggleThemeButtonProps {
    darkTheme: RaThemeOptions;
    lightTheme?: RaThemeOptions;
}

declare const defaultTheme: {
    palette: {
        background: {
            default: string;
        };
        secondary: {
            light: string;
            main: string;
            dark: string;
            contrastText: string;
        };
    };
    typography: {
        h6: {
            fontWeight: number;
        };
    };
    sidebar: {
        width: number;
        closedWidth: number;
    };
    components: {
        MuiButtonBase: {
            defaultProps: {
                disableRipple: boolean;
            };
            styleOverrides: {
                root: {
                    '&:hover:active::after': {
                        content: string;
                        display: string;
                        width: string;
                        height: string;
                        position: string;
                        top: number;
                        right: number;
                        backgroundColor: string;
                        opacity: number;
                        borderRadius: string;
                    };
                    '&:focus::after': {
                        content: string;
                        display: string;
                        width: string;
                        height: string;
                        position: string;
                        top: number;
                        right: number;
                        backgroundColor: string;
                        opacity: number;
                        borderRadius: string;
                    };
                };
            };
        };
        MuiFilledInput: {
            styleOverrides: {
                root: {
                    backgroundColor: string;
                    '&$disabled': {
                        backgroundColor: string;
                    };
                };
            };
        };
        MuiTextField: {
            defaultProps: {
                variant: "filled";
                margin: "dense";
                size: "small";
            };
        };
        MuiFormControl: {
            defaultProps: {
                variant: "filled";
                margin: "dense";
                size: "small";
            };
        };
    };
};
interface RaThemeOptions extends ThemeOptions {
    sidebar?: {
        width?: number;
        closedWidth?: number;
    };
}

/**
 * Page component for the Create view
 *
 * The `<Create>` component renders the page title and actions.
 * It is not responsible for rendering the actual form -
 * that's the job of its child component (usually `<SimpleForm>`),
 * to which it passes the `record` as prop.
 *
 * The <Create> component accepts the following props:
 *
 * - actions
 * - aside
 * - component
 * - mutationOptions
 * - title
 *
 * @example
 *
 * // in src/posts.js
 * import * as React from "react";
 * import { Create, SimpleForm, TextInput } from 'react-admin';
 *
 * export const PostCreate = (props) => (
 *     <Create {...props}>
 *         <SimpleForm>
 *             <TextInput source="title" />
 *         </SimpleForm>
 *     </Create>
 * );
 *
 * // in src/App.js
 * import * as React from "react";
 * import { Admin, Resource } from 'react-admin';
 *
 * import { PostCreate } from './posts';
 *
 * const App = () => (
 *     <Admin dataProvider={...}>
 *         <Resource name="posts" create={PostCreate} />
 *     </Admin>
 * );
 * export default App;
 */
declare const Create: {
    <RecordType extends RaRecord = any>(props: CreateProps<RecordType> & {
        children: ReactElement;
    }): ReactElement;
    propTypes: {
        actions: PropTypes__default.Requireable<boolean | PropTypes__default.ReactElementLike>;
        aside: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        className: PropTypes__default.Requireable<string>;
        disableAuthentication: PropTypes__default.Requireable<boolean>;
        hasEdit: PropTypes__default.Requireable<boolean>;
        hasShow: PropTypes__default.Requireable<boolean>;
        redirect: PropTypes__default.Requireable<string | boolean | ((...args: any[]) => any)>;
        resource: PropTypes__default.Requireable<string>;
        title: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        record: PropTypes__default.Requireable<object>;
        mutationOptions: PropTypes__default.Requireable<object>;
        transform: PropTypes__default.Requireable<(...args: any[]) => any>;
        sx: PropTypes__default.Requireable<any>;
    };
};

/**
 * Action Toolbar for the Create view
 *
 * Internal component. If you want to add or remove actions for a Create view,
 * write your own CreateActions Component. Then, in the <Create> component,
 * use it in the `actions` prop to pass a custom component.
 *
 * @example
 *     import Button from '@mui/material/Button';
 *     import { TopToolbar, Create, ListButton } from 'react-admin';
 *
 *     const PostCreateActions = () => (
 *         <TopToolbar>
 *             <ListButton />
 *             // Add your custom actions here //
 *             <Button color="primary" onClick={customAction}>Custom Action</Button>
 *         </TopToolbar>
 *     );
 *
 *     export const PostCreate = (props) => (
 *         <Create actions={<PostCreateActions />} {...props}>
 *             ...
 *         </Create>
 *     );
 */
declare const CreateActions: {
    ({ className, ...rest }: CreateActionsProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        hasCreate: PropTypes__default.Requireable<boolean>;
        hasEdit: PropTypes__default.Requireable<boolean>;
        hasShow: PropTypes__default.Requireable<boolean>;
        hasList: PropTypes__default.Requireable<boolean>;
        resource: PropTypes__default.Requireable<string>;
    };
};
interface CreateActionsProps {
    className?: string;
    hasCreate?: boolean;
    hasEdit?: boolean;
    hasList?: boolean;
    hasShow?: boolean;
    resource?: string;
}

declare const CreateView: {
    (props: CreateViewProps): JSX.Element;
    propTypes: {
        actions: PropTypes__default.Requireable<boolean | PropTypes__default.ReactElementLike>;
        aside: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        className: PropTypes__default.Requireable<string>;
        defaultTitle: PropTypes__default.Requireable<any>;
        hasList: PropTypes__default.Requireable<boolean>;
        hasShow: PropTypes__default.Requireable<boolean>;
        mutationOptions: PropTypes__default.Requireable<object>;
        record: PropTypes__default.Requireable<object>;
        redirect: PropTypes__default.Requireable<string | boolean | ((...args: any[]) => any)>;
        resource: PropTypes__default.Requireable<string>;
        save: PropTypes__default.Requireable<(...args: any[]) => any>;
        title: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
    };
};
interface CreateViewProps<RecordType extends RaRecord = any> extends CreateProps<RecordType>, Omit<CreateControllerProps<RecordType>, 'resource'> {
    children: ReactElement;
}
declare const CreateClasses: {
    main: string;
    noActions: string;
    card: string;
};

/**
 * Page component for the Edit view
 *
 * The `<Edit>` component renders the page title and actions,
 * fetches the record from the data provider.
 * It is not responsible for rendering the actual form -
 * that's the job of its child component (usually `<SimpleForm>`),
 * to which it passes the `record` as prop.
 *
 * The <Edit> component accepts the following props:
 *
 * - actions
 * - aside
 * - component
 * - title
 * - mutationMode
 * - mutationOptions
 *
 * @example
 *
 * // in src/posts.js
 * import * as React from "react";
 * import { Edit, SimpleForm, TextInput } from 'react-admin';
 *
 * export const PostEdit = (props) => (
 *     <Edit {...props}>
 *         <SimpleForm>
 *             <TextInput source="title" />
 *         </SimpleForm>
 *     </Edit>
 * );
 *
 * // in src/App.js
 * import * as React from "react";
 * import { Admin, Resource } from 'react-admin';
 *
 * import { PostEdit } from './posts';
 *
 * const App = () => (
 *     <Admin dataProvider={...}>
 *         <Resource name="posts" edit={PostEdit} />
 *     </Admin>
 * );
 * export default App;
 */
declare const Edit: {
    <RecordType extends RaRecord = any>(props: EditProps<RecordType> & {
        children: ReactNode;
    }): JSX.Element;
    propTypes: {
        actions: PropTypes__default.Requireable<boolean | PropTypes__default.ReactElementLike>;
        aside: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        className: PropTypes__default.Requireable<string>;
        disableAuthentication: PropTypes__default.Requireable<boolean>;
        hasCreate: PropTypes__default.Requireable<boolean>;
        hasEdit: PropTypes__default.Requireable<boolean>;
        hasShow: PropTypes__default.Requireable<boolean>;
        hasList: PropTypes__default.Requireable<boolean>;
        id: PropTypes__default.Requireable<any>;
        mutationMode: PropTypes__default.Requireable<string>;
        mutationOptions: PropTypes__default.Requireable<object>;
        queryOptions: PropTypes__default.Requireable<object>;
        redirect: PropTypes__default.Requireable<string | boolean | ((...args: any[]) => any)>;
        resource: PropTypes__default.Requireable<string>;
        title: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        transform: PropTypes__default.Requireable<(...args: any[]) => any>;
        sx: PropTypes__default.Requireable<any>;
    };
};

/**
 * Action Toolbar for the Edit view
 *
 * Internal component. If you want to add or remove actions for an Edit view,
 * write your own EditActions Component. Then, in the <Edit> component,
 * use it in the `actions` prop to pass a custom component.
 *
 * @example
 *     import Button from '@mui/material/Button';
 *     import { TopToolbar, ShowButton, Edit } from 'react-admin';
 *
 *     const PostEditActions = ({ record, resource }) => (
 *         <TopToolbar>
 *             <ShowButton record={record} />
 *             // Add your custom actions here
 *             <Button color="primary" onClick={customAction}>Custom Action</Button>
 *         </TopToolbar>
 *     );
 *
 *     export const PostEdit = (props) => (
 *         <Edit actions={<PostEditActions />} {...props}>
 *             ...
 *         </Edit>
 *     );
 */
declare const EditActions: {
    ({ className, ...rest }: EditActionsProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        data: PropTypes__default.Requireable<object>;
        hasCreate: PropTypes__default.Requireable<boolean>;
        hasEdit: PropTypes__default.Requireable<boolean>;
        hasShow: PropTypes__default.Requireable<boolean>;
        hasList: PropTypes__default.Requireable<boolean>;
        resource: PropTypes__default.Requireable<string>;
    };
};
interface EditActionsProps {
    className?: string;
    data?: RaRecord;
    hasCreate?: boolean;
    hasEdit?: boolean;
    hasList?: boolean;
    hasShow?: boolean;
    resource?: string;
}

declare const editFieldTypes: InferredTypeMap;

declare const EditGuesser: (props: EditProps) => JSX.Element;

declare const EditView: {
    (props: EditViewProps): JSX.Element;
    propTypes: {
        actions: PropTypes__default.Requireable<boolean | PropTypes__default.ReactElementLike>;
        aside: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        className: PropTypes__default.Requireable<string>;
        component: (props: any, propName: any, componentName: any) => Error;
        defaultTitle: PropTypes__default.Requireable<any>;
        hasList: PropTypes__default.Requireable<boolean>;
        hasShow: PropTypes__default.Requireable<boolean>;
        mutationMode: PropTypes__default.Requireable<string>;
        mutationOptions: PropTypes__default.Requireable<object>;
        record: PropTypes__default.Requireable<object>;
        redirect: PropTypes__default.Requireable<string | boolean | ((...args: any[]) => any)>;
        resource: PropTypes__default.Requireable<string>;
        save: PropTypes__default.Requireable<(...args: any[]) => any>;
        title: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
    };
};
interface EditViewProps extends EditProps, Omit<EditControllerProps, 'resource'> {
    children: ReactNode;
}
declare const EditClasses: {
    main: string;
    noActions: string;
    card: string;
};

/**
 * Page component for the Show view
 *
 * The `<Show>` component handles the headless logic of the Show page:
 * - it calls useShowController to fetch the record from the data provider,
 * - it creates a ShowContext and a RecordContext,
 * - it computes the default page title
 * - it renders the page layout with the correct title and actions
 *
 * `<Show>` is not responsible for rendering the actual page -
 * that's the job of its child component (usually `<SimpleShowLayout>`).
 *
 * @example
 *
 * // in src/posts.js
 * import * as React from "react";
 * import { Show, SimpleShowLayout, TextField } from 'react-admin';
 *
 * export const PostShow = () => (
 *     <Show>
 *         <SimpleShowLayout>
 *             <TextField source="title" />
 *         </SimpleShowLayout>
 *     </Show>
 * );
 *
 * // in src/App.js
 * import * as React from "react";
 * import { Admin, Resource } from 'react-admin';
 *
 * import { PostShow } from './posts';
 *
 * const App = () => (
 *     <Admin dataProvider={...}>
 *         <Resource name="posts" show={PostShow} />
 *     </Admin>
 * );
 * export default App;
 *
 * @param {ShowProps} props
 * @param {ReactElement|false} props.actions An element to display above the page content, or false to disable actions.
 * @param {string} props.className A className to apply to the page content.
 * @param {ElementType} props.component The component to use as root component (div by default).
 * @param {boolean} props.emptyWhileLoading Do not display the page content while loading the initial data.
 * @param {string} props.id The id of the resource to display (grabbed from the route params if not defined).
 * @param {Object} props.queryClient Options to pass to the react-query useQuery hook.
 * @param {string} props.resource The resource to fetch from the data provider (grabbed from the ResourceContext if not defined).
 * @param {Object} props.sx Custom style object.
 * @param {ElementType|string} props.title The title of the page. Defaults to `#{resource} #${id}`.
 *
 * @see ShowView for the actual rendering
 */
declare const Show: {
    <RecordType extends RaRecord = any>({ id, resource, queryOptions, ...rest }: ShowProps<RecordType>): ReactElement;
    propTypes: {
        actions: PropTypes__default.Requireable<boolean | PropTypes__default.ReactElementLike>;
        children: PropTypes__default.Validator<PropTypes__default.ReactNodeLike>;
        className: PropTypes__default.Requireable<string>;
        disableAuthentication: PropTypes__default.Requireable<boolean>;
        emptyWhileLoading: PropTypes__default.Requireable<boolean>;
        component: PropTypes__default.Requireable<PropTypes__default.ReactComponentLike>;
        resource: PropTypes__default.Requireable<string>;
        title: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        sx: PropTypes__default.Requireable<any>;
    };
};

/**
 * Action Toolbar for the Show view
 *
 * Internal component. If you want to add or remove actions for a Show view,
 * write your own ShowActions Component. Then, in the <Show> component,
 * use it in the `actions` prop to pass a custom component.
 *
 * @example
 *     import Button from '@mui/material/Button';
 *     import { TopToolbar, EditButton, Show } from 'react-admin';
 *
 *     const PostShowActions = ({ record, resource }) => (
 *         <TopToolbar>
 *             <EditButton record={record} />
 *             // Add your custom actions here //
 *             <Button color="primary" onClick={customAction}>Custom Action</Button>
 *         </TopToolbar>
 *     );
 *
 *     export const PostShow = (props) => (
 *         <Show actions={<PostShowActions />} {...props}>
 *             ...
 *         </Show>
 *     );
 */
declare const ShowActions: {
    (props: ShowActionsProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        record: PropTypes__default.Requireable<any>;
    };
};
interface ShowActionsProps {
    className?: string;
    record?: RaRecord;
}

declare const showFieldTypes: InferredTypeMap;

declare const ShowGuesser: ({ id, queryOptions, resource, ...rest }: Omit<ShowProps, 'children'>) => JSX.Element;

declare const ShowView: {
    (props: ShowViewProps): JSX.Element;
    propTypes: {
        actions: PropTypes__default.Requireable<boolean | PropTypes__default.ReactElementLike>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        className: PropTypes__default.Requireable<string>;
        emptyWhileLoading: PropTypes__default.Requireable<boolean>;
        title: PropTypes__default.Requireable<any>;
    };
};
declare type ShowViewProps = ShowProps;
declare const ShowClasses: {
    main: string;
    noActions: string;
    card: string;
};

/**
 * Layout for a Show view showing fields in one column.
 *
 * It pulls the record from the RecordContext. It renders the record fields in
 * a single-column layout (via MUI's `<Stack>` component).
 * `<SimpleShowLayout>` delegates the actual rendering of fields to its children.
 * It wraps each field inside a `<Labeled>` component to add a label.
 *
 * @example
 * // in src/posts.js
 * import * as React from "react";
 * import { Show, SimpleShowLayout, TextField } from 'react-admin';
 *
 * export const PostShow = () => (
 *     <Show>
 *         <SimpleShowLayout>
 *             <TextField source="title" />
 *         </SimpleShowLayout>
 *     </Show>
 * );
 *
 * // in src/App.js
 * import * as React from "react";
 * import { Admin, Resource } from 'react-admin';
 *
 * import { PostShow } from './posts';
 *
 * const App = () => (
 *     <Admin dataProvider={...}>
 *         <Resource name="posts" show={PostShow} />
 *     </Admin>
 * );
 *
 * @param {SimpleShowLayoutProps} props
 * @param {string} props.className A className to apply to the page content.
 * @param {ElementType} props.component The component to use as root component (div by default).
 * @param {ReactNode} props.divider An optional divider between each field, passed to `<Stack>`.
 * @param {number} props.spacing The spacing to use between each field, passed to `<Stack>`. Defaults to 1.
 * @param {Object} props.sx Custom style object.
 */
declare const SimpleShowLayout: {
    (props: SimpleShowLayoutProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        className: PropTypes__default.Requireable<string>;
        record: PropTypes__default.Requireable<object>;
        spacing: PropTypes__default.Requireable<any>;
        sx: PropTypes__default.Requireable<any>;
    };
};
interface SimpleShowLayoutProps {
    children: ReactNode;
    className?: string;
    divider?: ReactNode;
    record?: RaRecord;
    spacing?: ResponsiveStyleValue<number | string>;
    sx?: SxProps$1;
}
declare const SimpleShowLayoutClasses: {
    stack: string;
    row: string;
};

/**
 * Layout for a Show view showing fields grouped in tabs and laid out in a single column.
 *
 * It pulls the record from the RecordContext. It renders a set of `<Tabs>`,
 * each of which contains a list of record fields in a single-column layout
 * (via MUI's `<Stack>` component).
 * `<TabbedShowLayout>` delegates the actual rendering of fields to its children,
 * which should be `<Tab>` components.
 * `<Tab>` wraps each field inside a <Labeled> component to add a label.
 *
 * @example
 * // in src/posts.js
 * import * as React from "react";
 * import { Show, TabbedShowLayout, Tab, TextField } from 'react-admin';
 *
 * export const PostShow = () => (
 *     <Show>
 *         <TabbedShowLayout>
 *             <Tab label="Content">
 *                 <TextField source="title" />
 *                 <TextField source="subtitle" />
 *            </Tab>
 *             <Tab label="Metadata">
 *                 <TextField source="category" />
 *            </Tab>
 *         </TabbedShowLayout>
 *     </Show>
 * );
 *
 * // in src/App.js
 * import * as React from "react";
 * import { Admin, Resource } from 'react-admin';
 *
 * import { PostShow } from './posts';
 *
 * const App = () => (
 *     <Admin dataProvider={...}>
 *         <Resource name="posts" show={PostShow} />
 *     </Admin>
 * );
 *
 * @param {TabbedShowLayoutProps} props
 * @param {string} props.className A className to apply to the page content.
 * @param {ElementType} props.component The component to use as root component (div by default).
 * @param {ReactNode} props.divider An optional divider between each field, passed to `<Stack>`.
 * @param {number} props.spacing The spacing to use between each field, passed to `<Stack>`. Defaults to 1.
 * @param {Object} props.sx Custom style object.
 * @param {boolean} props.syncWithLocation Whether to update the URL when the tab changes. Defaults to true.
 * @param {ElementType} props.tabs A custom component for rendering tabs.
 */
declare const TabbedShowLayout: {
    (props: TabbedShowLayoutProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        className: PropTypes__default.Requireable<string>;
        record: PropTypes__default.Requireable<object>;
        spacing: PropTypes__default.Requireable<any>;
        sx: PropTypes__default.Requireable<any>;
        syncWithLocation: PropTypes__default.Requireable<boolean>;
        tabs: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        value: PropTypes__default.Requireable<number>;
    };
};
interface TabbedShowLayoutProps {
    children: ReactNode;
    className?: string;
    divider?: ReactNode;
    record?: RaRecord;
    rootPath?: string;
    spacing?: ResponsiveStyleValue<number | string>;
    sx?: SxProps$1;
    syncWithLocation?: boolean;
    tabs?: ReactElement;
    value?: any;
}
declare const TabbedShowLayoutClasses: {
    content: string;
};

/**
 * Tab element for the TabbedShowLayout.
 *
 * The `<Tab>` component accepts the following props:
 *
 * - label: The string displayed for each tab
 * - icon: The icon to show before the label (optional). Must be a component.
 * - path: The string used for custom urls
 *
 * @example
 *     // in src/posts.js
 *     import * as React from "react";
 *     import FavoriteIcon from '@mui/icons-material/Favorite';
 *     import PersonPinIcon from '@mui/icons-material/PersonPin';
 *     import { Show, TabbedShowLayout, Tab, TextField } from 'react-admin';
 *
 *     export const PostShow = (props) => (
 *         <Show {...props}>
 *             <TabbedShowLayout>
 *                 <Tab label="Content" icon={<FavoriteIcon />}>
 *                     <TextField source="title" />
 *                     <TextField source="subtitle" />
 *                </Tab>
 *                 <Tab label="Metadata" icon={<PersonIcon />} path="metadata">
 *                     <TextField source="category" />
 *                </Tab>
 *             </TabbedShowLayout>
 *         </Show>
 *     );
 *
 *     // in src/App.js
 *     import * as React from "react";
 *     import { Admin, Resource } from 'react-admin';
 *
 *     import { PostShow } from './posts';
 *
 *     const App = () => (
 *         <Admin dataProvider={...}>
 *             <Resource name="posts" show={PostShow} />
 *         </Admin>
 *     );
 *     export default App;
 */
declare const Tab: {
    ({ children, contentClassName, context, className, divider, icon, label, record, spacing, syncWithLocation, value, ...rest }: TabProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        contentClassName: PropTypes__default.Requireable<string>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        context: PropTypes__default.Requireable<string>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        label: PropTypes__default.Validator<string | PropTypes__default.ReactElementLike>;
        path: PropTypes__default.Requireable<string>;
        spacing: PropTypes__default.Requireable<any>;
        value: PropTypes__default.Requireable<string | number>;
    };
};
interface TabProps extends Omit<TabProps$1, 'children'> {
    children: ReactNode;
    contentClassName?: string;
    context?: 'header' | 'content';
    className?: string;
    divider?: ReactNode;
    icon?: ReactElement;
    label: string | ReactElement;
    path?: string;
    record?: RaRecord;
    spacing?: ResponsiveStyleValue<number | string>;
    syncWithLocation?: boolean;
    value?: string | number;
}

declare const TabbedShowLayoutTabs: {
    ({ children, syncWithLocation, value, ...rest }: TabbedShowLayoutTabsProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
    };
};
declare const getShowLayoutTabFullPath: (tab: any, index: any) => string;
interface TabbedShowLayoutTabsProps extends TabsProps {
    children?: ReactElement<TabProps>;
    syncWithLocation?: boolean;
}

/**
 * Form layout where inputs are divided by tab, one input per line.
 *
 * Pass FormTab components as children.
 *
 * @example
 *
 * import * as React from "react";
 * import {
 *     Edit,
 *     TabbedForm,
 *     FormTab,
 *     Datagrid,
 *     TextField,
 *     DateField,
 *     TextInput,
 *     ReferenceManyField,
 *     NumberInput,
 *     DateInput,
 *     BooleanInput,
 *     EditButton
 * } from 'react-admin';
 *
 * export const PostEdit = (props) => (
 *     <Edit {...props}>
 *         <TabbedForm>
 *             <FormTab label="summary">
 *                 <TextInput disabled label="Id" source="id" />
 *                 <TextInput source="title" validate={required()} />
 *                 <TextInput multiline source="teaser" validate={required()} />
 *             </FormTab>
 *             <FormTab label="body">
 *                 <RichTextInput source="body" validate={required()} label={false} />
 *             </FormTab>
 *             <FormTab label="Miscellaneous">
 *                 <TextInput label="Password (if protected post)" source="password" type="password" />
 *                 <DateInput label="Publication date" source="published_at" />
 *                 <NumberInput source="average_note" validate={[ number(), minValue(0) ]} />
 *                 <BooleanInput label="Allow comments?" source="commentable" defaultValue />
 *                 <TextInput disabled label="Nb views" source="views" />
 *             </FormTab>
 *             <FormTab label="comments">
 *                 <ReferenceManyField reference="comments" target="post_id" label={false}>
 *                     <Datagrid>
 *                         <TextField source="body" />
 *                         <DateField source="created_at" />
 *                         <EditButton />
 *                     </Datagrid>
 *                 </ReferenceManyField>
 *             </FormTab>
 *         </TabbedForm>
 *     </Edit>
 * );
 *
 * @typedef {Object} Props the props you can use (other props are injected by Create or Edit)
 * @prop {ReactElement[]} FormTab elements
 * @prop {Object} defaultValues
 * @prop {Function} validate
 * @prop {string} redirect
 * @prop {ReactElement} toolbar The element displayed at the bottom of the form, containing the SaveButton
 *
 * @param {Props} props
 */
declare const TabbedForm: {
    (props: TabbedFormProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        defaultValues: PropTypes__default.Requireable<object>;
        formRootPathname: PropTypes__default.Requireable<string>;
        mutationMode: PropTypes__default.Requireable<string>;
        record: PropTypes__default.Requireable<object>;
        redirect: PropTypes__default.Requireable<string | boolean | ((...args: any[]) => any)>;
        saving: PropTypes__default.Requireable<boolean>;
        validate: PropTypes__default.Requireable<(...args: any[]) => any>;
    };
};
interface TabbedFormProps extends Omit<FormProps, 'render'>, Omit<HtmlHTMLAttributes<HTMLFormElement>, 'defaultValue' | 'onSubmit' | 'children'> {
    children: ReactNode;
    className?: string;
    defaultValues?: any;
    formRootPathname?: string;
    mutationMode?: MutationMode;
    record?: RaRecord;
    redirect?: RedirectionSideEffect;
    resource?: string;
    syncWithLocation?: boolean;
    tabs?: ReactElement;
    toolbar?: ReactElement;
    warnWhenUnsavedChanges?: boolean;
}
declare const findTabsWithErrors: (children: any, errors: any) => React.ReactChild | React.ReactFragment | React.ReactPortal;

declare const FormTab: {
    (props: FormTabProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        contentClassName: PropTypes__default.Requireable<string>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        intent: PropTypes__default.Requireable<string>;
        hidden: PropTypes__default.Requireable<boolean>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        label: PropTypes__default.Validator<string | PropTypes__default.ReactElementLike>;
        path: PropTypes__default.Requireable<string>;
        resource: PropTypes__default.Requireable<string>;
        value: PropTypes__default.Requireable<string | number>;
    };
    displayName: string;
};
interface FormTabProps extends Omit<StackProps, 'color'>, Omit<TabProps$1, 'children' | 'classes' | 'ref'> {
    className?: string;
    children?: ReactNode;
    contentClassName?: string;
    hidden?: boolean;
    icon?: ReactElement;
    intent?: 'header' | 'content';
    label: string | ReactElement;
    path?: string;
    resource?: string;
    syncWithLocation?: boolean;
    value?: string | number;
}

declare const FormTabHeader: {
    ({ label, value, icon, className, onChange, syncWithLocation, ...rest }: FormTabHeaderProps): ReactElement;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        contentClassName: PropTypes__default.Requireable<string>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        intent: PropTypes__default.Requireable<string>;
        hidden: PropTypes__default.Requireable<boolean>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        label: PropTypes__default.Validator<string | PropTypes__default.ReactElementLike>;
        margin: PropTypes__default.Requireable<string>;
        path: PropTypes__default.Requireable<string>;
        record: PropTypes__default.Requireable<object>;
        resource: PropTypes__default.Requireable<string>;
        value: PropTypes__default.Requireable<string | number>;
        variant: PropTypes__default.Requireable<string>;
    };
};
interface FormTabHeaderProps extends Omit<TabProps$1, 'children'> {
    className?: string;
    hidden?: boolean;
    icon?: ReactElement;
    intent?: 'header' | 'content';
    label: string | ReactElement;
    margin?: 'none' | 'normal' | 'dense';
    onChange?: (event: any) => void;
    path?: string;
    resource?: string;
    syncWithLocation?: boolean;
    value?: string | number;
    variant?: 'standard' | 'outlined' | 'filled';
}

/**
 * Form with a one column layout, one input per line.
 *
 * Pass input components as children.
 *
 * @example
 *
 * import * as React from "react";
 * import { Create, Edit, SimpleForm, TextInput, DateInput, ReferenceManyField, Datagrid, TextField, DateField, EditButton } from 'react-admin';
 * import RichTextInput from 'ra-input-rich-text';
 *
 * export const PostCreate = (props) => (
 *     <Create {...props}>
 *         <SimpleForm>
 *             <TextInput source="title" />
 *             <TextInput source="teaser" options={{ multiline: true }} />
 *             <RichTextInput source="body" />
 *             <DateInput label="Publication date" source="published_at" defaultValue={new Date()} />
 *         </SimpleForm>
 *     </Create>
 * );
 *
 * @typedef {Object} Props the props you can use (other props are injected by Create or Edit)
 * @prop {ReactElement[]} children Input elements
 * @prop {Object} defaultValues
 * @prop {Function} validate
 * @prop {string} redirect
 * @prop {ReactElement} toolbar The element displayed at the bottom of the form, containing the SaveButton
 *
 * @param {Props} props
 */
declare const SimpleForm: {
    (props: SimpleFormProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        defaultValues: PropTypes__default.Requireable<object>;
        record: PropTypes__default.Requireable<object>;
        redirect: PropTypes__default.Requireable<string | boolean | ((...args: any[]) => any)>;
        toolbar: PropTypes__default.Requireable<boolean | PropTypes__default.ReactElementLike>;
        validate: PropTypes__default.Requireable<(...args: any[]) => any>;
    };
};
interface SimpleFormProps extends Omit<FormProps, 'render'>, Omit<StackProps, 'onSubmit'> {
    children: ReactNode;
    className?: string;
    component?: React.ComponentType<any>;
    defaultValues?: any;
    toolbar?: ReactElement | false;
    sx?: SxProps;
}

declare const TabbedFormTabs: {
    (props: TabbedFormTabsProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        url: PropTypes__default.Requireable<string>;
        tabsWithErrors: PropTypes__default.Requireable<string[]>;
    };
};
declare const getTabbedFormTabFullPath: (tab: ReactElement, index: number) => string;
interface TabbedFormTabsProps extends TabsProps {
    url?: string;
    tabsWithErrors?: string[];
    syncWithLocation?: boolean;
}

declare const TabbedFormView: {
    (props: TabbedFormViewProps): ReactElement;
    propTypes: {
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        className: PropTypes__default.Requireable<string>;
        location: PropTypes__default.Requireable<object>;
        match: PropTypes__default.Requireable<object>;
        resource: PropTypes__default.Requireable<string>;
        tabs: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        toolbar: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        validate: PropTypes__default.Requireable<(...args: any[]) => any>;
        value: PropTypes__default.Requireable<number>;
    };
};
interface TabbedFormViewProps {
    children?: ReactNode;
    className?: string;
    component?: ComponentType<any>;
    resource?: string;
    formRootPathname?: string;
    syncWithLocation?: boolean;
    tabs?: ReactElement;
    toolbar?: ReactElement;
    sx?: SxProps;
}
declare const TabbedFormClasses: {
    errorTabButton: string;
};

/**
 * The Toolbar displayed at the bottom of forms.
 *
 * @example Always enable the <SaveButton />
 *
 * import * as React from 'react';
 * import {
 *     Create,
 *     DateInput,
 *     TextInput,
 *     SimpleForm,
 *     Toolbar,
 *     SaveButton,
 *     required,
 * } from 'react-admin';
 *
 * const now = new Date();
 * const defaultSort = { field: 'title', order: 'ASC' };
 *
 * const MyToolbar = props => (
 *     <Toolbar {...props} >
 *         <SaveButton alwaysEnable />
 *     </Toolbar>
 * );
 *
 * const CommentCreate = () => (
 *     <Create>
 *         <SimpleForm redirect={false} toolbar={<MyToolbar />}>
 *             <TextInput
 *                 source="author.name"
 *                 fullWidth
 *             />
 *             <DateInput source="created_at" defaultValue={now} />
 *             <TextInput source="body" fullWidth={true} multiline={true} />
 *         </SimpleForm>
 *     </Create>
 * );
 *
 * @typedef {Object} Props the props you can use (other props are injected by the <SimpleForm>)
 * @prop {ReactElement[]} children Customize the buttons you want to display in the <Toolbar>.
 *
 */
declare const Toolbar: {
    <RecordType extends Partial<RaRecord> = Partial<RaRecord>>(props: ToolbarProps<RecordType>): JSX.Element;
    propTypes: {
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        className: PropTypes__default.Requireable<string>;
        record: PropTypes__default.Requireable<any>;
        resource: PropTypes__default.Requireable<string>;
    };
};
interface ToolbarProps<RecordType extends Partial<RaRecord> = any> extends Omit<ToolbarProps$1, 'classes'> {
    children?: ReactNode;
    className?: string;
    record?: RecordType;
    resource?: string;
}
declare const ToolbarClasses: {
    desktopToolbar: string;
    mobileToolbar: string;
    defaultToolbar: string;
};

declare type TextAlign = TableCellProps['align'];
declare type SortOrder = 'ASC' | 'DESC';
interface FieldProps<RecordType extends RaRecord = any> extends PublicFieldProps, InjectedFieldProps<RecordType> {
}
interface PublicFieldProps {
    sortBy?: string;
    sortByOrder?: SortOrder;
    source?: string;
    label?: string | ReactElement | boolean;
    sortable?: boolean;
    className?: string;
    cellClassName?: string;
    headerClassName?: string;
    formClassName?: string;
    textAlign?: TextAlign;
    emptyText?: string;
    fullWidth?: boolean;
}
interface InjectedFieldProps<RecordType extends RaRecord = any> {
    record?: RecordType;
    resource?: string;
}

/**
 * Display a collection
 *
 * Ideal for embedded arrays of objects, e.g.
 * {
 *   id: 123
 *   tags: [
 *     { name: 'foo' },
 *     { name: 'bar' }
 *   ]
 * }
 *
 * The child must be an iterator component
 * (like <Datagrid> or <SingleFieldList>).
 *
 * @example Display all the backlinks of the current post as a <Datagrid>
 * // post = {
 * //   id: 123
 * //   backlinks: [
 * //       {
 * //           uuid: '34fdf393-f449-4b04-a423-38ad02ae159e',
 * //           date: '2012-08-10T00:00:00.000Z',
 * //           url: 'http://example.com/foo/bar.html',
 * //       },
 * //       {
 * //           uuid: 'd907743a-253d-4ec1-8329-404d4c5e6cf1',
 * //           date: '2012-08-14T00:00:00.000Z',
 * //           url: 'https://blog.johndoe.com/2012/08/12/foobar.html',
 * //       }
 * //    ]
 * // }
 *     <ArrayField source="backlinks">
 *         <Datagrid>
 *             <DateField source="date" />
 *             <UrlField source="url" />
 *         </Datagrid>
 *     </ArrayField>
 *
 * @example Display all the tags of the current post as <Chip> components
 * // post = {
 * //   id: 123
 * //   tags: [
 * //     { name: 'foo' },
 * //     { name: 'bar' }
 * //   ]
 * // }
 *     <ArrayField source="tags">
 *         <SingleFieldList>
 *             <ChipField source="name" />
 *         </SingleFieldList>
 *     </ArrayField>
 *
 * If you need to render a collection in a custom way, it's often simpler
 * to write your own component:
 *
 * @example
 *     const TagsField = ({ record }) => (
 *          <ul>
 *              {record.tags.map(item => (
 *                  <li key={item.name}>{item.name}</li>
 *              ))}
 *          </ul>
 *     );
 */
declare const ArrayField: FC<ArrayFieldProps>;
interface ArrayFieldProps extends PublicFieldProps, InjectedFieldProps {
    children: ReactElement;
}

declare const BooleanField: FunctionComponent<BooleanFieldProps>;
interface BooleanFieldProps extends PublicFieldProps, InjectedFieldProps, Omit<TypographyProps, 'textAlign'> {
    valueLabelTrue?: string;
    valueLabelFalse?: string;
    TrueIcon?: SvgIconComponent;
    FalseIcon?: SvgIconComponent;
    looseValue?: boolean;
}

declare const ChipField: FC<ChipFieldProps>;
interface ChipFieldProps extends PublicFieldProps, InjectedFieldProps, Omit<ChipProps, 'label'> {
}

/**
 * Display a date value as a locale string.
 *
 * Uses Intl.DateTimeFormat() if available, passing the locales and options props as arguments.
 * If Intl is not available, it outputs date as is (and ignores the locales and options props).
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString
 * @example
 * <DateField source="published_at" />
 * // renders the record { id: 1234, published_at: new Date('2012-11-07') } as
 * <span>07/11/2012</span>
 *
 * <DateField source="published_at" className="red" />
 * // renders the record { id: 1234, new Date('2012-11-07') } as
 * <span class="red">07/11/2012</span>
 *
 * <DateField source="share" options={{ weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }} />
 * // renders the record { id: 1234, new Date('2012-11-07') } as
 * <span>Wednesday, November 7, 2012</span>
 *
 * <DateField source="price" locales="fr-FR" options={{ weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }} />
 * // renders the record { id: 1234, new Date('2012-11-07') } as
 * <span>mercredi 7 novembre 2012</span>
 */
declare const DateField: FC<DateFieldProps>;
interface DateFieldProps extends PublicFieldProps, InjectedFieldProps, Omit<TypographyProps, 'textAlign'> {
    locales?: string | string[];
    options?: object;
    showTime?: boolean;
}

declare const EmailField: FC<EmailFieldProps>;
interface EmailFieldProps extends PublicFieldProps, InjectedFieldProps, Omit<LinkProps$1, 'textAlign'> {
}

/**
 * Render a link to a file based on a path contained in a record field
 *
 * @example
 * import { FileField } from 'react-admin';
 *
 * <FileField source="url" title="title" />
 *
 * // renders the record { id: 123, url: 'doc.pdf', title: 'Presentation' } as
 * <div>
 *     <a href="doc.pdf" title="Presentation">Presentation</a>
 * </div>
 */
declare const FileField: {
    (props: FileFieldProps): JSX.Element;
    propTypes: {
        src: PropTypes__default.Requireable<string>;
        title: PropTypes__default.Requireable<string>;
        target: PropTypes__default.Requireable<string>;
        download: PropTypes__default.Requireable<string | boolean>;
        ping: PropTypes__default.Requireable<string>;
        rel: PropTypes__default.Requireable<string>;
        sortBy: PropTypes__default.Requireable<string>;
        sortByOrder: PropTypes__default.Requireable<"ASC" | "DESC">;
        source: PropTypes__default.Requireable<string>;
        label: PropTypes__default.Requireable<string | boolean | PropTypes__default.ReactElementLike>;
        sortable: PropTypes__default.Requireable<boolean>;
        className: PropTypes__default.Requireable<string>;
        cellClassName: PropTypes__default.Requireable<string>;
        headerClassName: PropTypes__default.Requireable<string>;
        textAlign: PropTypes__default.Requireable<"inherit" | "left" | "right" | "center" | "justify">;
        emptyText: PropTypes__default.Requireable<string>;
    };
};
interface FileFieldProps extends PublicFieldProps, InjectedFieldProps {
    src?: string;
    title?: string;
    target?: string;
    download?: boolean | string;
    ping?: string;
    rel?: string;
    sx?: SxProps$1;
}

/**
 * Field using a render function
 *
 * @example
 * <FunctionField
 *     source="last_name" // used for sorting
 *     label="Name"
 *     render={record => record && `${record.first_name} ${record.last_name}`}
 * />
 */
declare const FunctionField: {
    <RecordType extends RaRecord = any>(props: FunctionFieldProps<RecordType>): JSX.Element;
    propTypes: any;
};
interface FunctionFieldProps<RecordType extends RaRecord = any> extends PublicFieldProps, InjectedFieldProps<RecordType>, Omit<TypographyProps$1, 'textAlign'> {
    render: (record?: RecordType, source?: string) => any;
}

declare const ImageField: {
    (props: ImageFieldProps): JSX.Element;
    displayName: string;
    propTypes: {
        src: PropTypes__default.Requireable<string>;
        title: PropTypes__default.Requireable<string>;
        sortBy: PropTypes__default.Requireable<string>;
        sortByOrder: PropTypes__default.Requireable<"ASC" | "DESC">;
        source: PropTypes__default.Requireable<string>;
        label: PropTypes__default.Requireable<string | boolean | PropTypes__default.ReactElementLike>;
        sortable: PropTypes__default.Requireable<boolean>;
        className: PropTypes__default.Requireable<string>;
        cellClassName: PropTypes__default.Requireable<string>;
        headerClassName: PropTypes__default.Requireable<string>;
        textAlign: PropTypes__default.Requireable<"inherit" | "left" | "right" | "center" | "justify">;
        emptyText: PropTypes__default.Requireable<string>;
    };
};
declare const ImageFieldClasses: {
    list: string;
    image: string;
};
interface ImageFieldProps extends PublicFieldProps, InjectedFieldProps {
    src?: string;
    title?: string;
    sx?: SxProps$1;
}

/**
 * Display a numeric value as a locale string.
 *
 * Uses Intl.NumberFormat() if available, passing the locales and options props as arguments.
 * If Intl is not available, it outputs number as is (and ignores the locales and options props).
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString
 * @example
 * <NumberField source="score" />
 * // renders the record { id: 1234, score: 567 } as
 * <span>567</span>
 *
 * <NumberField source="score" className="red" />
 * // renders the record { id: 1234, score: 567 } as
 * <span class="red">567</span>
 *
 * <NumberField source="share" options={{ style: 'percent' }} />
 * // renders the record { id: 1234, share: 0.2545 } as
 * <span>25%</span>
 *
 * <NumberField source="price" options={{ style: 'currency', currency: 'USD' }} />
 * // renders the record { id: 1234, price: 25.99 } as
 * <span>$25.99</span>
 *
 * <NumberField source="price" locales="fr-FR" options={{ style: 'currency', currency: 'USD' }} />
 * // renders the record { id: 1234, price: 25.99 } as
 * <span>25,99 $US</span>
 */
declare const NumberField: FC<NumberFieldProps>;
interface NumberFieldProps extends PublicFieldProps, InjectedFieldProps, Omit<TypographyProps$1, 'textAlign'> {
    locales?: string | string[];
    options?: object;
}

/**
 * A container component that fetches records from another resource specified
 * by an array of *ids* in current record.
 *
 * You must define the fields to be passed to the iterator component as children.
 *
 * @example Display all the products of the current order as datagrid
 * // order = {
 * //   id: 123,
 * //   product_ids: [456, 457, 458],
 * // }
 * <ReferenceArrayField label="Products" reference="products" source="product_ids">
 *     <Datagrid>
 *         <TextField source="id" />
 *         <TextField source="description" />
 *         <NumberField source="price" options={{ style: 'currency', currency: 'USD' }} />
 *         <EditButton />
 *     </Datagrid>
 * </ReferenceArrayField>
 *
 * @example Display all the categories of the current product as a list of chips
 * // product = {
 * //   id: 456,
 * //   category_ids: [11, 22, 33],
 * // }
 * <ReferenceArrayField label="Categories" reference="categories" source="category_ids">
 *     <SingleFieldList>
 *         <ChipField source="name" />
 *     </SingleFieldList>
 * </ReferenceArrayField>
 *
 * By default, restricts the displayed values to 1000. You can extend this limit
 * by setting the `perPage` prop.
 *
 * @example
 * <ReferenceArrayField perPage={10} reference="categories" source="category_ids">
 *    ...
 * </ReferenceArrayField>
 *
 * By default, the field displays the results in the order in which they are referenced
 * (i.e. in the order of the list of ids). You can change this order
 * by setting the `sort` prop (an object with `field` and `order` properties).
 *
 * @example
 * <ReferenceArrayField sort={{ field: 'name', order: 'ASC' }} reference="categories" source="category_ids">
 *    ...
 * </ReferenceArrayField>
 *
 * Also, you can filter the results to display only a subset of values. Use the
 * `filter` prop for that.
 *
 * @example
 * <ReferenceArrayField filter={{ is_published: true }} reference="categories" source="category_ids">
 *    ...
 * </ReferenceArrayField>
 */
declare const ReferenceArrayField: FC<ReferenceArrayFieldProps>;
interface ReferenceArrayFieldProps extends PublicFieldProps, InjectedFieldProps {
    children: ReactNode;
    filter?: FilterPayload;
    page?: number;
    pagination?: ReactElement;
    perPage?: number;
    reference: string;
    resource?: string;
    sort?: SortPayload;
    sx?: SxProps$1;
}
interface ReferenceArrayFieldViewProps extends Omit<ReferenceArrayFieldProps, 'resource' | 'page' | 'perPage'>, ListControllerProps {
}
declare const ReferenceArrayFieldView: FC<ReferenceArrayFieldViewProps>;
declare const ReferenceArrayFieldClasses: {
    progress: string;
};

/**
 * Fetch reference record, and delegate rendering to child component.
 *
 * The reference prop should be the name of one of the <Resource> components
 * added as <Admin> child.
 *
 * @example
 * <ReferenceField label="User" source="userId" reference="users">
 *     <TextField source="name" />
 * </ReferenceField>
 *
 * @default
 * By default, includes a link to the <Edit> page of the related record
 * (`/users/:userId` in the previous example).
 *
 * Set the `link` prop to "show" to link to the <Show> page instead.
 *
 * @example
 * <ReferenceField label="User" source="userId" reference="users" link="show">
 *     <TextField source="name" />
 * </ReferenceField>
 *
 * @default
 * You can also prevent `<ReferenceField>` from adding link to children by setting
 * `link` to false.
 *
 * @example
 * <ReferenceField label="User" source="userId" reference="users" link={false}>
 *     <TextField source="name" />
 * </ReferenceField>
 *
 * @default
 * Alternatively, you can also pass a custom function to `link`. It must take reference and record
 * as arguments and return a string
 *
 * @example
 * <ReferenceField label="User" source="userId" reference="users" link={(record, reference) => "/path/to/${reference}/${record}"}>
 *     <TextField source="name" />
 * </ReferenceField>
 *
 * @default
 * In previous versions of React-Admin, the prop `linkType` was used. It is now deprecated and replaced with `link`. However
 * backward-compatibility is still kept
 */
declare const ReferenceField: FC<ReferenceFieldProps>;
interface ReferenceFieldProps<RecordType extends RaRecord = any> extends PublicFieldProps, InjectedFieldProps<RecordType> {
    children: ReactNode;
    reference: string;
    resource?: string;
    source: string;
    translateChoice?: Function | boolean;
    link?: LinkToType;
    sx?: SxProps;
}
/**
 * This intermediate component is made necessary by the useReference hook,
 * which cannot be called conditionally when get(record, source) is empty.
 */
declare const NonEmptyReferenceField: FC<Omit<ReferenceFieldProps, 'emptyText' | 'source'> & {
    id: Identifier;
}>;
declare const ReferenceFieldView: FC<ReferenceFieldViewProps>;
interface ReferenceFieldViewProps extends PublicFieldProps, InjectedFieldProps, UseReferenceResult {
    reference: string;
    resource?: string;
    translateChoice?: Function | boolean;
    resourceLinkPath?: string | false;
    children?: ReactNode;
    sx?: SxProps;
}
declare const ReferenceFieldClasses: {
    link: string;
};

/**
 * Render related records to the current one.
 *
 * You must define the fields to be passed to the iterator component as children.
 *
 * @example Display all the comments of the current post as a datagrid
 * <ReferenceManyField reference="comments" target="post_id">
 *     <Datagrid>
 *         <TextField source="id" />
 *         <TextField source="body" />
 *         <DateField source="created_at" />
 *         <EditButton />
 *     </Datagrid>
 * </ReferenceManyField>
 *
 * @example Display all the books by the current author, only the title
 * <ReferenceManyField reference="books" target="author_id">
 *     <SingleFieldList>
 *         <ChipField source="title" />
 *     </SingleFieldList>
 * </ReferenceManyField>
 *
 * By default, restricts the displayed values to 25. You can extend this limit
 * by setting the `perPage` prop.
 *
 * @example
 * <ReferenceManyField perPage={10} reference="comments" target="post_id">
 *    ...
 * </ReferenceManyField>
 *
 * By default, orders the possible values by id desc. You can change this order
 * by setting the `sort` prop (an object with `field` and `order` properties).
 *
 * @example
 * <ReferenceManyField sort={{ field: 'created_at', order: 'DESC' }} reference="comments" target="post_id">
 *    ...
 * </ReferenceManyField>
 *
 * Also, you can filter the query used to populate the possible values. Use the
 * `filter` prop for that.
 *
 * @example
 * <ReferenceManyField filter={{ is_published: true }} reference="comments" target="post_id">
 *    ...
 * </ReferenceManyField>
 */
declare const ReferenceManyField: FC<ReferenceManyFieldProps>;
interface ReferenceManyFieldProps extends PublicFieldProps, InjectedFieldProps {
    children: ReactNode;
    filter?: FilterPayload;
    page?: number;
    pagination?: ReactElement;
    perPage?: number;
    reference: string;
    sort?: SortPayload;
    target: string;
}

/**
 * Render the related record in a one-to-one relationship
 *
 * Expects a single field as child
 *
 * @example // display the bio of the current author
 * <ReferenceOneField reference="bios" target="author_id">
 *     <TextField source="body" />
 * </ReferenceOneField>
 */
declare const ReferenceOneField: {
    (props: ReferenceOneFieldProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Validator<PropTypes__default.ReactNodeLike>;
        className: PropTypes__default.Requireable<string>;
        label: PropTypes__default.Requireable<string | boolean | PropTypes__default.ReactElementLike>;
        record: PropTypes__default.Requireable<any>;
        reference: PropTypes__default.Validator<string>;
        source: PropTypes__default.Validator<string>;
        target: PropTypes__default.Validator<string>;
    };
    defaultProps: {
        source: string;
    };
};
interface ReferenceOneFieldProps extends PublicFieldProps, InjectedFieldProps {
    children: ReactNode;
    reference: string;
    target: string;
    link?: LinkToType;
}

declare const RichTextField: FC<RichTextFieldProps>;
interface RichTextFieldProps extends PublicFieldProps, InjectedFieldProps, Omit<TypographyProps$1, 'textAlign'> {
    stripTags?: boolean;
}
declare const removeTags: (input: string) => string;

declare const sanitizeFieldRestProps: (props: any) => any;

/**
 * Display a value in an enumeration
 *
 * Pass possible options as an array of objects in the 'choices' attribute.
 *
 * @example
 * const choices = [
 *    { id: 'M', name: 'Male' },
 *    { id: 'F', name: 'Female' },
 * ];
 * <SelectField source="gender" choices={choices} />
 *
 * By default, the text is built by
 * - finding a choice where the 'id' property equals the field value
 * - using the 'name' property as the option text
 *
 * You can also customize the properties to use for the value and text,
 * thanks to the 'optionValue' and 'optionText' attributes.
 *
 * @example
 * const choices = [
 *    { _id: 123, full_name: 'Leo Tolstoi', sex: 'M' },
 *    { _id: 456, full_name: 'Jane Austen', sex: 'F' },
 * ];
 * <SelectField source="author_id" choices={choices} optionText="full_name" optionValue="_id" />
 *
 * `optionText` also accepts a function, so you can shape the option text at will:
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;
 * <SelectField source="author_id" choices={choices} optionText={optionRenderer} />
 *
 * `optionText` also accepts a React Element, that can access
 * the related choice through the `useRecordContext` hook. You can use Field components there.
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const FullNameField = ({ record }) => <Chip>{record.first_name} {record.last_name}</Chip>;
 * <SelectField source="gender" choices={choices} optionText={<FullNameField />}/>
 *
 * The current choice is translated by default, so you can use translation identifiers as choices:
 * @example
 * const choices = [
 *    { id: 'M', name: 'myroot.gender.male' },
 *    { id: 'F', name: 'myroot.gender.female' },
 * ];
 *
 * However, in some cases (e.g. inside a `<ReferenceField>`), you may not want
 * the choice to be translated. In that case, set the `translateChoice` prop to false.
 * @example
 * <SelectField source="gender" choices={choices} translateChoice={false}/>
 *
 * **Tip**: <ReferenceField> sets `translateChoice` to false by default.
 */
declare const SelectField: FC<SelectFieldProps>;
interface SelectFieldProps extends ChoicesProps, PublicFieldProps, InjectedFieldProps, Omit<TypographyProps, 'textAlign'> {
}

declare const TextField: FC<TextFieldProps>;
interface TextFieldProps extends PublicFieldProps, InjectedFieldProps, Omit<TypographyProps$1, 'textAlign'> {
    component?: ElementType<any>;
}

/**
 * Provides a way to show multiple languages for any field passed as children.
 * It expects the translatable values to have the following structure:
 * {
 *     name: {
 *         en: 'The english value',
 *         fr: 'The french value',
 *         tlh: 'The klingon value',
 *     },
 *     description: {
 *         en: 'The english value',
 *         fr: 'The french value',
 *         tlh: 'The klingon value',
 *     }
 * }
 *
 * @example <caption>Basic usage</caption>
 * <TranslatableFields locales={['en', 'fr']}>
 *     <TextField source={getSource('title')} />
 *     <TextField source={getSource('description')} />
 * </TranslatableFields>
 *
 * @example <caption>With a custom language selector</caption>
 * <TranslatableFields
 *     selector={<MyLanguageSelector />}
 *     locales={['en', 'fr']}
 * >
 *     <TextField source={getSource('title')} />
 * <TranslatableFields>
>
 *
 * const MyLanguageSelector = () => {
 *     const {
 *         locales,
 *         selectedLocale,
 *         selectLocale,
 *     } = useTranslatableContext();
 *
 *     return (
 *         <select onChange={selectLocale}>
 *             {locales.map((locale) => (
 *                 <option selected={locale.locale === selectedLocale}>
 *                     {locale.name}
 *                 </option>
 *             ))}
 *        </select>
 *     );
 * }
 *
 * @param props The component props
 * @param {string} props.defaultLocale The locale selected by default. Default to 'en'.
 * @param {string[]} props.locales An array of the possible locales in the form. For example [{ 'en', 'fr' }].
 * @param {ReactElement} props.selector The element responsible for selecting a locale. Defaults to MUI tabs.
 */
declare const TranslatableFields: (props: TranslatableFieldsProps) => ReactElement;
interface TranslatableFieldsProps extends UseTranslatableOptions {
    children: ReactNode;
    className?: string;
    record?: RaRecord;
    resource?: string;
    selector?: ReactElement;
    groupKey?: string;
}

/**
 * Single tab that selects a locale in a TranslatableFields component.
 * @see TranslatableFields
 */
declare const TranslatableFieldsTab: (props: TranslatableFieldsTabProps & TabProps$2) => JSX.Element;
interface TranslatableFieldsTabProps {
    locale: string;
    groupKey?: string;
}

/**
 * Default container for a group of translatable fields inside a TranslatableFields components.
 * @see TranslatableFields
 */
declare const TranslatableFieldsTabContent: (props: TranslatableFieldsTabContentProps) => ReactElement;
declare type TranslatableFieldsTabContentProps = {
    children: ReactNode;
    className?: string;
    formGroupKeyPrefix?: string;
    groupKey: string;
    locale: string;
    record: RaRecord;
    resource: string;
};

declare const UrlField: FC<UrlFieldProps>;
interface UrlFieldProps extends PublicFieldProps, InjectedFieldProps, AnchorHTMLAttributes<HTMLAnchorElement> {
}

/**
 * A field rendering its children.
 *
 * Designed as a wrapper for several fields, to support props read by
 * the parent element (e.g. `<SimpleShowLayout>`, `<Datagrid`).
 *
 * @example
 * import { WrapperField, TextField } from 'react-admin';
 *
 * const PostShow = () => (
 *    <Show>
 *        <SimpleShowLayout>
 *            <WrapperField label="author" sortBy="last_name">
 *               <TextField source="first_name" />
 *               <TextField source="last_name" />
 *            </WrapperField>
 *       </SimpleShowLayout>
 *   </Show>
 * );
 */
declare const WrapperField: {
    ({ children }: WrapperFieldProps): JSX.Element;
    displayName: string;
    propTypes: {
        sortBy: PropTypes.Requireable<string>;
        sortByOrder: PropTypes.Requireable<"ASC" | "DESC">;
        source: PropTypes.Requireable<string>;
        label: PropTypes.Requireable<string | boolean | PropTypes.ReactElementLike>;
        sortable: PropTypes.Requireable<boolean>;
        className: PropTypes.Requireable<string>;
        cellClassName: PropTypes.Requireable<string>;
        headerClassName: PropTypes.Requireable<string>;
        textAlign: PropTypes.Requireable<"inherit" | "left" | "right" | "center" | "justify">;
        emptyText: PropTypes.Requireable<string>;
    };
};
interface WrapperFieldProps extends PublicFieldProps, InjectedFieldProps {
    children: ReactNode;
}

/**
 * Wrap a field or an input with a label if necessary.
 *
 * The label is displayed if:
 * - the field or input has a label prop that is not false, or
 * - the field or input has a source prop
 *
 * @example
 * <Labeled>
 *     <FooComponent source="title" />
 * </Labeled>
 */
declare const Labeled: {
    ({ children, className, color, component, fullWidth, isRequired, label, resource, source, ...rest }: LabeledProps): JSX.Element;
    displayName: string;
};
interface LabeledProps extends StackProps {
    children: ReactElement;
    className?: string;
    color?: ResponsiveStyleValue<Property.Color | Property.Color[]> | ((theme: Theme) => ResponsiveStyleValue<Property.Color | Property.Color[]>);
    component?: ElementType;
    fullWidth?: boolean;
    htmlFor?: string;
    isRequired?: boolean;
    label?: string | ReactElement | false;
    resource?: string;
    source?: string;
}
declare const LabeledClasses: {
    label: string;
    fullWidth: string;
};

declare type CommonInputProps = InputProps & {
    cellClassName?: string;
    formClassName?: string;
    fullWidth?: boolean;
    headerCellClassName?: string;
    margin?: 'none' | 'dense' | 'normal';
    variant?: 'standard' | 'outlined' | 'filled';
};

/**
 * To edit arrays of data embedded inside a record, <ArrayInput> creates a list of sub-forms.
 *
 *  @example
 *
 *      import { ArrayInput, SimpleFormIterator, DateInput, TextInput } from 'react-admin';
 *
 *      <ArrayInput source="backlinks">
 *          <SimpleFormIterator>
 *              <DateInput source="date" />
 *              <TextInput source="url" />
 *          </SimpleFormIterator>
 *      </ArrayInput>
 *
 * <ArrayInput> allows the edition of embedded arrays, like the backlinks field
 * in the following post record:
 *
 * {
 *   id: 123
 *   backlinks: [
 *         {
 *             date: '2012-08-10T00:00:00.000Z',
 *             url: 'http://example.com/foo/bar.html',
 *         },
 *         {
 *             date: '2012-08-14T00:00:00.000Z',
 *             url: 'https://blog.johndoe.com/2012/08/12/foobar.html',
 *         }
 *    ]
 * }
 *
 * <ArrayInput> expects a single child, which must be a *form iterator* component.
 * A form iterator is a component accepting a fields object as passed by
 * react-hook-form-arrays's useFieldArray() hook, and defining a layout for
 * an array of fields. For instance, the <SimpleFormIterator> component
 * displays an array of fields in an unordered list (<ul>), one sub-form by
 * list item (<li>). It also provides controls for adding and removing
 * a sub-record (a backlink in this example).
 *
 * @see {@link https://react-hook-form.com/api/usefieldarray}
 */
declare const ArrayInput: {
    (props: ArrayInputProps): JSX.Element;
    defaultProps: {
        options: {};
        fullWidth: boolean;
    };
};
declare const getArrayInputError: (error: any) => any;
interface ArrayInputProps extends CommonInputProps, Omit<FormControlProps, 'defaultValue' | 'onBlur' | 'onChange'> {
    className?: string;
    children: ReactElement;
    disabled?: boolean;
    isFetching?: boolean;
    isLoading?: boolean;
    record?: Partial<RaRecord>;
}

/**
 * A React context that provides access to an ArrayInput methods as provided by react-hook-form
 * Useful to create custom array input iterators.
 * @see {ArrayInput}
 * @see {@link https://react-hook-form.com/api/usefieldarray}
 */
declare const ArrayInputContext: React.Context<ArrayInputContextValue>;
declare type ArrayInputContextValue = UseFieldArrayReturn;

declare const SimpleFormIteratorItem: React.ForwardRefExoticComponent<Partial<ArrayInputContextValue> & {
    children?: ReactNode;
    disabled?: boolean;
    disableRemove?: boolean | DisableRemoveFunction;
    disableReordering?: boolean;
    getItemLabel?: (index: number) => string;
    index: number;
    member: string;
    onRemoveField: (index: number) => void;
    onReorder: (origin: number, destination: number) => void;
    record: RaRecord;
    removeButton?: ReactElement;
    reOrderButtons?: ReactElement;
    resource: string;
    source: string;
} & React.RefAttributes<unknown>>;
declare type DisableRemoveFunction = (record: RaRecord) => boolean;
declare type SimpleFormIteratorItemProps = Partial<ArrayInputContextValue> & {
    children?: ReactNode;
    disabled?: boolean;
    disableRemove?: boolean | DisableRemoveFunction;
    disableReordering?: boolean;
    getItemLabel?: (index: number) => string;
    index: number;
    member: string;
    onRemoveField: (index: number) => void;
    onReorder: (origin: number, destination: number) => void;
    record: RaRecord;
    removeButton?: ReactElement;
    reOrderButtons?: ReactElement;
    resource: string;
    source: string;
};

declare const SimpleFormIterator: {
    (props: SimpleFormIteratorProps): JSX.Element;
    defaultProps: {
        disableAdd: boolean;
        disableRemove: boolean;
    };
    propTypes: {
        defaultValue: PropTypes__default.Requireable<any>;
        addButton: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        removeButton: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        className: PropTypes__default.Requireable<string>;
        field: PropTypes__default.Requireable<object>;
        fields: PropTypes__default.Requireable<any[]>;
        fieldState: PropTypes__default.Requireable<object>;
        formState: PropTypes__default.Requireable<object>;
        record: PropTypes__default.Requireable<object>;
        source: PropTypes__default.Requireable<string>;
        resource: PropTypes__default.Requireable<string>;
        translate: PropTypes__default.Requireable<(...args: any[]) => any>;
        disableAdd: PropTypes__default.Requireable<boolean>;
        disableRemove: PropTypes__default.Requireable<boolean | ((...args: any[]) => any)>;
        TransitionProps: PropTypes__default.Requireable<PropTypes__default.InferProps<{}>>;
    };
};
interface SimpleFormIteratorProps extends Partial<UseFieldArrayReturn> {
    addButton?: ReactElement;
    children?: ReactNode;
    className?: string;
    defaultValue?: any;
    disabled?: boolean;
    disableAdd?: boolean;
    disableRemove?: boolean | DisableRemoveFunction;
    disableReordering?: boolean;
    getItemLabel?: (index: number) => string;
    meta?: {
        error?: any;
        submitFailed?: boolean;
    };
    record?: RaRecord;
    removeButton?: ReactElement;
    reOrderButtons?: ReactElement;
    resource?: string;
    source?: string;
}

/**
 * A React context that provides access to a SimpleFormIterator data (the total number of items) and mutators (add, reorder and remove).
 * Useful to create custom array input iterators.
 * @see {SimpleFormIterator}
 * @see {ArrayInput}
 */
declare const SimpleFormIteratorContext: React.Context<SimpleFormIteratorContextValue>;
declare type SimpleFormIteratorContextValue = {
    add: () => void;
    remove: (index: number) => void;
    reOrder: (index: number, newIndex: number) => void;
    source: string;
    total: number;
};

/**
 * A React context that provides access to a SimpleFormIterator item meta (its index and the total number of items) and mutators (reorder and remove this remove).
 * Useful to create custom array input iterators.
 * @see {SimpleFormIterator}
 * @see {ArrayInput}
 */
declare const SimpleFormIteratorItemContext: React.Context<SimpleFormIteratorItemContextValue>;
declare type SimpleFormIteratorItemContextValue = {
    index: number;
    total: number;
    remove: () => void;
    reOrder: (newIndex: number) => void;
};

/**
 * A hook to access an array input methods as provided by react-hook-form.
 * Useful to create custom array input iterators.
 * @see {ArrayInput}
 * @see https://react-hook-form.com/api/usefieldarray
 */
declare const useArrayInput: (props?: Partial<ArrayInputContextValue>) => ArrayInputContextValue;

/**
 * A hook that provides access to a SimpleFormIterator data (the total number of items) and mutators (add, reorder and remove).
 * Useful to create custom array input iterators.
 * @see {SimpleFormIterator}
 * @see {ArrayInput}
 */
declare const useSimpleFormIterator: () => SimpleFormIteratorContextValue;

/**
 * A hook that provides access to a SimpleFormIterator item meta (its index and the total number of items) and mutators (reorder and remove this remove).
 * Useful to create custom array input iterators.
 * @see {SimpleFormIterator}
 * @see {ArrayInput}
 */
declare const useSimpleFormIteratorItem: () => SimpleFormIteratorItemContextValue;

declare const SimpleFormIteratorPrefix = "RaSimpleFormIterator";
declare const SimpleFormIteratorClasses: {
    line: string;
    index: string;
    indexContainer: string;
    form: string;
    action: string;
    leftIcon: string;
};

declare const AddItemButton: (props: Omit<ButtonProps, 'onClick'>) => JSX.Element;

declare const RemoveItemButton: (props: Omit<ButtonProps, 'onClick'>) => JSX.Element;

declare const ReOrderButtons: ({ className }: {
    className?: string;
}) => JSX.Element;

/**
 * This hook provides support for suggestion creation in inputs which have choices.
 *
 * @param options The hook option
 * @param {ReactElement} options.create A react element which will be rendered when users choose to create a new choice. This component must call the `useCreateSuggestionContext` hook which provides `onCancel`, `onCreate` and `filter`. See the examples.
 * @param {String} options.createLabel Optional. The label for the choice item allowing users to create a new choice. Can be a translation key. Defaults to `ra.action.create`.
 * @param {String} options.createItemLabel Optional. The label for the choice item allowing users to create a new choice when they already entered a filter. Can be a translation key. The translation will receive an `item` parameter. Defaults to `ra.action.create_item`.
 * @param {any} options.createValue Optional. The value for the choice item allowing users to create a new choice. Defaults to `@@ra-create`.
 * @param {String} options.filter Optional. The filter users may have already entered. Useful for autocomplete inputs for example.
 * @param {OnCreateHandler} options.onCreate Optional. A function which will be called when users choose to create a new choice, if the `create` option wasn't provided.
 * @param {Function} options.handleChange A function to pass to the input. Receives the same parameter as the original event handler and an additional newItem parameter if a new item was create.
 * @returns {UseSupportCreateValue} An object with the following properties:
 * - getCreateItem: a function which will return the label of the choice for create a new choice.
 * - createElement: a React element to render after the input. It will be rendered when users choose to create a new choice. It renders null otherwise.
 */
declare const useSupportCreateSuggestion: (options: SupportCreateSuggestionOptions) => UseSupportCreateValue;
interface SupportCreateSuggestionOptions {
    create?: ReactElement;
    createValue?: string;
    createLabel?: string;
    createItemLabel?: string;
    filter?: string;
    handleChange: (value: any) => void;
    onCreate?: OnCreateHandler;
    optionText?: OptionText;
}
interface UseSupportCreateValue {
    getCreateItem: (filterValue?: string) => {
        id: Identifier;
        [key: string]: any;
    };
    handleChange: (eventOrValue: ChangeEvent | any) => Promise<void>;
    createElement: ReactElement | null;
}
interface CreateSuggestionContextValue {
    filter?: string;
    onCreate: (choice: any) => void;
    onCancel: () => void;
}
declare const useCreateSuggestionContext: () => CreateSuggestionContextValue;
declare type OnCreateHandler = (filter?: string) => any | Promise<any>;

/**
 * An Input component for an autocomplete field, using an array of objects for the options
 *
 * Pass possible options as an array of objects in the 'choices' attribute.
 *
 * By default, the options are built from:
 *  - the 'id' property as the option value,
 *  - the 'name' property as the option text
 * @example
 * const choices = [
 *    { id: 'M', name: 'Male' },
 *    { id: 'F', name: 'Female' },
 * ];
 * <AutocompleteInput source="gender" choices={choices} />
 *
 * You can also customize the properties to use for the option name and value,
 * thanks to the 'optionText' and 'optionValue' attributes.
 * @example
 * const choices = [
 *    { _id: 123, full_name: 'Leo Tolstoi', sex: 'M' },
 *    { _id: 456, full_name: 'Jane Austen', sex: 'F' },
 * ];
 * <AutocompleteInput source="author_id" choices={choices} optionText="full_name" optionValue="_id" />
 *
 * `optionText` also accepts a function, so you can shape the option text at will:
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;
 * <AutocompleteInput source="author_id" choices={choices} optionText={optionRenderer} />
 *
 * `optionText` also accepts a React Element, that can access
 * the related choice through the `useRecordContext` hook. You can use Field components there.
 * Note that you must also specify the `matchSuggestion` and `inputText` props
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const matchSuggestion = (filterValue, choice) => choice.first_name.match(filterValue) || choice.last_name.match(filterValue)
 * const inputText = (record) => `${record.fullName} (${record.language})`;
 *
 * const FullNameField = () => {
 *     const record = useRecordContext();
 *     return <span>{record.first_name} {record.last_name}</span>;
 * }
 * <AutocompleteInput source="author" choices={choices} optionText={<FullNameField />} matchSuggestion={matchSuggestion} inputText={inputText} />
 *
 * The choices are translated by default, so you can use translation identifiers as choices:
 * @example
 * const choices = [
 *    { id: 'M', name: 'myroot.gender.male' },
 *    { id: 'F', name: 'myroot.gender.female' },
 * ];
 *
 * However, in some cases (e.g. inside a `<ReferenceInput>`), you may not want
 * the choice to be translated. In that case, set the `translateChoice` prop to false.
 * @example
 * <AutocompleteInput source="gender" choices={choices} translateChoice={false}/>
 *
 * The object passed as `options` props is passed to the MUI <TextField> component
 *
 * @example
 * <AutocompleteInput source="author_id" options={{ color: 'secondary', InputLabelProps: { shrink: true } }} />
 */
declare const AutocompleteInput: <OptionType extends RaRecord = RaRecord, Multiple extends boolean = false, DisableClearable extends boolean = false, SupportCreate extends boolean = false>(props: AutocompleteInputProps<OptionType, Multiple, DisableClearable, SupportCreate>) => JSX.Element;
declare const AutocompleteInputClasses: {
    textField: string;
};
interface AutocompleteInputProps<OptionType extends any = RaRecord, Multiple extends boolean | undefined = false, DisableClearable extends boolean | undefined = false, SupportCreate extends boolean | undefined = false> extends Omit<CommonInputProps, 'source'>, ChoicesProps, UseSuggestionsOptions, Omit<SupportCreateSuggestionOptions, 'handleChange' | 'optionText'>, Omit<AutocompleteProps<OptionType, Multiple, DisableClearable, SupportCreate>, 'onChange' | 'options' | 'renderInput'> {
    debounce?: number;
    filterToQuery?: (searchText: string) => any;
    inputText?: (option: any) => string;
    setFilter?: (value: string) => void;
    shouldRenderSuggestions?: any;
    source?: string;
    TextFieldProps?: TextFieldProps$1;
}

/**
 * An Input component for an autocomplete field, using an array of objects for the options
 *
 * Pass possible options as an array of objects in the 'choices' attribute.
 *
 * By default, the options are built from:
 *  - the 'id' property as the option value,
 *  - the 'name' property as the option text
 * @example
 * const choices = [
 *    { id: 'M', name: 'Male' },
 *    { id: 'F', name: 'Female' },
 * ];
 * <AutocompleteArrayInput source="gender" choices={choices} />
 *
 * You can also customize the properties to use for the option name and value,
 * thanks to the 'optionText' and 'optionValue' attributes.
 * @example
 * const choices = [
 *    { _id: 123, full_name: 'Leo Tolstoi', sex: 'M' },
 *    { _id: 456, full_name: 'Jane Austen', sex: 'F' },
 * ];
 * <AutocompleteArrayInput source="author_id" choices={choices} optionText="full_name" optionValue="_id" />
 *
 * `optionText` also accepts a function, so you can shape the option text at will:
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;
 * <AutocompleteArrayInput source="author_id" choices={choices} optionText={optionRenderer} />
 *
 * `optionText` also accepts a React Element, that can access
 * the related choice through the `useRecordContext` hook. You can use Field components there.
 * Note that you must also specify the `matchSuggestion` and `inputText` props
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const matchSuggestion = (filterValue, choice) => choice.first_name.match(filterValue) || choice.last_name.match(filterValue)
 * const inputText = (record) => `${record.fullName} (${record.language})`;
 *
 * const FullNameField = () => {
 *     const record = useRecordContext();
 *     return <span>{record.first_name} {record.last_name}</span>;
 * }
 *
 * <AutocompleteArrayInput source="gender" choices={choices} optionText={<FullNameField />} matchSuggestion={matchSuggestion} />
 *
 * The choices are translated by default, so you can use translation identifiers as choices:
 * @example
 * const choices = [
 *    { id: 'M', name: 'myroot.gender.male' },
 *    { id: 'F', name: 'myroot.gender.female' },
 * ];
 *
 * However, in some cases (e.g. inside a `<ReferenceInput>`), you may not want
 * the choice to be translated. In that case, set the `translateChoice` prop to false.
 * @example
 * <AutocompleteArrayInput source="gender" choices={choices} translateChoice={false}/>
 */
declare const AutocompleteArrayInput: <OptionType extends RaRecord = RaRecord, DisableClearable extends boolean = false, SupportCreate extends boolean = false>({ defaultValue, ...props }: AutocompleteArrayInputProps) => JSX.Element;
declare type AutocompleteArrayInputProps<OptionType extends any = RaRecord, DisableClearable extends boolean | undefined = false, SupportCreate extends boolean | undefined = false> = Omit<AutocompleteInputProps<OptionType, true, DisableClearable, SupportCreate>, 'defaultValue'> & {
    defaultValue?: any[];
};

declare const BooleanInput: {
    (props: BooleanInputProps): JSX.Element;
    propTypes: {
        options: PropTypes__default.Requireable<PropTypes__default.InferProps<any>>;
        disabled: PropTypes__default.Requireable<boolean>;
        label: PropTypes__default.Requireable<string | boolean>;
        resource: PropTypes__default.Requireable<string>;
        source: PropTypes__default.Requireable<string>;
    };
    defaultProps: {
        options: {};
    };
};
declare type BooleanInputProps = CommonInputProps & SwitchProps & Omit<FormGroupProps, 'defaultValue' | 'onChange' | 'onBlur' | 'onFocus'> & {
    options: SwitchProps;
};

/**
 * An Input component for a checkbox group, using an array of objects for the options
 *
 * Pass possible options as an array of objects in the 'choices' attribute.
 *
 * The expected input must be an array of identifiers (e.g. [12, 31]) which correspond to
 * the 'optionValue' of 'choices' attribute objects.
 *
 * By default, the options are built from:
 *  - the 'id' property as the option value,
 *  - the 'name' property as the option text
 * @example
 * const choices = [
 *     { id: 12, name: 'Ray Hakt' },
 *     { id: 31, name: 'Ann Gullar' },
 *     { id: 42, name: 'Sean Phonee' },
 * ];
 * <CheckboxGroupInput source="recipients" choices={choices} />
 *
 * You can also customize the properties to use for the option name and value,
 * thanks to the 'optionText' and 'optionValue' attributes.
 * @example
 * const choices = [
 *    { _id: 123, full_name: 'Leo Tolstoi' },
 *    { _id: 456, full_name: 'Jane Austen' },
 * ];
 * <CheckboxGroupInput source="recipients" choices={choices} optionText="full_name" optionValue="_id" />
 *
 * `optionText` also accepts a function, so you can shape the option text at will:
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;
 * <CheckboxGroupInput source="recipients" choices={choices} optionText={optionRenderer} />
 *
 * `optionText` also accepts a React Element, that can access
 * the related choice through the `useRecordContext` hook. You can use Field components there.
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const FullNameField = () => {
 *     const record = useRecordContext();
 *     return <span>{record.first_name} {record.last_name}</span>;
 * };
 *
 * <CheckboxGroupInput source="recipients" choices={choices} optionText={<FullNameField />}/>
 *
 * The choices are translated by default, so you can use translation identifiers as choices:
 * @example
 * const choices = [
 *    { id: 'programming', name: 'myroot.category.programming' },
 *    { id: 'lifestyle', name: 'myroot.category.lifestyle' },
 *    { id: 'photography', name: 'myroot.category.photography' },
 * ];
 *
 * However, in some cases (e.g. inside a `<ReferenceArrayInput>`), you may not want
 * the choice to be translated. In that case, set the `translateChoice` prop to false.
 * @example
 * <CheckboxGroupInput source="tags" choices={choices} translateChoice={false}/>
 *
 * The object passed as `options` props is passed to the MUI <Checkbox> components
 */
declare const CheckboxGroupInput: FunctionComponent<CheckboxGroupInputProps>;
declare type CheckboxGroupInputProps = Omit<CommonInputProps, 'source'> & ChoicesProps & CheckboxProps & FormControlProps$1 & {
    row?: boolean;
    source?: string;
};
declare const CheckboxGroupInputClasses: {
    label: string;
};

declare const DatagridRow: FC<DatagridRowProps>;
interface DatagridRowProps extends Omit<TableRowProps, 'id' | 'classes'> {
    className?: string;
    expand?: ReactElement | FC<{
        id: Identifier;
        record: RaRecord;
        resource: string;
    }>;
    hasBulkActions?: boolean;
    hover?: boolean;
    id?: Identifier;
    onToggleItem?: (id: Identifier, event: React__default.TouchEvent | React__default.MouseEvent) => void;
    record?: RaRecord;
    resource?: string;
    rowClick?: RowClickFunction | string | false;
    selected?: boolean;
    style?: any;
    selectable?: boolean;
}
declare type RowClickFunction = (id: Identifier, resource: string, record: RaRecord) => string | Promise<string>;
declare const PureDatagridRow: React__default.NamedExoticComponent<DatagridRowProps>;

declare const DatagridBody: FC<DatagridBodyProps>;
interface DatagridBodyProps extends Omit<TableBodyProps, 'classes'> {
    className?: string;
    data?: any[];
    expand?: ReactElement | FC<{
        id: Identifier;
        record: RaRecord;
        resource: string;
    }>;
    hasBulkActions?: boolean;
    hover?: boolean;
    onToggleItem?: (id: Identifier, event: React.TouchEvent | React.MouseEvent) => void;
    record?: RaRecord;
    resource?: string;
    row?: ReactElement;
    rowClick?: string | RowClickFunction;
    rowStyle?: (record: RaRecord, index: number) => any;
    selectedIds?: Identifier[];
    isRowSelectable?: (record: RaRecord) => boolean;
}
declare const PureDatagridBody: React.NamedExoticComponent<DatagridBodyProps>;

declare const DatagridCell: React.ForwardRefExoticComponent<Pick<DatagridCellProps, "className" | "style" | "classes" | "abbr" | "slot" | "title" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "dir" | "draggable" | "hidden" | "id" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "translate" | "radioGroup" | "role" | "about" | "datatype" | "inlist" | "prefix" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "color" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "children" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "sx" | "height" | "width" | "padding" | "size" | "component" | "align" | "colSpan" | "headers" | "rowSpan" | "scope" | "valign" | "variant" | "record" | "field" | "sortDirection"> & React.RefAttributes<HTMLTableCellElement>>;
interface DatagridCellProps extends TableCellProps {
    className?: string;
    field?: JSX.Element;
    record?: RaRecord;
    resource?: string;
}

interface DatagridHeaderCellProps extends Omit<TableCellProps, 'classes'> {
    className?: string;
    field?: JSX.Element;
    isSorting?: boolean;
    resource: string;
    sort: SortPayload;
    updateSort?: (event: any) => void;
}
declare const _default$2: React.MemoExoticComponent<{
    (props: DatagridHeaderCellProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        field: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        sort: PropTypes__default.Validator<PropTypes__default.InferProps<{
            field: PropTypes__default.Requireable<string>;
            order: PropTypes__default.Requireable<string>;
        }>>;
        isSorting: PropTypes__default.Requireable<boolean>;
        resource: PropTypes__default.Requireable<string>;
        updateSort: PropTypes__default.Requireable<(...args: any[]) => any>;
    };
}>;

declare const DatagridHeaderCellClasses: {
    icon: string;
};

interface DatagridLoadingProps {
    className?: string;
    expand?: ReactElement | FC<{
        id: Identifier;
        record: RaRecord;
        resource: string;
    }>;
    hasBulkActions?: boolean;
    nbChildren: number;
    nbFakeLines?: number;
    size?: 'small' | 'medium';
}
declare const _default$1: React.MemoExoticComponent<{
    ({ className, expand, hasBulkActions, nbChildren, nbFakeLines, size, }: DatagridLoadingProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        expand: PropTypes__default.Requireable<PropTypes__default.ReactElementLike | PropTypes__default.ReactComponentLike>;
        hasBulkActions: PropTypes__default.Requireable<boolean>;
        nbChildren: PropTypes__default.Requireable<number>;
        nbFakeLines: PropTypes__default.Requireable<number>;
        size: PropTypes__default.Requireable<string>;
    };
}>;

interface ExpandRowButtonProps extends IconButtonProps$1 {
    component?: ElementType;
    expanded: boolean;
    expandContentId?: string;
}
declare const _default: React.MemoExoticComponent<({ expanded, expandContentId, ...props }: ExpandRowButtonProps) => JSX.Element>;

/**
 * The Datagrid component renders a list of records as a table.
 * It is usually used as a child of the <List> and <ReferenceManyField> components.
 *
 * Props:
 *  - body
 *  - bulkActionButtons
 *  - children
 *  - empty
 *  - expand
 *  - header
 *  - hover
 *  - isRowExpandable
 *  - isRowSelectable
 *  - optimized
 *  - rowStyle
 *  - rowClick
 *  - size
 *  - sx
 *
 * @example // Display all posts as a datagrid
 * const postRowStyle = (record, index) => ({
 *     backgroundColor: record.nb_views >= 500 ? '#efe' : 'white',
 * });
 * export const PostList = (props) => (
 *     <List {...props}>
 *         <Datagrid rowStyle={postRowStyle}>
 *             <TextField source="id" />
 *             <TextField source="title" />
 *             <TextField source="body" />
 *             <EditButton />
 *         </Datagrid>
 *     </List>
 * );
 *
 * @example // Display all the comments of the current post as a datagrid
 * <ReferenceManyField reference="comments" target="post_id">
 *     <Datagrid>
 *         <TextField source="id" />
 *         <TextField source="body" />
 *         <DateField source="created_at" />
 *         <EditButton />
 *     </Datagrid>
 * </ReferenceManyField>
 *
 * @example // Usage outside of a <List> or a <ReferenceManyField>.
 *
 * const sort = { field: 'published_at', order: 'DESC' };
 *
 * export const MyCustomList = (props) => {
 *     const { data, total, isLoading } = useGetList(
 *         'posts',
 *         { pagination: { page: 1, perPage: 10 }, sort: sort }
 *     );
 *
 *     return (
 *         <Datagrid
 *             data={data}
 *             total={total}
 *             isLoading={isLoading}
 *             sort={sort}
 *             selectedIds={[]}
 *             setSort={() => {
 *                 console.log('set sort');
 *             }}
 *             onSelect={() => {
 *                 console.log('on select');
 *             }}
 *             onToggleItem={() => {
 *                 console.log('on toggle item');
 *             }}
 *         >
 *             <TextField source="id" />
 *             <TextField source="title" />
 *         </Datagrid>
 *     );
 * }
 */
declare const Datagrid: FC<DatagridProps>;
interface DatagridProps<RecordType extends RaRecord = any> extends Omit<TableProps, 'size' | 'classes' | 'onSelect'> {
    body?: ReactElement | ComponentType;
    className?: string;
    bulkActionButtons?: ReactElement | false;
    expand?: ReactElement | FC<{
        id: Identifier;
        record: RecordType;
        resource: string;
    }>;
    header?: ReactElement | ComponentType;
    hover?: boolean;
    empty?: ReactElement;
    isRowSelectable?: (record: RecordType) => boolean;
    isRowExpandable?: (record: RecordType) => boolean;
    optimized?: boolean;
    rowClick?: string | RowClickFunction;
    rowStyle?: (record: RecordType, index: number) => any;
    size?: 'medium' | 'small';
    sort?: SortPayload;
    data?: RecordType[];
    isLoading?: boolean;
    onSelect?: (ids: Identifier[]) => void;
    onToggleItem?: (id: Identifier) => void;
    setSort?: (sort: SortPayload) => void;
    selectedIds?: Identifier[];
    expandSingle?: boolean;
    total?: number;
}

/**
 * The default Datagrid Header component.
 *
 * Renders select all checkbox as well as column header buttons used for sorting.
 */
declare const DatagridHeader: {
    (props: DatagridHeaderProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        className: PropTypes__default.Requireable<string>;
        sort: PropTypes__default.Requireable<Required<PropTypes__default.InferProps<{
            field: PropTypes__default.Requireable<string>;
            order: PropTypes__default.Requireable<string>;
        }>>>;
        data: PropTypes__default.Requireable<any[]>;
        hasExpand: PropTypes__default.Requireable<boolean>;
        hasBulkActions: PropTypes__default.Requireable<boolean>;
        isRowSelectable: PropTypes__default.Requireable<(...args: any[]) => any>;
        isRowExpandable: PropTypes__default.Requireable<(...args: any[]) => any>;
        onSelect: PropTypes__default.Requireable<(...args: any[]) => any>;
        onToggleItem: PropTypes__default.Requireable<(...args: any[]) => any>;
        resource: PropTypes__default.Requireable<string>;
        selectedIds: PropTypes__default.Requireable<any[]>;
        setSort: PropTypes__default.Requireable<(...args: any[]) => any>;
    };
    displayName: string;
};
interface DatagridHeaderProps<RecordType extends RaRecord = any> {
    children?: React.ReactNode;
    className?: string;
    hasExpand?: boolean;
    hasBulkActions?: boolean;
    isRowSelectable?: (record: RecordType) => boolean;
    isRowExpandable?: (record: RecordType) => boolean;
    size?: 'medium' | 'small';
    sort?: SortPayload;
    data?: RecordType[];
    onSelect?: (ids: Identifier[]) => void;
    onToggleItem?: (id: Identifier) => void;
    resource?: string;
    selectedIds?: Identifier[];
    setSort?: (sort: SortPayload) => void;
}

declare const DatagridClasses: {
    table: string;
    tableWrapper: string;
    thead: string;
    tbody: string;
    headerRow: string;
    headerCell: string;
    checkbox: string;
    row: string;
    clickableRow: string;
    rowEven: string;
    rowOdd: string;
    rowCell: string;
    selectable: string;
    expandHeader: string;
    expandIconCell: string;
    expandIcon: string;
    expandable: string;
    expanded: string;
    expandedPanel: string;
};
declare const DatagridRoot: _emotion_styled.StyledComponent<_mui_system.MUIStyledCommonProps<_mui_material.Theme>, Pick<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, keyof React.HTMLAttributes<HTMLDivElement> | keyof React.ClassAttributes<HTMLDivElement>>, {}>;

/**
 * WIP: This component is not yet ready to be used.
 *
 * An input for selecting items displayed in a datagrid
 *
 * @example
 * const membersFilters = [
 *     <TextInput label="Search" source="q" alwaysOn />,
 * ];
 * const TeamEdit = () => (
 *    <Edit>
 *        <SimpleForm>
 *            <TextInput source="name" />
 *            <ReferenceArrayInput
 *                source="members"
 *                reference="users"
 *                filter={{ is_retired: false }}
 *                perPage={50}
 *                sort={{ field: 'lastName', order: 'ASC' }}
 *            >
 *                <DatagridInput
 *                    filters={membersFilters}
 *                >
 *                    <TextField source="firstName" />
 *                    <TextField source="lastName" />
 *                </DatagridInput>
 *            </ReferenceArrayInput>
 *        </SimpleForm>
 *    </Edit>
 * );
 */
declare const DatagridInput: (props: DatagridInputProps) => JSX.Element;
declare type DatagridInputProps = Omit<CommonInputProps, 'source'> & ChoicesProps & Omit<SupportCreateSuggestionOptions, 'handleChange'> & DatagridProps & {
    children?: ReactNode;
    source?: string;
    filters?: ReactElement | ReactElement[];
    pagination?: ReactElement | false;
};

/**
 * Form input to edit a Date string value in the "YYYY-MM-DD" format (e.g. '2021-06-23').
 *
 * Renders a date picker (the exact UI depends on the browser).
 *
 * @example
 * import { Edit, SimpleForm, DateInput } from 'react-admin';
 *
 * const PostEdit = (props) => (
 *     <Edit {...props}>
 *         <SimpleForm>
 *             <DateInput source="published_at" />
 *         </SimpleForm>
 *     </Edit>
 * );
 *
 * @example
 * // If the initial value is a Date object, DateInput converts it to a string
 * // but you must pass a custom parse method to convert the form value
 * // (which is always a date string) back to a Date object.
 * <DateInput source="published_at" parse={val => new Date(val)} />
 */
declare const DateInput: {
    ({ className, defaultValue, format, label, name, source, resource, helperText, margin, onBlur, onChange, parse, validate, variant, ...rest }: DateInputProps): JSX.Element;
    propTypes: {
        label: PropTypes__default.Requireable<string | boolean>;
        resource: PropTypes__default.Requireable<string>;
        source: PropTypes__default.Requireable<string>;
    };
};
declare type DateInputProps = CommonInputProps & Omit<TextFieldProps$2, 'helperText' | 'label'>;

/**
 * Input component for entering a date and a time with timezone, using the browser locale
 */
declare const DateTimeInput: {
    ({ className, defaultValue, format, label, helperText, margin, onBlur, onChange, source, resource, parse, validate, variant, ...rest }: DateTimeInputProps): JSX.Element;
    propTypes: {
        label: PropTypes__default.Requireable<string | boolean>;
        resource: PropTypes__default.Requireable<string>;
        source: PropTypes__default.Requireable<string>;
    };
};
declare type DateTimeInputProps = CommonInputProps & Omit<TextFieldProps$2, 'helperText' | 'label'>;

declare const FileInput: {
    (props: FileInputProps): JSX.Element;
    propTypes: {
        accept: PropTypes__default.Requireable<string>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        className: PropTypes__default.Requireable<string>;
        id: PropTypes__default.Requireable<string>;
        isRequired: PropTypes__default.Requireable<boolean>;
        label: PropTypes__default.Requireable<string>;
        labelMultiple: PropTypes__default.Requireable<string>;
        labelSingle: PropTypes__default.Requireable<string>;
        maxSize: PropTypes__default.Requireable<number>;
        minSize: PropTypes__default.Requireable<number>;
        multiple: PropTypes__default.Requireable<boolean>;
        validateFileRemoval: PropTypes__default.Requireable<(...args: any[]) => any>;
        options: PropTypes__default.Requireable<object>;
        resource: PropTypes__default.Requireable<string>;
        source: PropTypes__default.Requireable<string>;
        placeholder: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
    };
};
declare const FileInputClasses: {
    dropZone: string;
    preview: string;
    removeButton: string;
};
declare type FileInputProps = CommonInputProps & {
    accept?: DropzoneOptions['accept'];
    className?: string;
    children?: ReactNode;
    labelMultiple?: string;
    labelSingle?: string;
    maxSize?: DropzoneOptions['maxSize'];
    minSize?: DropzoneOptions['minSize'];
    multiple?: DropzoneOptions['multiple'];
    options?: DropzoneOptions;
    onRemove?: Function;
    placeholder?: ReactNode;
    inputProps?: any;
    validateFileRemoval?(file: any): boolean | Promise<boolean>;
    sx?: SxProps$1;
};

declare const ImageInput: (props: ImageInputProps) => JSX.Element;
declare type ImageInputProps = FileInputProps;

declare const InputHelperText: (props: InputHelperTextProps) => JSX.Element;
interface InputHelperTextProps {
    helperText?: string | ReactElement | boolean;
    error?: ValidationErrorMessage;
    touched: boolean;
}

/**
 * Common PropTypes for all react-admin inputs
 */
declare const InputPropTypes: {
    label: PropTypes__default.Requireable<string | boolean>;
    resource: PropTypes__default.Requireable<string>;
    source: PropTypes__default.Requireable<string>;
};

declare const NullableBooleanInput: {
    (props: NullableBooleanInputProps): JSX.Element;
    propTypes: {
        label: PropTypes__default.Requireable<string | boolean>;
        options: PropTypes__default.Requireable<object>;
        resource: PropTypes__default.Requireable<string>;
        source: PropTypes__default.Requireable<string>;
        nullLabel: PropTypes__default.Requireable<string>;
        falseLabel: PropTypes__default.Requireable<string>;
        trueLabel: PropTypes__default.Requireable<string>;
    };
};
declare const NullableBooleanInputClasses: {
    input: string;
};
declare type NullableBooleanInputProps = CommonInputProps & Omit<TextFieldProps$2, 'label' | 'helperText'> & {
    nullLabel?: string;
    falseLabel?: string;
    trueLabel?: string;
};

/**
 * An Input component for a number
 *
 * Due to limitations in React controlled components and number formatting,
 * this input only updates the form value on blur.
 *
 * @example
 * <NumberInput source="nb_views" />
 *
 * You can customize the `step` props (which defaults to "any")
 * @example
 * <NumberInput source="nb_views" step={1} />
 *
 */
declare const NumberInput: {
    ({ className, defaultValue, format, helperText, label, margin, onBlur, onChange, parse, resource, source, step, min, max, validate, variant, inputProps: overrideInputProps, ...rest }: NumberInputProps): JSX.Element;
    propTypes: {
        label: PropTypes__default.Requireable<string | boolean>;
        options: PropTypes__default.Requireable<object>;
        resource: PropTypes__default.Requireable<string>;
        source: PropTypes__default.Requireable<string>;
        step: PropTypes__default.Requireable<string | number>;
    };
    defaultProps: {
        options: {};
        step: string;
        textAlign: string;
    };
};
interface NumberInputProps extends CommonInputProps, Omit<TextFieldProps$2, 'label' | 'helperText' | 'defaultValue' | 'onChange' | 'onBlur'> {
    step?: string | number;
    min?: string | number;
    max?: string | number;
}

/**
 * An override of the default MUI TextField which is resettable
 */
declare const ResettableTextField: React.ForwardRefExoticComponent<Pick<Props$2 & Omit<TextFieldProps$1, "onChange"> & {
    onChange?: (eventOrValue: any) => void;
}, "className" | "style" | "classes" | "label" | "slot" | "select" | "title" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "dir" | "draggable" | "hidden" | "id" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "translate" | "radioGroup" | "role" | "about" | "datatype" | "inlist" | "prefix" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "color" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "children" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "disabled" | "sx" | "key" | "type" | "margin" | "size" | "autoFocus" | "name" | "value" | "error" | "autoComplete" | "required" | "rows" | "fullWidth" | "variant" | "helperText" | "focused" | "hiddenLabel" | "inputProps" | "inputRef" | "multiline" | "maxRows" | "minRows" | "InputProps" | "FormHelperTextProps" | "InputLabelProps" | "SelectProps" | keyof Props$2> & React.RefAttributes<unknown>>;
interface Props$2 {
    clearAlwaysVisible?: boolean;
    resettable?: boolean;
}
declare type ResettableTextFieldProps = Props$2 & Omit<TextFieldProps$1, 'onChange'> & {
    onChange?: (eventOrValue: any) => void;
};
declare const ResettableTextFieldClasses: {
    clearIcon: string;
    visibleClearIcon: string;
    clearButton: string;
    selectAdornment: string;
    inputAdornedEnd: string;
};
declare const ResettableTextFieldStyles: {
    [x: string]: {
        height: number;
        width: number;
        padding?: undefined;
        position?: undefined;
        right?: undefined;
        paddingRight?: undefined;
    } | {
        width: number;
        height?: undefined;
        padding?: undefined;
        position?: undefined;
        right?: undefined;
        paddingRight?: undefined;
    } | {
        height: number;
        width: number;
        padding: number;
        position?: undefined;
        right?: undefined;
        paddingRight?: undefined;
    } | {
        position: string;
        right: number;
        height?: undefined;
        width?: undefined;
        padding?: undefined;
        paddingRight?: undefined;
    } | {
        paddingRight: number;
        height?: undefined;
        width?: undefined;
        padding?: undefined;
        position?: undefined;
        right?: undefined;
    };
};

/**
 * An Input component for a string
 *
 * @example
 * <TextInput source="first_name" />
 *
 * You can customize the `type` props (which defaults to "text").
 * Note that, due to a React bug, you should use `<NumberField>` instead of using type="number".
 * @example
 * <TextInput source="email" type="email" />
 * <NumberInput source="nb_views" />
 *
 * The object passed as `options` props is passed to the <ResettableTextField> component
 */
declare const TextInput: {
    (props: TextInputProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        label: PropTypes__default.Requireable<string | boolean>;
        options: PropTypes__default.Requireable<object>;
        resource: PropTypes__default.Requireable<string>;
        source: PropTypes__default.Requireable<string>;
    };
    defaultProps: {
        options: {};
    };
};
declare type TextInputProps = CommonInputProps & Omit<ResettableTextFieldProps, 'label' | 'helperText'>;

declare const PasswordInput: (props: PasswordInputProps) => JSX.Element;
interface PasswordInputProps extends TextInputProps {
    initiallyVisible?: boolean;
}

/**
 * An Input component for a radio button group, using an array of objects for the options
 *
 * Pass possible options as an array of objects in the 'choices' attribute.
 *
 * By default, the options are built from:
 *  - the 'id' property as the option value,
 *  - the 'name' property as the option text
 * @example
 * const choices = [
 *    { id: 'M', name: 'Male' },
 *    { id: 'F', name: 'Female' },
 * ];
 * <RadioButtonGroupInput source="gender" choices={choices} />
 *
 * You can also customize the properties to use for the option name and value,
 * thanks to the 'optionText' and 'optionValue' attributes.
 * @example
 * const choices = [
 *    { _id: 123, full_name: 'Leo Tolstoi', sex: 'M' },
 *    { _id: 456, full_name: 'Jane Austen', sex: 'F' },
 * ];
 * <RadioButtonGroupInput source="author_id" choices={choices} optionText="full_name" optionValue="_id" />
 *
 * `optionText` also accepts a function, so you can shape the option text at will:
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;
 * <CheckboxGroupInput source="recipients" choices={choices} optionText={optionRenderer} />
 *
 * `optionText` also accepts a React Element, that can access
 * the related choice through the `useRecordContext` hook. You can use Field components there.
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const FullNameField = ({ record }) => <span>{record.first_name} {record.last_name}</span>;
 * <RadioButtonGroupInput source="recipients" choices={choices} optionText={<FullNameField />}/>
 *
 * The choices are translated by default, so you can use translation identifiers as choices:
 * @example
 * const choices = [
 *    { id: 'M', name: 'myroot.gender.male' },
 *    { id: 'F', name: 'myroot.gender.female' },
 * ];
 *
 * However, in some cases (e.g. inside a `<ReferenceInput>`), you may not want
 * the choice to be translated. In that case, set the `translateChoice` prop to false.
 * @example
 * <RadioButtonGroupInput source="gender" choices={choices} translateChoice={false}/>
 *
 * The object passed as `options` props is passed to the MUI <RadioButtonGroup> component
 */
declare const RadioButtonGroupInput: {
    (props: RadioButtonGroupInputProps): JSX.Element;
    propTypes: {
        choices: PropTypes__default.Requireable<any[]>;
        label: PropTypes__default.Requireable<string | boolean>;
        options: PropTypes__default.Requireable<object>;
        optionText: PropTypes__default.Requireable<string | PropTypes__default.ReactElementLike | ((...args: any[]) => any)>;
        optionValue: PropTypes__default.Requireable<string>;
        resource: PropTypes__default.Requireable<string>;
        source: PropTypes__default.Requireable<string>;
        translateChoice: PropTypes__default.Requireable<boolean>;
    };
    defaultProps: {
        options: {};
        optionText: string;
        optionValue: string;
        row: boolean;
        translateChoice: boolean;
    };
};
declare type RadioButtonGroupInputProps = CommonInputProps & ChoicesProps & FormControlProps$1 & RadioGroupProps;
declare const RadioButtonGroupInputClasses: {
    label: string;
};

/**
 * An Input component for fields containing a list of references to another resource.
 * Useful for 'hasMany' relationship.
 *
 * @example
 * The post object has many tags, so the post resource looks like:
 * {
 *    id: 1234,
 *    tag_ids: [ "1", "23", "4" ]
 * }
 *
 * ReferenceArrayInput component fetches the current resources (using
 * `dataProvider.getMany()`) as well as possible resources (using
 * `dataProvider.getList()`) in the reference endpoint. It then
 * delegates rendering to its child component, to which it makes the possible
 * choices available through the ChoicesContext.
 *
 * Use it with a selector component as child, like `<SelectArrayInput>`
 * or <CheckboxGroupInput>.
 *
 * @example
 * export const PostEdit = (props) => (
 *     <Edit {...props}>
 *         <SimpleForm>
 *             <ReferenceArrayInput source="tag_ids" reference="tags">
 *                 <SelectArrayInput optionText="name" />
 *             </ReferenceArrayInput>
 *         </SimpleForm>
 *     </Edit>
 * );
 *
 * By default, restricts the possible values to 25. You can extend this limit
 * by setting the `perPage` prop.
 *
 * @example
 * <ReferenceArrayInput
 *      source="tag_ids"
 *      reference="tags"
 *      perPage={100}>
 *     <SelectArrayInput optionText="name" />
 * </ReferenceArrayInput>
 *
 * By default, orders the possible values by id desc. You can change this order
 * by setting the `sort` prop (an object with `field` and `order` properties).
 *
 * @example
 * <ReferenceArrayInput
 *      source="tag_ids"
 *      reference="tags"
 *      sort={{ field: 'name', order: 'ASC' }}>
 *     <SelectArrayInput optionText="name" />
 * </ReferenceArrayInput>
 *
 * Also, you can filter the query used to populate the possible values. Use the
 * `filter` prop for that.
 *
 * @example
 * <ReferenceArrayInput
 *      source="tag_ids"
 *      reference="tags"
 *      filter={{ is_public: true }}>
 *     <SelectArrayInput optionText="name" />
 * </ReferenceArrayInput>
 *
 * The enclosed component may filter results. ReferenceArrayInput create a ChoicesContext which provides
 * a `setFilters` function. You can call this function to filter the results.
 */
declare const ReferenceArrayInput: {
    (props: ReferenceArrayInputProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Validator<PropTypes__default.ReactElementLike>;
        filter: PropTypes__default.Requireable<object>;
        label: PropTypes__default.Requireable<string>;
        page: PropTypes__default.Requireable<number>;
        perPage: PropTypes__default.Requireable<number>;
        reference: PropTypes__default.Validator<string>;
        resource: PropTypes__default.Requireable<string>;
        sort: PropTypes__default.Requireable<PropTypes__default.InferProps<{
            field: PropTypes__default.Requireable<string>;
            order: PropTypes__default.Requireable<string>;
        }>>;
        source: PropTypes__default.Requireable<string>;
    };
    defaultProps: {
        filter: {};
        page: number;
        perPage: number;
        sort: {
            field: string;
            order: string;
        };
    };
};
interface ReferenceArrayInputProps extends InputProps {
    children: ReactElement;
    label?: string;
    page?: number;
    perPage?: number;
    reference: string;
    resource?: string;
    enableGetChoices?: (filters: any) => boolean;
    [key: string]: any;
}

/**
 * An Input component for choosing a reference record. Useful for foreign keys.
 *
 * This component fetches the possible values in the reference resource
 * (using `dataProvider.getList()`), then delegates rendering
 * to a subcomponent, to which it passes the possible choices
 * as the `choices` attribute.
 *
 * Use it with a selector component as child, like `<AutocompleteInput>`,
 * `<SelectInput>`, or `<RadioButtonGroupInput>`.
 *
 * @example
 * export const CommentEdit = (props) => (
 *     <Edit {...props}>
 *         <SimpleForm>
 *             <ReferenceInput label="Post" source="post_id" reference="posts">
 *                 <AutocompleteInput optionText="title" />
 *             </ReferenceInput>
 *         </SimpleForm>
 *     </Edit>
 * );
 *
 * @example
 * export const CommentEdit = (props) => (
 *     <Edit {...props}>
 *         <SimpleForm>
 *             <ReferenceInput label="Post" source="post_id" reference="posts">
 *                 <SelectInput optionText="title" />
 *             </ReferenceInput>
 *         </SimpleForm>
 *     </Edit>
 * );
 *
 * By default, restricts the possible values to 25. You can extend this limit
 * by setting the `perPage` prop.
 *
 * @example
 * <ReferenceInput
 *      source="post_id"
 *      reference="posts"
 *      perPage={100}>
 *     <SelectInput optionText="title" />
 * </ReferenceInput>
 *
 * By default, orders the possible values by id desc. You can change this order
 * by setting the `sort` prop (an object with `field` and `order` properties).
 *
 * @example
 * <ReferenceInput
 *      source="post_id"
 *      reference="posts"
 *      sort={{ field: 'title', order: 'ASC' }}>
 *     <SelectInput optionText="title" />
 * </ReferenceInput>
 *
 * Also, you can filter the query used to populate the possible values. Use the
 * `filter` prop for that.
 *
 * @example
 * <ReferenceInput
 *      source="post_id"
 *      reference="posts"
 *      filter={{ is_published: true }}>
 *     <SelectInput optionText="title" />
 * </ReferenceInput>
 *
 * The enclosed component may filter results. ReferenceInput create a ChoicesContext which provides
 * a `setFilters` function. You can call this function to filter the results.
 */
declare const ReferenceInput: {
    (props: ReferenceInputProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Validator<PropTypes__default.ReactElementLike>;
        filter: PropTypes__default.Requireable<object>;
        label: PropTypes__default.Requireable<string>;
        page: PropTypes__default.Requireable<number>;
        perPage: PropTypes__default.Requireable<number>;
        record: PropTypes__default.Requireable<object>;
        reference: PropTypes__default.Validator<string>;
        resource: PropTypes__default.Requireable<string>;
        sort: PropTypes__default.Requireable<PropTypes__default.InferProps<{
            field: PropTypes__default.Requireable<string>;
            order: PropTypes__default.Requireable<string>;
        }>>;
        source: PropTypes__default.Requireable<string>;
    };
    defaultProps: {
        filter: {};
        page: number;
        perPage: number;
        sort: {
            field: string;
            order: string;
        };
    };
};
interface ReferenceInputProps extends InputProps {
    children: ReactElement;
    label?: string;
    page?: number;
    perPage?: number;
    reference: string;
    referenceSource?: (resource: string, source: string) => string;
    resource?: string;
    enableGetChoices?: (filters: any) => boolean;
    [key: string]: any;
}

declare const sanitizeInputRestProps: ({ afterSubmit, allowNull, alwaysOn, beforeSubmit, component, data, defaultValue, error, format, formatOnBlur, formClassName, initialValue, initializeForm, input, isEqual, isRequired, label, limitChoicesToValue, locale, meta, multiple, name, options, optionText, optionValue, parse, record, ref, refetch, render, resource, setFilter, setPagination, setSort, source, submitError, subscription, textAlign, translate, translateChoice, validate, validateFields, value, ...rest }: any) => any;

declare const SearchInput: (props: SearchInputProps) => JSX.Element;
declare type SearchInputProps = CommonInputProps & TextInputProps;

/**
 * An Input component for a select box allowing multiple selections, using an array of objects for the options
 *
 * Pass possible options as an array of objects in the 'choices' attribute.
 *
 * By default, the options are built from:
 *  - the 'id' property as the option value,
 *  - the 'name' property as the option text
 * @example
 * const choices = [
 *    { id: 'programming', name: 'Programming' },
 *    { id: 'lifestyle', name: 'Lifestyle' },
 *    { id: 'photography', name: 'Photography' },
 * ];
 * <SelectArrayInput source="tags" choices={choices} />
 *
 * You can also customize the properties to use for the option name and value,
 * thanks to the 'optionText' and 'optionValue' attributes.
 * @example
 * const choices = [
 *    { _id: 123, full_name: 'Leo Tolstoi', sex: 'M' },
 *    { _id: 456, full_name: 'Jane Austen', sex: 'F' },
 * ];
 * <SelectArrayInput source="authors" choices={choices} optionText="full_name" optionValue="_id" />
 *
 * `optionText` also accepts a function, so you can shape the option text at will:
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;
 * <SelectArrayInput source="authors" choices={choices} optionText={optionRenderer} />
 *
 * `optionText` also accepts a React Element, that can access
 * the related choice through the `useRecordContext` hook. You can use Field components there.
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const FullNameField = ({ record }) => <span>{record.first_name} {record.last_name}</span>;
 * <SelectArrayInput source="authors" choices={choices} optionText={<FullNameField />}/>
 *
 * The choices are translated by default, so you can use translation identifiers as choices:
 * @example
 * const choices = [
 *    { id: 'programming', name: 'myroot.tags.programming' },
 *    { id: 'lifestyle', name: 'myroot.tags.lifestyle' },
 *    { id: 'photography', name: 'myroot.tags.photography' },
 * ];
 */
declare const SelectArrayInput: {
    (props: SelectArrayInputProps): JSX.Element;
    propTypes: {
        choices: PropTypes__default.Requireable<object[]>;
        className: PropTypes__default.Requireable<string>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        label: PropTypes__default.Requireable<string | boolean>;
        options: PropTypes__default.Requireable<object>;
        optionText: PropTypes__default.Validator<string | PropTypes__default.ReactElementLike | ((...args: any[]) => any)>;
        optionValue: PropTypes__default.Validator<string>;
        disableValue: PropTypes__default.Requireable<string>;
        resource: PropTypes__default.Requireable<string>;
        source: PropTypes__default.Requireable<string>;
        translateChoice: PropTypes__default.Requireable<boolean>;
    };
    defaultProps: {
        options: {};
        optionText: string;
        optionValue: string;
        disableValue: string;
        translateChoice: boolean;
    };
};
declare type SelectArrayInputProps = ChoicesProps & Omit<SupportCreateSuggestionOptions, 'handleChange'> & Omit<CommonInputProps, 'source'> & Omit<FormControlProps$1, 'defaultValue' | 'onBlur' | 'onChange'> & {
    disableValue?: string;
    source?: string;
    onChange?: (event: ChangeEvent<HTMLInputElement> | RaRecord) => void;
};
declare const SelectArrayInputClasses: {
    chips: string;
    chip: string;
};

/**
 * An Input component for a select box, using an array of objects for the options
 *
 * Pass possible options as an array of objects in the 'choices' attribute.
 *
 * By default, the options are built from:
 *  - the 'id' property as the option value,
 *  - the 'name' property as the option text
 * @example
 * const choices = [
 *    { id: 'M', name: 'Male' },
 *    { id: 'F', name: 'Female' },
 * ];
 * <SelectInput source="gender" choices={choices} />
 *
 * You can also customize the properties to use for the option name and value,
 * thanks to the 'optionText' and 'optionValue' attributes.
 * @example
 * const choices = [
 *    { _id: 123, full_name: 'Leo Tolstoi', sex: 'M' },
 *    { _id: 456, full_name: 'Jane Austen', sex: 'F' },
 * ];
 * <SelectInput source="author_id" choices={choices} optionText="full_name" optionValue="_id" />
 *
 * `optionText` also accepts a function, so you can shape the option text at will:
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;
 * <SelectInput source="author_id" choices={choices} optionText={optionRenderer} />
 *
 * `optionText` also accepts a React Element, that can access
 * the related choice through the `useRecordContext` hook. You can use Field components there.
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 * ];
 * const FullNameField = () => {
 *     const record = useRecordContext();
 *     return <span>{record.first_name} {record.last_name}</span>;
 * }
 * <SelectInput source="author" choices={choices} optionText={<FullNameField />}/>
 *
 * The choices are translated by default, so you can use translation identifiers as choices:
 * @example
 * const choices = [
 *    { id: 'M', name: 'myroot.gender.male' },
 *    { id: 'F', name: 'myroot.gender.female' },
 * ];
 *
 * However, in some cases (e.g. inside a `<ReferenceInput>`), you may not want
 * the choice to be translated. In that case, set the `translateChoice` prop to false.
 * @example
 * <SelectInput source="gender" choices={choices} translateChoice={false}/>
 *
 * The object passed as `options` props is passed to the MUI <Select> component
 *
 * You can disable some choices by providing a `disableValue` field which name is `disabled` by default
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 *    { id: 976, first_name: 'William', last_name: 'Rinkerd', disabled: true },
 * ];
 *
 * @example
 * const choices = [
 *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },
 *    { id: 456, first_name: 'Jane', last_name: 'Austen' },
 *    { id: 976, first_name: 'William', last_name: 'Rinkerd', not_available: true },
 * ];
 * <SelectInput source="gender" choices={choices} disableValue="not_available" />
 *
 */
declare const SelectInput: {
    (props: SelectInputProps): JSX.Element;
    propTypes: {
        emptyText: PropTypes__default.Requireable<string | PropTypes__default.ReactElementLike>;
        emptyValue: PropTypes__default.Requireable<any>;
        choices: PropTypes__default.Requireable<object[]>;
        className: PropTypes__default.Requireable<string>;
        label: PropTypes__default.Requireable<string | boolean>;
        options: PropTypes__default.Requireable<object>;
        optionText: PropTypes__default.Validator<string | PropTypes__default.ReactElementLike | ((...args: any[]) => any)>;
        optionValue: PropTypes__default.Validator<string>;
        disableValue: PropTypes__default.Requireable<string>;
        resettable: PropTypes__default.Requireable<boolean>;
        resource: PropTypes__default.Requireable<string>;
        source: PropTypes__default.Requireable<string>;
        translateChoice: PropTypes__default.Requireable<boolean>;
    };
    defaultProps: {
        emptyText: string;
        emptyValue: string;
        options: {};
        optionText: string;
        optionValue: string;
        translateChoice: boolean;
        disableValue: string;
    };
};
declare type SelectInputProps = Omit<CommonInputProps, 'source'> & ChoicesProps & Omit<SupportCreateSuggestionOptions, 'handleChange'> & Omit<TextFieldProps$2, 'label' | 'helperText' | 'classes' | 'onChange'> & {
    disableValue?: string;
    emptyText?: string | ReactElement;
    emptyValue?: any;
    source?: string;
    onChange?: (event: ChangeEvent<HTMLInputElement> | RaRecord) => void;
};

/**
 * Provides a way to edit multiple languages for any input passed as children.
 * It expects the translatable values to have the following structure:
 * {
 *     name: {
 *         en: 'The english value',
 *         fr: 'The french value',
 *         tlh: 'The klingon value',
 *     },
 *     description: {
 *         en: 'The english value',
 *         fr: 'The french value',
 *         tlh: 'The klingon value',
 *     }
 * }
 *
 * @example <caption>Basic usage</caption>
 * <TranslatableInputs locales={['en', 'fr']}>
 *     <TextInput source="title" />
 *     <RichTextInput source="description" />
 * </Translatable>
 *
 * @example <caption>With a custom language selector</caption>
 * <TranslatableInputs
 *     selector={<MyLanguageSelector />}
 *     locales={['en', 'fr']}
 * >
 *     <TextInput source="title" />
 * </Translatable>
 *
 * const MyLanguageSelector = () => {
 *     const {
 *         locales,
 *         selectedLocale,
 *         selectLocale,
 *     } = useTranslatableContext();
 *
 *     return (
 *         <select onChange={event => selectLocale(event.target.value)}>
 *             {locales.map((locale) => (
 *                 <option selected={locale === selectedLocale}>
 *                     {locale}
 *                 </option>
 *             ))}
 *        </select>
 *     );
 * }
 *
 * @param props The component props
 * @param {string} props.defaultLocale The locale selected by default. Default to 'en'.
 * @param {string[]} props.locales An array of the possible locales. For example: `['en', 'fr'].
 * @param {ReactElement} props.selector The element responsible for selecting a locale. Defaults to MUI tabs.
 */
declare const TranslatableInputs: (props: TranslatableInputsProps) => ReactElement;
interface TranslatableInputsProps extends UseTranslatableOptions {
    className?: string;
    selector?: ReactElement;
    children: ReactNode;
    groupKey?: string;
    margin?: 'none' | 'normal' | 'dense';
    variant?: 'standard' | 'outlined' | 'filled';
}

/**
 * Default container for a group of translatable inputs inside a TranslatableInputs component.
 * @see TranslatableInputs
 */
declare const TranslatableInputsTabContent: (props: TranslatableInputsTabContentProps) => ReactElement;
declare type TranslatableInputsTabContentProps<RecordType extends RaRecord | Omit<RaRecord, 'id'> = any> = {
    children: ReactNode;
    groupKey?: string;
    locale: string;
    record?: RecordType;
    resource?: string;
    margin?: 'none' | 'normal' | 'dense';
    variant?: 'standard' | 'outlined' | 'filled';
};
declare const TranslatableInputsTabContentClasses: {
    root: string;
};

/**
 * The AppBar component renders a custom MuiAppBar.
 *
 * @param {Object} props
 * @param {ReactNode} props.children React node/s to be rendered as children of the AppBar
 * @param {string} props.className CSS class applied to the MuiAppBar component
 * @param {string} props.color The color of the AppBar
 * @param {boolean} props.open State of the <Admin/> Sidebar
 * @param {Element | boolean} props.userMenu A custom user menu component for the AppBar. <UserMenu/> component by default. Pass false to disable.
 *
 * @example
 *
 * const MyAppBar = props => {

 *   return (
 *       <AppBar {...props}>
 *           <Typography
 *               variant="h6"
 *               color="inherit"
 *               className={classes.title}
 *               id="react-admin-title"
 *           />
 *       </AppBar>
 *   );
 *};
 *
 * @example Without a user menu
 *
 * const MyAppBar = props => {

 *   return (
 *       <AppBar {...props} userMenu={false} />
 *   );
 *};
 */
declare const AppBar: FC<AppBarProps>;
interface AppBarProps extends Omit<AppBarProps$1, 'title'> {
    container?: React.ElementType<any>;
    open?: boolean;
    title?: string | JSX.Element;
    userMenu?: JSX.Element | boolean;
}
declare const AppBarClasses: {
    appBar: string;
    toolbar: string;
    menuButton: string;
    menuButtonIconClosed: string;
    menuButtonIconOpen: string;
    title: string;
};

/**
 * Overrides MUI CardContent to allow inner content
 *
 * When using several CardContent inside the same Card, the top and bottom
 * padding double the spacing between each CardContent, leading to too much
 * wasted space. Use this component as a CardContent alternative.
 */
declare const CardContentInner: {
    (props: CardContentInnerProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        classes: PropTypes__default.Requireable<object>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
    };
};
interface CardContentInnerProps {
    className?: string;
    children: ReactNode;
}
declare const CardContentInnerClasses: {
    root: string;
};

/**
 * Confirmation dialog
 *
 * @example
 * <Confirm
 *     isOpen={true}
 *     title="Delete Item"
 *     content="Are you sure you want to delete this item?"
 *     confirm="Yes"
 *     confirmColor="primary"
 *     ConfirmIcon=ActionCheck
 *     CancelIcon=AlertError
 *     cancel="Cancel"
 *     onConfirm={() => { // do something }}
 *     onClose={() => { // do something }}
 * />
 */
declare const Confirm: {
    (props: ConfirmProps): JSX.Element;
    propTypes: {
        cancel: PropTypes__default.Requireable<string>;
        className: PropTypes__default.Requireable<string>;
        confirm: PropTypes__default.Requireable<string>;
        confirmColor: PropTypes__default.Requireable<string>;
        ConfirmIcon: PropTypes__default.Requireable<PropTypes__default.ReactComponentLike>;
        CancelIcon: PropTypes__default.Requireable<PropTypes__default.ReactComponentLike>;
        content: PropTypes__default.Validator<PropTypes__default.ReactNodeLike>;
        isOpen: PropTypes__default.Requireable<boolean>;
        loading: PropTypes__default.Requireable<boolean>;
        onClose: PropTypes__default.Validator<(...args: any[]) => any>;
        onConfirm: PropTypes__default.Validator<(...args: any[]) => any>;
        title: PropTypes__default.Validator<string>;
        sx: PropTypes__default.Requireable<any>;
    };
};
interface ConfirmProps {
    cancel?: string;
    className?: string;
    confirm?: string;
    confirmColor?: string;
    ConfirmIcon?: ReactComponentLike;
    CancelIcon?: ReactComponentLike;
    content: React.ReactNode;
    isOpen?: boolean;
    loading?: boolean;
    onClose: MouseEventHandler;
    onConfirm: MouseEventHandler;
    title: string;
    translateOptions?: object;
    sx?: SxProps$1;
}
declare const ConfirmClasses: {
    confirmPrimary: string;
    confirmWarning: string;
    iconPaddingStyle: string;
};

declare const DashboardMenuItem: {
    (props: DashboardMenuItemProps): JSX.Element;
    propTypes: {
        leftIcon: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        locale: PropTypes__default.Requireable<string>;
        onClick: PropTypes__default.Requireable<(...args: any[]) => any>;
        dense: PropTypes__default.Requireable<boolean>;
        sidebarIsOpen: PropTypes__default.Requireable<boolean>;
    };
};
interface DashboardMenuItemProps {
    leftIcon?: ReactElement;
    locale?: string;
    onClick?: () => void;
    dense?: boolean;
    /**
     * @deprecated
     */
    sidebarIsOpen?: boolean;
}

/**
 * Test utility to simulate a device form factor for server-side mediaQueries
 *
 * Do not use inside a browser.
 *
 * @example
 *
 * <DeviceTestWrapper width="sm">
 *     <MyResponsiveComponent />
 * <DeviceTestWrapper>
 */
declare const DeviceTestWrapper: ({ width, children, }: DeviceTestWrapperProps) => JSX.Element;
interface DeviceTestWrapperProps {
    width: 'md' | 'xs' | 'sm' | 'lg' | 'xl';
    children: JSX.Element;
}

declare const Error$1: {
    (props: InternalErrorProps & {
        errorComponent?: ComponentType<ErrorProps>;
    }): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        error: PropTypes__default.Validator<object>;
        errorInfo: PropTypes__default.Requireable<object>;
        title: PropTypes__default.Requireable<string | PropTypes__default.ReactElementLike>;
    };
};
interface InternalErrorProps extends Omit<HtmlHTMLAttributes<HTMLDivElement>, 'title'>, FallbackProps, ErrorProps {
    className?: string;
}
interface ErrorProps extends Pick<FallbackProps, 'error'> {
    errorInfo?: ErrorInfo;
    title?: TitleComponent;
}
declare const ErrorClasses: {
    container: string;
    title: string;
    icon: string;
    panel: string;
    panelSumary: string;
    panelDetails: string;
    toolbar: string;
    advice: string;
};

declare const HideOnScroll: {
    (props: HideOnScrollProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Validator<PropTypes__default.ReactNodeLike>;
    };
};
interface HideOnScrollProps {
    children: React.ReactElement;
}

declare const Menu: {
    (props: MenuProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        dense: PropTypes__default.Requireable<boolean>;
        hasDashboard: PropTypes__default.Requireable<boolean>;
    };
};
interface MenuProps {
    children?: ReactNode;
    className?: string;
    dense?: boolean;
    hasDashboard?: boolean;
}
declare const MenuClasses: {
    open: string;
    closed: string;
};

declare const Layout: (props: LayoutProps) => JSX.Element;
interface LayoutProps extends CoreLayoutProps, Omit<HtmlHTMLAttributes<HTMLDivElement>, 'title'> {
    appBar?: ComponentType<AppBarProps>;
    className?: string;
    error?: ComponentType<ErrorProps>;
    menu?: ComponentType<MenuProps>;
    sidebar?: ComponentType<{
        children: ReactNode;
    }>;
}
interface LayoutState {
    hasError: boolean;
    error?: Error;
    errorInfo?: ErrorInfo;
}
declare const LayoutClasses: {
    appFrame: string;
    contentWithSidebar: string;
    content: string;
};

/**
 * Progress bar formatted to replace an input or a field in a form layout
 *
 * Avoids visual jumps when replaced by value or form input
 *
 * @see ReferenceField
 * @see ReferenceInput
 *
 * @typedef {Object} Props the props you can use
 * @prop {Object} classes CSS class names
 * @prop {string} className CSS class applied to the LinearProgress component
 * @prop {integer} timeout Milliseconds to wait before showing the progress bar. One second by default
 *
 * @param {Props} props
 */
declare const LinearProgress: {
    ({ timeout, ...props }: LinearProgressProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        timeout: PropTypes__default.Requireable<number>;
    };
    displayName: string;
};
interface LinearProgressProps extends LinearProgressProps$1 {
    timeout?: number;
}

declare const Loading: {
    (props: any): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        loadingPrimary: PropTypes__default.Requireable<string>;
        loadingSecondary: PropTypes__default.Requireable<string>;
    };
    defaultProps: {
        loadingPrimary: string;
        loadingSecondary: string;
    };
};
declare const LoadingClasses: {
    root: string;
    icon: string;
    message: string;
};

declare const LoadingIndicator: {
    (props: LoadingIndicatorProps): JSX.Element;
    propTypes: {
        classes: PropTypes__default.Requireable<object>;
        className: PropTypes__default.Requireable<string>;
        width: PropTypes__default.Requireable<string>;
    };
};
interface LoadingIndicatorProps {
    className?: string;
    sx?: SxProps$1;
}
declare const LoadingIndicatorClasses: {
    loader: string;
    loadedIcon: string;
};

declare const LoadingPage: {
    ({ loadingPrimary, loadingSecondary, ...props }: {
        [x: string]: any;
        loadingPrimary?: string;
        loadingSecondary?: string;
    }): JSX.Element;
    propTypes: {
        theme: PropTypes__default.Requireable<object>;
        className: PropTypes__default.Requireable<string>;
        loadingPrimary: PropTypes__default.Requireable<string>;
        loadingSecondary: PropTypes__default.Requireable<string>;
    };
};

/**
 * Displays a menu item with a label and an icon - or only the icon with a tooltip when the sidebar is minimized.
 * It also handles the automatic closing of the menu on tap on mobile.
 *
 * @typedef {Object} Props the props you can use
 * @prop {string|Location} to The menu item's target. It is passed to a React Router NavLink component.
 * @prop {string|ReactNode} primaryText The menu content, displayed when the menu isn't minimized. |
 * @prop {ReactNode} leftIcon The menu icon
 *
 * Additional props are passed down to the underling MUI <MenuItem> component
 * @see https://material-ui.com/api/menu-item/#menuitem-api
 *
 * @example // You can create a custom menu component using the <DashboardMenuItem> and <MenuItemLink> components:
 *
 * // in src/Menu.js
 * import * as React from 'react';
 * import { DashboardMenuItem, MenuItemLink } from 'react-admin';
 * import BookIcon from '@mui/icons-material/Book';
 * import ChatBubbleIcon from '@mui/icons-material/ChatBubble';
 * import PeopleIcon from '@mui/icons-material/People';
 * import LabelIcon from '@mui/icons-material/Label';
 *
 * export const Menu = () => (
 *     <div>
 *         <DashboardMenuItem />
 *         <MenuItemLink to="/posts" primaryText="Posts" leftIcon={<BookIcon />}/>
 *         <MenuItemLink to="/comments" primaryText="Comments" leftIcon={<ChatBubbleIcon />}/>
 *         <MenuItemLink to="/users" primaryText="Users" leftIcon={<PeopleIcon />}/>
 *         <MenuItemLink to="/custom-route" primaryText="Miscellaneous" leftIcon={<LabelIcon />}/>
 *     </div>
 * );
 *
 * // to use this custom menu component, pass it to a custom Layout:
 * // in src/Layout.js
 * import { Layout } from 'react-admin';
 * import { Menu } from './Menu';
 *
 * export const Layout = (props) => <Layout {...props} menu={Menu} />;
 *
 * // then, use this layout in the <Admin layout> prop:
 * // in src/App.js
 * import { Layout }  from './Layout';
 *
 * const App = () => (
 *     <Admin layout={Layout} dataProvider={simpleRestProvider('http://path.to.my.api')}>
 *         // ...
 *     </Admin>
 * );
 */
declare const MenuItemLink: React__default.ForwardRefExoticComponent<Pick<Props$1 & LinkProps$2 & {
    autoFocus?: boolean;
    classes?: Partial<_mui_material.MenuItemClasses>;
    dense?: boolean;
    disabled?: boolean;
    disableGutters?: boolean;
    divider?: boolean;
    selected?: boolean;
    sx?: _mui_material.SxProps<Theme>;
} & Omit<{
    action?: React__default.Ref<_mui_material.ButtonBaseActions>;
    centerRipple?: boolean;
    children?: React__default.ReactNode;
    classes?: Partial<_mui_material.ButtonBaseClasses>;
    disabled?: boolean;
    disableRipple?: boolean;
    disableTouchRipple?: boolean;
    focusRipple?: boolean;
    focusVisibleClassName?: string;
    LinkComponent?: React__default.ElementType<any>;
    onFocusVisible?: React__default.FocusEventHandler<any>;
    sx?: _mui_material.SxProps<Theme>;
    tabIndex?: number;
    TouchRippleProps?: Partial<_mui_material_ButtonBase_TouchRipple.TouchRippleProps>;
}, "classes"> & _mui_material_OverridableComponent.CommonProps & Omit<Pick<React__default.DetailedHTMLProps<React__default.LiHTMLAttributes<HTMLLIElement>, HTMLLIElement>, "key" | keyof React__default.LiHTMLAttributes<HTMLLIElement>> & {
    ref?: React__default.Ref<HTMLLIElement>;
}, keyof _mui_material_OverridableComponent.CommonProps | "tabIndex" | "children" | "action" | "centerRipple" | "disabled" | "disableRipple" | "disableTouchRipple" | "focusRipple" | "focusVisibleClassName" | "LinkComponent" | "onFocusVisible" | "sx" | "TouchRippleProps" | "autoFocus" | "dense" | "selected" | "disableGutters" | "divider">, "className" | "style" | "classes" | "slot" | "title" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "dir" | "draggable" | "hidden" | "id" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "translate" | "radioGroup" | "role" | "about" | "datatype" | "inlist" | "prefix" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "color" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "children" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "action" | "centerRipple" | "disabled" | "disableRipple" | "disableTouchRipple" | "focusRipple" | "focusVisibleClassName" | "LinkComponent" | "onFocusVisible" | "sx" | "TouchRippleProps" | "replace" | "key" | "download" | "hrefLang" | "media" | "ping" | "rel" | "target" | "type" | "referrerPolicy" | "autoFocus" | "value" | "dense" | "to" | "selected" | "state" | "disableGutters" | "divider" | "leftIcon" | "primaryText" | "sidebarIsOpen" | "tooltipProps" | "reloadDocument"> & React__default.RefAttributes<unknown>>;
interface Props$1 {
    leftIcon?: ReactElement;
    primaryText?: ReactNode;
    /**
     * @deprecated
     */
    sidebarIsOpen?: boolean;
    tooltipProps?: TooltipProps;
}
declare type MenuItemLinkProps = Props$1 & LinkProps$2 & MenuItemProps$1<'li'>;
declare const MenuItemLinkClasses: {
    active: string;
    icon: string;
};

declare const NotFound: {
    (props: any): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        title: PropTypes__default.Requireable<string>;
        location: PropTypes__default.Requireable<object>;
    };
};
declare const NotFoundClasses: {
    icon: string;
    message: string;
    toolbar: string;
};

/**
 * Provides a way to show a notification.
 * @see useNotify
 *
 * @example <caption>Basic usage</caption>
 * <Notification />
 *
 * @param props The component props
 * @param {string} props.type The notification type. Defaults to 'info'.
 * @param {number} props.autoHideDuration Duration in milliseconds to wait until hiding a given notification. Defaults to 4000.
 * @param {boolean} props.multiLine Set it to `true` if the notification message should be shown in more than one line.
 */
declare const Notification: {
    (props: NotificationProps): JSX.Element;
    propTypes: {
        type: PropTypes__default.Requireable<string>;
        autoHideDuration: PropTypes__default.Requireable<number>;
        multiLine: PropTypes__default.Requireable<boolean>;
    };
};
declare const NotificationClasses: {
    success: string;
    error: string;
    warning: string;
    undo: string;
    multiLine: string;
};
interface NotificationProps extends Omit<SnackbarProps, 'open'> {
    type?: string;
    autoHideDuration?: number;
    multiLine?: boolean;
}

declare const Sidebar: {
    (props: SidebarProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Validator<PropTypes__default.ReactNodeLike>;
    };
};
interface SidebarProps extends DrawerProps {
    children: ReactElement;
    closedSize?: number;
    size?: number;
}
declare const SidebarClasses: {
    docked: string;
    paper: string;
    paperAnchorLeft: string;
    paperAnchorRight: string;
    paperAnchorTop: string;
    paperAnchorBottom: string;
    paperAnchorDockedLeft: string;
    paperAnchorDockedTop: string;
    paperAnchorDockedRight: string;
    paperAnchorDockedBottom: string;
    modal: string;
    fixed: string;
};
declare const DRAWER_WIDTH = 240;
declare const CLOSED_DRAWER_WIDTH = 55;

/**
 * A button that toggles the sidebar. Used by default in the <AppBar>.
 * @param props The component props
 * @param {String} props.className An optional class name to apply to the button

 */
declare const SidebarToggleButton: (props: SidebarToggleButtonProps) => JSX.Element;
declare type SidebarToggleButtonProps = {
    className?: string;
};
declare const SidebarToggleButtonClasses: {
    menuButtonIconClosed: string;
    menuButtonIconOpen: string;
};

declare type ThemeSetter = (theme: ThemeOptions) => void;
declare const useTheme: (themeOverride?: ThemeOptions) => [ThemeOptions, ThemeSetter];

/**
 * This sets the MUI theme based on the store.
 *
 * @param props
 * @param props.children The children of the component.
 * @param props.theme The initial theme.
 */
declare const ThemeProvider: ({ children, theme: themeOverride, }: ThemeProviderProps) => JSX.Element;
interface ThemeProviderProps {
    children: ReactNode;
    theme: ThemeOptions;
}

declare const Title: {
    (props: TitleProps): React.ReactPortal;
    propTypes: {
        defaultTitle: PropTypes__default.Requireable<string>;
        className: PropTypes__default.Requireable<string>;
        record: PropTypes__default.Requireable<any>;
        title: PropTypes__default.Requireable<string | PropTypes__default.ReactElementLike>;
    };
};
declare const TitlePropType: PropTypes__default.Requireable<string | PropTypes__default.ReactElementLike>;
interface TitleProps {
    className?: string;
    defaultTitle?: string;
    record?: Partial<RaRecord>;
    title?: string | ReactElement;
}

declare const TopToolbar: {
    (props: ToolbarProps$2): JSX.Element;
    propTypes: {
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        className: PropTypes__default.Requireable<string>;
    };
};

/**
 * The UserMenu component renders a Mui Button that shows a Menu.
 * It accepts children that must be Mui MenuItem components.
 *
 * @example
 * import { Logout, UserMenu, useUserMenu } from 'react-admin';
 * import MenuItem from '@mui/material/MenuItem';
 * import ListItemIcon from '@mui/material/ListItemIcon';
 * import ListItemText from '@mui/material/ListItemText';
 * import SettingsIcon from '@mui/icons-material/Settings';

 * const ConfigurationMenu = React.forwardRef((props, ref) => {
 *     const { onClose } = useUserMenu();
 *     return (
 *         <MenuItem
 *             ref={ref}
 *             {...props}
 *             to="/configuration"
 *             onClick={onClose}
 *         >
 *             <ListItemIcon>
 *                 <SettingsIcon />
 *             </ListItemIcon>
 *             <ListItemText>Configuration</ListItemText>
 *         </MenuItem>
 *     );
 * });
 *
 * export const MyUserMenu = () => (
 *     <UserMenu>
 *         <ConfigurationMenu />
 *         <Logout />
 *     </UserMenu>
 * );
 * @param props
 * @param {ReactNode} props.children React node/s to be rendered as children of the UserMenu. Must be Mui MenuItem components
 * @param {string} props.className CSS class applied to the MuiAppBar component
 * @param {string} props.label The label of the UserMenu button. Accepts translation keys
 * @param {Element} props.icon The icon of the UserMenu button.
 *
 */
declare const UserMenu: {
    (props: UserMenuProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        classes: PropTypes__default.Requireable<object>;
        label: PropTypes__default.Requireable<string>;
        icon: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
    };
};
interface UserMenuProps {
    children?: ReactNode;
    className?: string;
    label?: string;
    icon?: ReactNode;
}
declare const UserMenuClasses: {
    userButton: string;
    avatar: string;
};

/**
 * This context provides access to a function for closing the user menu.
 *
 * @example
 * import { Logout, MenuItemLink, UserMenu, useUserMenu } from 'react-admin';
 *
 * const ConfigurationMenu = () => {
 *     const { onClose } = useUserMenu();
 *     return (
 *         <MenuItemLink
 *             to="/configuration"
 *             primaryText="pos.configuration"
 *             leftIcon={<SettingsIcon />}
 *             sidebarIsOpen
 *             onClick={onClose}
 *         />
 *     );
 * };
 *
 * export const MyUserMenu = () => (
 *     <UserMenu>
 *         <ConfigurationMenu />
 *         <Logout />
 *     </UserMenu>
 * );
 */
declare const UserMenuContext: React.Context<UserMenuContextValue>;
declare type UserMenuContextValue = {
    /**
     * Closes the user menu
     * @see UserMenu
     */
    onClose: () => void;
};

/**
 * A hook to use inside the component passed to FallbackComponent
 * of react-error-boundary. It resets the error boundary state whenever
 * the location changes
 * @param {Function} resetErrorBoundary
 */
declare const useResetErrorBoundaryOnLocationChange: (resetErrorBoundary: () => void) => void;

/**
 * A hook that returns the sidebar open state and a function to toggle it.
 *
 * @example
 * const ToggleSidebar = () => {
 *     const [open, setOpen] = useSidebarState();
 *     return (
 *         <Button onClick={() => setOpen(!open)}>
 *             {open ? 'Open' : 'Close'}
 *         </Button>
 *     );
 * };
 */
declare const useSidebarState: () => useSidebarStateResult;
declare type useSidebarStateResult = [boolean, (open: boolean) => void];

/**
 * A hook to retrieve the user menu context, which provides access to a function for closing the user menu.
 * @returns {UserMenuContextValue}
 *
 * @example
 * import { Logout, MenuItemLink, UserMenu, useUserMenu } from 'react-admin';
 *
 * const ConfigurationMenu = () => {
 *     const { onClose } = useUserMenu();
 *     return (
 *         <MenuItemLink
 *             to="/configuration"
 *             primaryText="pos.configuration"
 *             leftIcon={<SettingsIcon />}
 *             sidebarIsOpen
 *             onClick={onClose}
 *         />
 *     );
 * };
 *
 * export const MyUserMenu = () => (
 *     <UserMenu>
 *         <ConfigurationMenu />
 *         <Logout />
 *     </UserMenu>
 * );
 */
declare const useUserMenu: () => UserMenuContextValue;

/**
 * Default locale selector for the TranslatableInputs component. Generates a tab for each specified locale.
 * @see TranslatableInputs
 */
declare const TranslatableInputsTabs: (props: TranslatableInputsTabsProps & AppBarProps) => ReactElement;
interface TranslatableInputsTabsProps {
    groupKey?: string;
    TabsProps?: TabsProps$1;
}
declare const TranslatableInputsTabsClasses: {
    root: string;
    tabs: string;
};

/**
 * Single tab that selects a locale in a TranslatableInputs component.
 * @see TranslatableInputs
 */
declare const TranslatableInputsTab: (props: TranslatableInputsTabProps & TabProps$2) => JSX.Element;
interface TranslatableInputsTabProps {
    groupKey?: string;
    locale: string;
}
declare const TranslatableInputsTabClasses: {
    root: string;
    error: string;
};

declare const Link: {
    (props: LinkProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        to: PropTypes__default.Requireable<string | object>;
    };
};
declare const LinkClasses: {
    link: string;
};
interface LinkProps extends LinkProps$2 {
    className?: string;
}

declare const BulkActionsToolbar: {
    (props: BulkActionsToolbarProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        label: PropTypes__default.Requireable<string>;
    };
};
interface BulkActionsToolbarProps {
    children?: ReactNode;
    label?: string;
    selectedIds?: Identifier[];
    className?: string;
}
declare const BulkActionsToolbarClasses: {
    toolbar: string;
    topToolbar: string;
    buttons: string;
    collapsed: string;
    title: string;
    icon: string;
};

declare const Empty: (props: EmptyProps) => JSX.Element;
interface EmptyProps {
    resource?: string;
    hasCreate?: boolean;
    className?: string;
}
declare const EmptyClasses: {
    message: string;
    icon: string;
    toolbar: string;
};

/**
 * Filter button/form combo
 *
 * @example
 *
 * const PostFilter = (props) => (
 *     <Filter {...props}>
 *         <TextInput label="Search" source="q" alwaysOn />
 *         <TextInput label="Title" source="title" defaultValue="Hello, World!" />
 *     </Filter>
 * );
 *
 * export const PostList = (props) => (
 *     <List {...props} filters={<PostFilter />}>
 *         ...
 *     </List>
 * );
 *
 */
declare const Filter: {
    (props: FilterProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        classes: PropTypes__default.Requireable<object>;
        context: PropTypes__default.Requireable<string>;
    };
};
declare const FilterClasses: {
    button: string;
    form: string;
};
interface FilterProps {
    children: ReactNode;
    context?: 'form' | 'button';
    variant?: string;
}

declare const FilterButton: {
    (props: FilterButtonProps): JSX.Element;
    propTypes: {
        resource: PropTypes__default.Requireable<string>;
        filters: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike[]>;
        displayedFilters: PropTypes__default.Requireable<object>;
        filterValues: PropTypes__default.Requireable<object>;
        showFilter: PropTypes__default.Requireable<(...args: any[]) => any>;
        className: PropTypes__default.Requireable<string>;
    };
};
interface FilterButtonProps extends HtmlHTMLAttributes<HTMLDivElement> {
    className?: string;
    resource?: string;
    filterValues?: any;
    showFilter?: (filterName: string, defaultValue: any) => void;
    displayedFilters?: any;
    filters?: ReactNode[];
}

declare const FilterButtonMenuItem: React.ForwardRefExoticComponent<FilterButtonMenuItemProps & React.RefAttributes<any>>;
interface FilterButtonMenuItemProps {
    filter: JSX.Element;
    onShow: (params: {
        source: string;
        defaultValue: any;
    }) => void;
    resource: string;
    autoFocus?: boolean;
}

declare const FilterForm: (props: FilterFormProps) => JSX.Element;
declare type FilterFormProps = FilterFormBaseProps & {
    defaultValues?: FieldValues;
};
declare const FilterFormBase: {
    (props: FilterFormBaseProps): JSX.Element;
    propTypes: {
        resource: PropTypes__default.Requireable<string>;
        filters: PropTypes__default.Validator<PropTypes__default.ReactNodeLike[]>;
        displayedFilters: PropTypes__default.Requireable<object>;
        hideFilter: PropTypes__default.Requireable<(...args: any[]) => any>;
        initialValues: PropTypes__default.Requireable<object>;
        className: PropTypes__default.Requireable<string>;
    };
};
declare type FilterFormBaseProps = Omit<HtmlHTMLAttributes<HTMLFormElement>, 'children'> & Partial<ListFilterContextValue> & {
    className?: string;
    resource?: string;
    filters?: ReactNode[];
};
declare const mergeInitialValuesWithDefaultValues: (initialValues: any, filters: any) => any;
declare const FilterFormClasses: {
    clearFix: string;
};
/**
 * Because we are using controlled inputs with react-hook-form, we must provide a default value
 * for each input when resetting the form. (see https://react-hook-form.com/api/useform/reset).
 * To ensure we don't provide undefined which will result to the current input value being reapplied
 * and due to the dynamic nature of the filter form, we rebuild the filter form values from its current
 * values and make sure to pass at least an empty string for each input.
 */
declare const getFilterFormValues: (formValues: Record<string, any>, filterValues: Record<string, any>) => Record<string, any>;

declare const FilterFormInput: {
    (props: any): JSX.Element;
    propTypes: {
        filterElement: PropTypes__default.Requireable<PropTypes__default.ReactNodeLike>;
        handleHide: PropTypes__default.Requireable<(...args: any[]) => any>;
        resource: PropTypes__default.Requireable<string>;
    };
};
declare const FilterFormInputClasses: {
    spacer: string;
    hideButton: string;
};

/**
 * Header and container for a list of filter list items
 *
 * Expects 2 props, and a list of <FilterListItem> as children:
 *
 * - label: The label for this filter section. Will be translated.
 * - icon: An icon react element
 *
 * @see FilterListItem
 *
 * @example
 *
 * import * as React from 'react';
 * import { Card, CardContent } from '@mui/material';
 * import MailIcon from '@mui/icons-material/MailOutline';
 * import { FilterList, FilterListItem } from 'react-admin';
 *
 * const FilterSidebar = () => (
 *     <Card>
 *         <CardContent>
 *             <FilterList
 *                 label="Subscribed to newsletter"
 *                 icon={<MailIcon />}
 *             >
 *                 <FilterListItem
 *                     label="Yes"
 *                     value={{ has_newsletter: true }}
 *                  />
 *                 <FilterListItem
 *                     label="No"
 *                     value={{ has_newsletter: false }}
 *                  />
 *             </FilterList>
 *         </CardContent>
 *     </Card>
 * );
 */
declare const FilterList: (props: FilterListProps) => JSX.Element;
interface FilterListProps extends BoxProps {
    label: string;
    icon: ReactNode;
}

/**
 * Button to enable/disable a list filter.
 *
 * Expects 2 props:
 *
 * - label: The text (or React element) to be displayed for this item.
 *   If it's a string, the component will translate it.
 * - value: An object to be merged into the filter value when enabling the filter
 *   (e.g. { is_published: true, published_at_gte: '2020-07-08' })
 *
 * @example
 *
 * import * as React from 'react';
 * import { Card, CardContent } from '@mui/material';
 * import MailIcon from '@mui/icons-material/MailOutline';
 * import { FilterList, FilterListItem } from 'react-admin';
 *
 * const FilterSidebar = () => (
 *     <Card>
 *         <CardContent>
 *             <FilterList
 *                 label="Subscribed to newsletter"
 *                 icon={<MailIcon />}
 *             >
 *                 <FilterListItem
 *                     label="Yes"
 *                     value={{ has_newsletter: true }}
 *                  />
 *                 <FilterListItem
 *                     label="No"
 *                     value={{ has_newsletter: false }}
 *                  />
 *             </FilterList>
 *         </CardContent>
 *     </Card>
 * );
 *
 * @example // The value prop can contain multiple keys
 *
 * import * as React from 'react';
 * import {
 *     endOfYesterday,
 *     startOfWeek,
 *     subWeeks,
 *     startOfMonth,
 *     subMonths,
 * } from 'date-fns';
 * import { Card, CardContent } from '@mui/material';
 * import AccessTimeIcon from '@mui/icons-material/AccessTime';
 * import { FilterList, FilterListItem } from 'react-admin';
 *
 * const FilterSidebar = () => (
 *     <Card>
 *         <CardContent>
 *             <FilterList
 *                 label="Last visited"
 *                 icon={<AccessTimeIcon />}
 *             >
 *                 <FilterListItem
 *                     label="Today"
 *                     value={{
 *                         last_seen_gte: endOfYesterday().toISOString(),
 *                         last_seen_lte: undefined,
 *                     }}
 *                 />
 *                 <FilterListItem
 *                     label="This week"
 *                     value={{
 *                         last_seen_gte: startOfWeek(
 *                             new Date()
 *                         ).toISOString(),
 *                         last_seen_lte: undefined,
 *                     }}
 *                 />
 *                 <FilterListItem
 *                     label="Last week"
 *                     value={{
 *                         last_seen_gte: subWeeks(
 *                             startOfWeek(new Date()),
 *                             1
 *                         ).toISOString(),
 *                         last_seen_lte: startOfWeek(
 *                             new Date()
 *                         ).toISOString(),
 *                     }}
 *                 />
 *                 <FilterListItem
 *                     label="This month"
 *                     value={{
 *                         last_seen_gte: startOfMonth(
 *                             new Date()
 *                         ).toISOString(),
 *                         last_seen_lte: undefined,
 *                     }}
 *                 />
 *                 <FilterListItem
 *                     label="Last month"
 *                     value={{
 *                         last_seen_gte: subMonths(
 *                             startOfMonth(new Date()),
 *                             1
 *                         ).toISOString(),
 *                         last_seen_lte: startOfMonth(
 *                             new Date()
 *                         ).toISOString(),
 *                     }}
 *                 />
 *                 <FilterListItem
 *                     label="Earlier"
 *                     value={{
 *                         last_seen_gte: undefined,
 *                         last_seen_lte: subMonths(
 *                             startOfMonth(new Date()),
 *                             1
 *                         ).toISOString(),
 *                     }}
 *                 />
 *             </FilterList>
 *         </CardContent>
 *     </Card>
 * );
 */
declare const FilterListItem: React.MemoExoticComponent<(props: FilterListItemProps) => JSX.Element>;
declare const FilterListItemClasses: {
    listItemButton: string;
    listItemText: string;
};
interface FilterListItemProps extends Omit<ListItemProps, 'value'> {
    label: string | ReactElement;
    value: any;
}

/**
 * Form and search input for doing a full-text search filter.
 *
 * Triggers a search on change (with debounce).
 *
 * @example
 *
 * const FilterPanel = () => (
 *     <Card>
 *         <CardContent>
 *             <FilterLiveSearch source="title" />
 *         </CardContent>
 *     </Card>
 * );
 */
declare const FilterLiveSearch: React.MemoExoticComponent<(props: {
    source?: string;
    sx?: SxProps$1;
    variant?: 'filled' | 'outlined';
}) => JSX.Element>;

declare const AddSavedQueryDialog: ({ open, onClose, }: AddSavedQueryDialogProps) => ReactElement;
interface AddSavedQueryDialogProps {
    open: boolean;
    onClose: () => void;
}

declare const AddSavedQueryIconButton: (props: IconButtonProps) => ReactElement;

interface RemoveSavedQueryDialogProps {
    open: boolean;
    onClose: () => void;
}
declare const RemoveSavedQueryDialog: ({ open, onClose, }: RemoveSavedQueryDialogProps) => ReactElement;

declare const RemoveSavedQueryIconButton: (props: IconButtonProps) => ReactElement;

/**
 * FilterList-like component allowing to save and restore a query (filters, sort, perPage).
 *
 * Use this component in a Filter sidebar to let users store custom queries
 * that they can reuse later. The saved queries will appear as FilterListItems,
 * and can be removed.
 *
 * This component uses useStore under the hood to store saved queries in
 * localStorage, one set of saved queries per resource.
 *
 * @example
 *
 * import { FilterList, FilterListItem, List, Datagrid, SavedQueriesList } from 'react-admin';
 * import { Card, CardContent } from '@mui/material';
 *
 * const PostFilterSidebar = () => (
 *     <Card>
 *         <CardContent>
 *             <SavedQueriesList />
 *             <FilterList label="Category" icon={<CategoryIcon />}>
 *                 ...
 *             </FilterList>
 *             <FilterList label="Published" icon={<DateRangeIcon />}>
 *                ...
 *             </FilterList>
 *             <FilterList label="Popularity" icon={<DateRangeIcon />}>
 *                ...
 *             </FilterList>
 *         </CardContent>
 *     </Card>
 * );
 *
 * const PostList = () => (
 *     <List aside={<PostFilterSidebar />}>
 *         <Datagrid>
 *             ...
 *         </Datagrid>
 *     </List>
 * );
 *
 */
declare const SavedQueriesList: ({ icon, }: SavedQueriesListProps) => JSX.Element;
declare const SavedQueriesListClasses: {
    floatingIcon: string;
    floatingTooltip: string;
    titleContainer: string;
    titleIcon: string;
};
interface SavedQueriesListProps {
    icon?: ReactNode;
}

declare const useSavedQueries: (resource: string) => ra_core.useStoreResult<SavedQuery[]>;
interface SavedQuery {
    label: string;
    value: {
        filter?: any;
        displayedFilters?: any[];
        sort?: SortPayload;
        perPage?: number;
    };
}
declare const extractValidSavedQueries: (savedQueries: SavedQuery[]) => SavedQuery[];
declare const areValidSavedQueries: (savedQueries: SavedQuery[]) => boolean;
declare const isValidSavedQuery: (savedQuery: SavedQuery) => boolean;

declare const SavedQueryFilterListItem: React.MemoExoticComponent<(props: SavedQueryFilterListItemProps) => ReactElement>;
declare const SavedQueryFilterListItemClasses: {
    listItemButton: string;
    listItemText: string;
};
interface SavedQueryFilterListItemProps extends SavedQuery, Omit<ListItemProps, 'value'> {
}

declare type FilterContextType = React.ReactNode[];
/**
 * Make filters accessible to sub components
 */
declare const FilterContext: React.Context<FilterContextType>;

declare const ListView: {
    <RecordType extends RaRecord = any>(props: ListViewProps): JSX.Element;
    propTypes: {
        actions: PropTypes__default.Requireable<boolean | PropTypes__default.ReactElementLike>;
        aside: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        children: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        className: PropTypes__default.Requireable<string>;
        component: (props: any, propName: any, componentName: any) => Error;
        sort: PropTypes__default.Requireable<PropTypes__default.InferProps<{
            field: PropTypes__default.Validator<string>;
            order: PropTypes__default.Validator<string>;
        }>>;
        data: PropTypes__default.Requireable<any>;
        defaultTitle: PropTypes__default.Requireable<string>;
        displayedFilters: PropTypes__default.Requireable<object>;
        emptyWhileLoading: PropTypes__default.Requireable<boolean>;
        exporter: PropTypes__default.Requireable<boolean | ((...args: any[]) => any)>;
        filterDefaultValues: PropTypes__default.Requireable<object>;
        filters: PropTypes__default.Requireable<PropTypes__default.ReactElementLike | PropTypes__default.ReactElementLike[]>;
        filterValues: PropTypes__default.Requireable<object>;
        hasCreate: PropTypes__default.Requireable<boolean>;
        hideFilter: PropTypes__default.Requireable<(...args: any[]) => any>;
        ids: PropTypes__default.Requireable<any[]>;
        loading: PropTypes__default.Requireable<boolean>;
        onSelect: PropTypes__default.Requireable<(...args: any[]) => any>;
        onToggleItem: PropTypes__default.Requireable<(...args: any[]) => any>;
        onUnselectItems: PropTypes__default.Requireable<(...args: any[]) => any>;
        page: PropTypes__default.Requireable<number>;
        pagination: PropTypes__default.Requireable<boolean | PropTypes__default.ReactElementLike>;
        perPage: PropTypes__default.Requireable<number>;
        refresh: PropTypes__default.Requireable<(...args: any[]) => any>;
        resource: PropTypes__default.Requireable<string>;
        selectedIds: PropTypes__default.Requireable<any[]>;
        setFilters: PropTypes__default.Requireable<(...args: any[]) => any>;
        setPage: PropTypes__default.Requireable<(...args: any[]) => any>;
        setPerPage: PropTypes__default.Requireable<(...args: any[]) => any>;
        setSort: PropTypes__default.Requireable<(...args: any[]) => any>;
        showFilter: PropTypes__default.Requireable<(...args: any[]) => any>;
        title: PropTypes__default.Requireable<string | PropTypes__default.ReactElementLike>;
        total: PropTypes__default.Requireable<number>;
    };
};
interface ListViewProps {
    actions?: ReactElement | false;
    aside?: ReactElement;
    /**
     * @deprecated pass the bulkActionButtons prop to the List child (Datagrid or SimpleList) instead
     */
    bulkActionButtons?: ReactElement | false;
    className?: string;
    children: ReactElement;
    component?: ElementType;
    empty?: ReactElement | false;
    emptyWhileLoading?: boolean;
    filters?: ReactElement | ReactElement[];
    hasCreate?: boolean;
    pagination?: ReactElement | false;
    title?: string | ReactElement;
    sx?: SxProps$1;
}
declare const ListClasses: {
    main: string;
    content: string;
    actions: string;
    noResults: string;
};

/**
 * List page component
 *
 * The <List> component renders the list layout (title, buttons, filters, pagination),
 * and fetches the list of records from the REST API.
 *
 * It then delegates the rendering of the list of records to its child component.
 * Usually, it's a <Datagrid>, responsible for displaying a table with one row for each post.
 *
 * The <List> component accepts the following props:
 *
 * - actions
 * - aside: Side Component
 * - children: List Layout
 * - component
 * - disableAuthentication
 * - disableSyncWithLocation
 * - empty: Empty Page Component
 * - emptyWhileLoading
 * - exporter
 * - filters: Filter Inputs
 * - filter: Permanent Filter
 * - filterDefaultValues
 * - pagination: Pagination Component
 * - perPage: Pagination Size
 * - queryOptions
 * - sort: Default Sort Field & Order
 * - title
 * - sx: CSS API
 *
 * @example
 * const postFilters = [
 *     <TextInput label="Search" source="q" alwaysOn />,
 *     <TextInput label="Title" source="title" />
 * ];
 * export const PostList = (props) => (
 *     <List {...props}
 *         title="List of posts"
 *         sort={{ field: 'published_at' }}
 *         filter={{ is_published: true }}
 *         filters={postFilters}
 *     >
 *         <Datagrid>
 *             <TextField source="id" />
 *             <TextField source="title" />
 *             <EditButton />
 *         </Datagrid>
 *     </List>
 * );
 */
declare const List: {
    <RecordType extends RaRecord = any>({ debounce, disableAuthentication, disableSyncWithLocation, exporter, filter, filterDefaultValues, perPage, queryOptions, resource, sort, ...rest }: ListProps<RecordType>): ReactElement;
    propTypes: {
        actions: PropTypes__default.Requireable<boolean | PropTypes__default.ReactElementLike>;
        aside: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        children: PropTypes__default.Validator<PropTypes__default.ReactElementLike>;
        className: PropTypes__default.Requireable<string>;
        emptyWhileLoading: PropTypes__default.Requireable<boolean>;
        filter: PropTypes__default.Requireable<object>;
        filterDefaultValues: PropTypes__default.Requireable<object>;
        filters: PropTypes__default.Requireable<PropTypes__default.ReactElementLike | PropTypes__default.ReactElementLike[]>;
        pagination: PropTypes__default.Requireable<boolean | PropTypes__default.ReactElementLike>;
        perPage: PropTypes__default.Validator<number>;
        sort: PropTypes__default.Requireable<PropTypes__default.InferProps<{
            field: PropTypes__default.Requireable<string>;
            order: PropTypes__default.Requireable<string>;
        }>>;
        sx: PropTypes__default.Requireable<any>;
        title: PropTypes__default.Requireable<string | PropTypes__default.ReactElementLike>;
        disableSyncWithLocation: PropTypes__default.Requireable<boolean>;
        hasCreate: PropTypes__default.Requireable<boolean>;
        hasEdit: PropTypes__default.Requireable<boolean>;
        hasList: PropTypes__default.Requireable<boolean>;
        hasShow: PropTypes__default.Requireable<boolean>;
        resource: PropTypes__default.Requireable<string>;
    };
    defaultProps: {
        filter: {};
        perPage: number;
    };
};
interface ListProps<RecordType extends RaRecord = any> extends ListControllerProps<RecordType>, ListViewProps {
}

/**
 * Action Toolbar for the List view
 *
 * Internal component. If you want to add or remove actions for a List view,
 * write your own ListActions Component. Then, in the <List> component,
 * use it in the `actions` prop to pass a custom component.
 *
 * @example
 *     import { cloneElement } from 'react';
 *     import Button from '@mui/material/Button';
 *     import { TopToolbar, List, CreateButton, ExportButton } from 'react-admin';
 *
 *     const PostListActions = ({ filters }) => (
 *         <TopToolbar>
 *             { cloneElement(filters, { context: 'button' }) }
 *             <CreateButton/>
 *             <ExportButton/>
 *             // Add your custom actions here //
 *             <Button onClick={customAction}>Custom Action</Button>
 *         </TopToolbar>
 *     );
 *
 *     export const PostList = (props) => (
 *         <List actions={<PostListActions />} {...props}>
 *             ...
 *         </List>
 *     );
 */
declare const ListActions: {
    (props: ListActionsProps): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        sort: PropTypes__default.Requireable<any>;
        displayedFilters: PropTypes__default.Requireable<object>;
        exporter: PropTypes__default.Requireable<boolean | ((...args: any[]) => any)>;
        filters: PropTypes__default.Requireable<PropTypes__default.ReactElementLike>;
        filterValues: PropTypes__default.Requireable<object>;
        hasCreate: PropTypes__default.Requireable<boolean>;
        resource: PropTypes__default.Requireable<string>;
        onUnselectItems: PropTypes__default.Validator<(...args: any[]) => any>;
        selectedIds: PropTypes__default.Requireable<any[]>;
        showFilter: PropTypes__default.Requireable<(...args: any[]) => any>;
        total: PropTypes__default.Requireable<number>;
    };
    defaultProps: {
        selectedIds: any[];
        onUnselectItems: () => any;
    };
};
interface ListActionsProps extends ToolbarProps$1 {
    sort?: SortPayload;
    className?: string;
    resource?: string;
    filters?: ReactElement<any>;
    displayedFilters?: any;
    exporter?: Exporter | boolean;
    filterValues?: any;
    permanentFilter?: any;
    hasCreate?: boolean;
    selectedIds?: Identifier[];
    onUnselectItems?: () => void;
    showFilter?: (filterName: string, defaultValue: any) => void;
    total?: number;
}

/**
 * List component rendering a <Datagrid> based on the result of the
 * dataProvider.getList() call.
 *
 * The result (choice and type of columns) isn't configurable, but the
 * <ListGuesser> outputs the <Datagrid> it has guessed to the console so that
 * developers can start from there.
 *
 * To be used as the list prop of a <Resource>.
 *
 * @example
 *
 * import { Admin, Resource, ListGuesser } from 'react-admin';
 *
 * const App = () => (
 *     <Admin dataProvider={myDataProvider}>
 *         <Resource name="posts" list={ListGuesser} />
 *     </Admin>
 * );
 */
declare const ListGuesser: <RecordType extends RaRecord = any>(props: Omit<ListProps, 'children'>) => JSX.Element;

declare const listFieldTypes: {
    table: {
        component: (props: any) => JSX.Element;
        representation: (_: any, children: any) => string;
    };
    array: {
        component: ({ children, ...props }: {
            [x: string]: any;
            children: any;
        }) => JSX.Element;
        representation: (props: any, children: any) => string;
    };
    boolean: {
        component: React.FunctionComponent<BooleanFieldProps>;
        representation: (props: any) => string;
    };
    date: {
        component: React.FC<DateFieldProps>;
        representation: (props: any) => string;
    };
    email: {
        component: React.FC<EmailFieldProps>;
        representation: (props: any) => string;
    };
    id: {
        component: React.FC<TextFieldProps>;
        representation: (props: any) => string;
    };
    number: {
        component: React.FC<NumberFieldProps>;
        representation: (props: any) => string;
    };
    reference: {
        component: React.FC<ReferenceFieldProps<any>>;
        representation: (props: any) => string;
    };
    referenceChild: {
        component: (props: any) => JSX.Element;
        representation: () => string;
    };
    referenceArray: {
        component: React.FC<ReferenceArrayFieldProps>;
        representation: (props: any) => string;
    };
    referenceArrayChild: {
        component: (props: any) => JSX.Element;
        representation: () => string;
    };
    richText: any;
    string: {
        component: React.FC<TextFieldProps>;
        representation: (props: any) => string;
    };
    url: {
        component: React.FC<UrlFieldProps>;
        representation: (props: any) => string;
    };
};

declare const ListToolbar: FC<ListToolbarProps>;
interface ListToolbarProps extends Omit<ToolbarProps$1, 'classes' | 'onSelect'> {
    actions?: ReactElement | false;
    exporter?: Exporter | false;
    filters?: ReactElement | ReactElement[];
    hasCreate?: boolean;
}

declare const Pagination: FC<PaginationProps>;
interface PaginationProps extends TablePaginationBaseProps {
    rowsPerPageOptions?: number[];
    actions?: FC;
    limit?: ReactElement;
}

declare const PaginationActions: FC<PaginationActionsProps>;
interface PaginationActionsProps extends PaginationProps$1 {
    page: number;
    rowsPerPage: number;
    count: number;
    onPageChange: (event: MouseEvent, page: number) => void;
}

declare const PaginationLimit: React.MemoExoticComponent<() => JSX.Element>;

interface PlaceholderProps {
    className?: string;
}
declare const Placeholder: (props: PlaceholderProps) => JSX.Element;

/**
 * The <SimpleList> component renders a list of records as a MUI <List>.
 * It is usually used as a child of react-admin's <List> and <ReferenceManyField> components.
 *
 * Also widely used on Mobile.
 *
 * Props:
 * - primaryText: function returning a React element (or some text) based on the record
 * - secondaryText: same
 * - tertiaryText: same
 * - leftAvatar: function returning a React element based on the record
 * - leftIcon: same
 * - rightAvatar: same
 * - rightIcon: same
 * - linkType: 'edit' or 'show', or a function returning 'edit' or 'show' based on the record
 * - rowStyle: function returning a style object based on (record, index)
 *
 * @example // Display all posts as a List
 * const postRowStyle = (record, index) => ({
 *     backgroundColor: record.views >= 500 ? '#efe' : 'white',
 * });
 * export const PostList = (props) => (
 *     <List {...props}>
 *         <SimpleList
 *             primaryText={record => record.title}
 *             secondaryText={record => `${record.views} views`}
 *             tertiaryText={record =>
 *                 new Date(record.published_at).toLocaleDateString()
 *             }
 *             rowStyle={postRowStyle}
 *          />
 *     </List>
 * );
 */
declare const SimpleList: {
    <RecordType extends RaRecord = any>(props: SimpleListProps<RecordType>): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        leftAvatar: PropTypes__default.Requireable<(...args: any[]) => any>;
        leftIcon: PropTypes__default.Requireable<(...args: any[]) => any>;
        linkType: PropTypes__default.Requireable<string | boolean | ((...args: any[]) => any)>;
        primaryText: PropTypes__default.Requireable<PropTypes__default.ReactElementLike | ((...args: any[]) => any)>;
        rightAvatar: PropTypes__default.Requireable<(...args: any[]) => any>;
        rightIcon: PropTypes__default.Requireable<(...args: any[]) => any>;
        secondaryText: PropTypes__default.Requireable<PropTypes__default.ReactElementLike | ((...args: any[]) => any)>;
        tertiaryText: PropTypes__default.Requireable<PropTypes__default.ReactElementLike | ((...args: any[]) => any)>;
        rowStyle: PropTypes__default.Requireable<(...args: any[]) => any>;
    };
};
declare type FunctionToElement<RecordType extends RaRecord = any> = (record: RecordType, id: Identifier) => ReactNode;
interface SimpleListProps<RecordType extends RaRecord = any> extends Omit<ListProps$1, 'classes'> {
    className?: string;
    hasBulkActions?: boolean;
    leftAvatar?: FunctionToElement<RecordType>;
    leftIcon?: FunctionToElement<RecordType>;
    primaryText?: FunctionToElement<RecordType> | ReactElement;
    linkType?: string | FunctionLinkType | false;
    rightAvatar?: FunctionToElement<RecordType>;
    rightIcon?: FunctionToElement<RecordType>;
    secondaryText?: FunctionToElement<RecordType> | ReactElement;
    tertiaryText?: FunctionToElement<RecordType> | ReactElement;
    rowStyle?: (record: RecordType, index: number) => any;
    resource?: string;
    data?: RecordType[];
    isLoading?: boolean;
    isLoaded?: boolean;
    total?: number;
}
declare type FunctionLinkType = (record: RaRecord, id: Identifier) => string;
interface LinkOrNotProps {
    linkType?: string | FunctionLinkType | false;
    resource: string;
    id: Identifier;
    record: RaRecord;
    children: ReactNode;
}
declare const SimpleListClasses: {
    tertiary: string;
};

declare const SimpleListLoading: {
    (props: Props & ListProps$2): JSX.Element;
    propTypes: {
        className: PropTypes__default.Requireable<string>;
        hasLeftAvatarOrIcon: PropTypes__default.Requireable<boolean>;
        hasRightAvatarOrIcon: PropTypes__default.Requireable<boolean>;
        hasSecondaryText: PropTypes__default.Requireable<boolean>;
        hasTertiaryText: PropTypes__default.Requireable<boolean>;
        nbFakeLines: PropTypes__default.Requireable<number>;
    };
};
declare const SimpleListLoadingClasses: {
    primary: string;
    tertiary: string;
};
interface Props {
    className?: string;
    hasLeftAvatarOrIcon?: boolean;
    hasRightAvatarOrIcon?: boolean;
    hasSecondaryText?: boolean;
    hasTertiaryText?: boolean;
    nbFakeLines?: number;
}

/**
 * Iterator component to be used to display a list of entities, using a single field
 *
 * @example Display all the books by the current author
 * <ReferenceManyField reference="books" target="author_id">
 *     <SingleFieldList>
 *         <ChipField source="title" />
 *     </SingleFieldList>
 * </ReferenceManyField>
 *
 * By default, it includes a link to the <Edit> page of the related record
 * (`/books/:id` in the previous example).
 *
 * Set the linkType prop to "show" to link to the <Show> page instead.
 *
 * @example
 * <ReferenceManyField reference="books" target="author_id" linkType="show">
 *     <SingleFieldList>
 *         <ChipField source="title" />
 *     </SingleFieldList>
 * </ReferenceManyField>
 *
 * You can also prevent `<SingleFieldList>` from adding link to children by setting
 * `linkType` to false.
 *
 * @example
 * <ReferenceManyField reference="books" target="author_id" linkType={false}>
 *     <SingleFieldList>
 *         <ChipField source="title" />
 *     </SingleFieldList>
 * </ReferenceManyField>
 */
declare const SingleFieldList: {
    (props: SingleFieldListProps): JSX.Element;
    propTypes: {
        children: PropTypes__default.Validator<PropTypes__default.ReactElementLike>;
        classes: PropTypes__default.Requireable<object>;
        className: PropTypes__default.Requireable<string>;
        component: (props: any, propName: any, componentName: any) => Error;
        data: PropTypes__default.Requireable<any>;
        ids: PropTypes__default.Requireable<any[]>;
        linkType: PropTypes__default.Requireable<string | boolean>;
        resource: PropTypes__default.Requireable<string>;
    };
};
interface SingleFieldListProps<RecordType extends RaRecord = any> extends HtmlHTMLAttributes<HTMLDivElement> {
    className?: string;
    component?: string | ComponentType<any>;
    linkType?: string | false;
    children: React.ReactElement;
    data?: RecordType[];
    total?: number;
    loaded?: boolean;
}
declare const SingleFieldListClasses: {
    link: string;
};

declare const AdminUI: {
    ({ notification, ...props }: AdminUIProps): JSX.Element;
    defaultProps: {
        layout: (props: LayoutProps) => JSX.Element;
        catchAll: {
            (props: any): JSX.Element;
            propTypes: {
                className: PropTypes.Requireable<string>;
                title: PropTypes.Requireable<string>;
                location: PropTypes.Requireable<object>;
            };
        };
        loading: {
            ({ loadingPrimary, loadingSecondary, ...props }: {
                [x: string]: any;
                loadingPrimary?: string;
                loadingSecondary?: string;
            }): JSX.Element;
            propTypes: {
                theme: PropTypes.Requireable<object>;
                className: PropTypes.Requireable<string>;
                loadingPrimary: PropTypes.Requireable<string>;
                loadingSecondary: PropTypes.Requireable<string>;
            };
        };
        loginPage: {
            (props: LoginProps): JSX.Element;
            propTypes: {
                backgroundImage: PropTypes.Requireable<string>;
                children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
                className: PropTypes.Requireable<string>;
            };
            defaultProps: {
                children: JSX.Element;
            };
        };
        notification: {
            (props: NotificationProps): JSX.Element;
            propTypes: {
                type: PropTypes.Requireable<string>;
                autoHideDuration: PropTypes.Requireable<number>;
                multiLine: PropTypes.Requireable<boolean>;
            };
        };
    };
};
interface AdminUIProps extends CoreAdminUIProps {
    notification?: ComponentType;
}

declare const AdminContext: {
    (props: CoreAdminContextProps): JSX.Element;
    displayName: string;
};

export { AddItemButton, AddSavedQueryDialog, AddSavedQueryDialogProps, AddSavedQueryIconButton, AdminContext, AdminUI, AdminUIProps, AppBar, AppBarClasses, AppBarProps, ArrayField, ArrayFieldProps, ArrayInput, ArrayInputContext, ArrayInputContextValue, ArrayInputProps, AutocompleteArrayInput, AutocompleteArrayInputProps, AutocompleteInput, AutocompleteInputClasses, AutocompleteInputProps, BooleanField, BooleanFieldProps, BooleanInput, BooleanInputProps, BulkActionProps, BulkActionsToolbar, BulkActionsToolbarClasses, BulkActionsToolbarProps, BulkDeleteButton, BulkDeleteButtonProps, BulkDeleteWithConfirmButton, BulkDeleteWithConfirmButtonProps, BulkDeleteWithUndoButton, BulkDeleteWithUndoButtonProps, BulkExportButton, BulkExportButtonProps, BulkUpdateButton, BulkUpdateButtonProps, BulkUpdateWithConfirmButton, BulkUpdateWithConfirmButtonProps, BulkUpdateWithUndoButton, BulkUpdateWithUndoButtonProps, Button, ButtonProps, CLOSED_DRAWER_WIDTH, CardContentInner, CardContentInnerClasses, CardContentInnerProps, CheckboxGroupInput, CheckboxGroupInputClasses, CheckboxGroupInputProps, ChipField, ChipFieldProps, _default$5 as CloneButton, CloneButtonProps, CommonInputProps, Confirm, ConfirmClasses, ConfirmProps, Create, CreateActions, CreateActionsProps, _default$4 as CreateButton, CreateButtonClasses, CreateButtonProps, CreateClasses, CreateProps, CreateView, DRAWER_WIDTH, DashboardMenuItem, DashboardMenuItemProps, Datagrid, DatagridBody, DatagridBodyProps, DatagridCell, DatagridCellProps, DatagridClasses, DatagridHeader, _default$2 as DatagridHeaderCell, DatagridHeaderCellClasses, DatagridHeaderCellProps, DatagridHeaderProps, DatagridInput, DatagridInputProps, _default$1 as DatagridLoading, DatagridLoadingProps, DatagridProps, DatagridRoot, DatagridRow, DatagridRowProps, DateField, DateFieldProps, DateInput, DateInputProps, DateTimeInput, DateTimeInputProps, DeleteButton, DeleteButtonProps, DeleteWithConfirmButton, DeleteWithConfirmButtonProps, DeleteWithUndoButton, DeleteWithUndoButtonProps, DeviceTestWrapper, DeviceTestWrapperProps, DisableRemoveFunction, Edit, EditActions, EditActionsProps, EditButton, EditButtonProps, EditClasses, EditGuesser, EditProps, EditView, EmailField, EmailFieldProps, Empty, EmptyClasses, EmptyProps, Error$1 as Error, ErrorClasses, ErrorProps, _default as ExpandRowButton, ExpandRowButtonProps, ExportButton, ExportButtonProps, FieldProps, FileField, FileFieldProps, FileInput, FileInputClasses, FileInputProps, Filter, FilterButton, FilterButtonMenuItem, FilterButtonMenuItemProps, FilterButtonProps, FilterClasses, FilterContext, FilterContextType, FilterForm, FilterFormBase, FilterFormBaseProps, FilterFormClasses, FilterFormInput, FilterFormInputClasses, FilterFormProps, FilterList, FilterListItem, FilterListItemClasses, FilterListItemProps, FilterListProps, FilterLiveSearch, FilterProps, FormTab, FormTabHeader, FormTabProps, FunctionField, FunctionFieldProps, FunctionLinkType, FunctionToElement, HideOnScroll, HideOnScrollProps, IconButtonWithTooltip, IconButtonWithTooltipProps, ImageField, ImageFieldClasses, ImageFieldProps, ImageInput, ImageInputProps, InjectedFieldProps, InputHelperText, InputHelperTextProps, InputPropTypes, Labeled, LabeledClasses, LabeledProps, Layout, LayoutClasses, LayoutProps, LayoutState, LinearProgress, LinearProgressProps, Link, LinkClasses, LinkOrNotProps, LinkProps, List, ListActions, ListActionsProps, ListButton, ListButtonProps, ListClasses, ListGuesser, ListProps, ListToolbar, ListToolbarProps, ListView, ListViewProps, Loading, LoadingClasses, LoadingIndicator, LoadingIndicatorClasses, LoadingPage, LocalesMenuButton, LocalesMenuButtonClasses, LocalesMenuButtonProps, LocationDescriptor, Login, LoginClasses, LoginForm, LoginFormClasses, LoginFormProps, LoginProps, Logout, LogoutClasses, LogoutProps, Menu, MenuClasses, MenuItemLink, MenuItemLinkClasses, MenuItemLinkProps, MenuProps, NonEmptyReferenceField, NotFound, NotFoundClasses, Notification, NotificationClasses, NotificationProps, NullableBooleanInput, NullableBooleanInputClasses, NullableBooleanInputProps, NumberField, NumberFieldProps, NumberInput, NumberInputProps, OnCreateHandler, Pagination, PaginationActions, PaginationActionsProps, PaginationLimit, PaginationProps, PasswordInput, PasswordInputProps, Placeholder, PublicFieldProps, PureDatagridBody, PureDatagridRow, RaThemeOptions, RadioButtonGroupInput, RadioButtonGroupInputClasses, RadioButtonGroupInputProps, ReOrderButtons, ReferenceArrayField, ReferenceArrayFieldClasses, ReferenceArrayFieldProps, ReferenceArrayFieldView, ReferenceArrayFieldViewProps, ReferenceArrayInput, ReferenceArrayInputProps, ReferenceField, ReferenceFieldClasses, ReferenceFieldProps, ReferenceFieldView, ReferenceFieldViewProps, ReferenceInput, ReferenceInputProps, ReferenceManyField, ReferenceManyFieldProps, ReferenceOneField, ReferenceOneFieldProps, RefreshButton, RefreshButtonProps, RefreshIconButton, RefreshIconButtonProps, RemoveItemButton, RemoveSavedQueryDialog, RemoveSavedQueryDialogProps, RemoveSavedQueryIconButton, ResettableTextField, ResettableTextFieldClasses, ResettableTextFieldProps, ResettableTextFieldStyles, RichTextField, RichTextFieldProps, RowClickFunction, SaveButton, SaveButtonProps, SavedQueriesList, SavedQueriesListClasses, SavedQueriesListProps, SavedQuery, SavedQueryFilterListItem, SavedQueryFilterListItemClasses, SavedQueryFilterListItemProps, SearchInput, SearchInputProps, SelectArrayInput, SelectArrayInputClasses, SelectArrayInputProps, SelectField, SelectFieldProps, SelectInput, SelectInputProps, Show, ShowActions, ShowActionsProps, PureShowButton as ShowButton, ShowButtonProps, ShowClasses, ShowGuesser, ShowProps, ShowView, ShowViewProps, Sidebar, SidebarClasses, SidebarProps, SidebarToggleButton, SidebarToggleButtonClasses, SidebarToggleButtonProps, SimpleForm, SimpleFormIterator, SimpleFormIteratorClasses, SimpleFormIteratorContext, SimpleFormIteratorContextValue, SimpleFormIteratorItem, SimpleFormIteratorItemContext, SimpleFormIteratorItemContextValue, SimpleFormIteratorItemProps, SimpleFormIteratorPrefix, SimpleFormIteratorProps, SimpleFormProps, SimpleList, SimpleListClasses, SimpleListLoading, SimpleListLoadingClasses, SimpleListProps, SimpleShowLayout, SimpleShowLayoutClasses, SimpleShowLayoutProps, SingleFieldList, SingleFieldListClasses, SingleFieldListProps, SkipNavigationButton, _default$3 as SortButton, SortButtonProps, SupportCreateSuggestionOptions, Tab, TabProps, TabbedForm, TabbedFormClasses, TabbedFormProps, TabbedFormTabs, TabbedFormTabsProps, TabbedFormView, TabbedFormViewProps, TabbedShowLayout, TabbedShowLayoutClasses, TabbedShowLayoutProps, TabbedShowLayoutTabs, TabbedShowLayoutTabsProps, TextField, TextFieldProps, TextInput, TextInputProps, ThemeProvider, ThemeProviderProps, ThemeSetter, Title, TitlePropType, TitleProps, ToggleThemeButton, ToggleThemeButtonProps, Toolbar, ToolbarClasses, ToolbarProps, TopToolbar, TranslatableFields, TranslatableFieldsProps, TranslatableFieldsTab, TranslatableFieldsTabContent, TranslatableFieldsTabContentProps, TranslatableFieldsTabProps, TranslatableInputs, TranslatableInputsProps, TranslatableInputsTab, TranslatableInputsTabClasses, TranslatableInputsTabContent, TranslatableInputsTabContentClasses, TranslatableInputsTabContentProps, TranslatableInputsTabProps, TranslatableInputsTabs, TranslatableInputsTabsClasses, TranslatableInputsTabsProps, UrlField, UrlFieldProps, UseSupportCreateValue, UserMenu, UserMenuClasses, UserMenuContext, UserMenuContextValue, UserMenuProps, WrapperField, WrapperFieldProps, areValidSavedQueries, defaultTheme, editFieldTypes, extractValidSavedQueries, findTabsWithErrors, getArrayInputError, getFilterFormValues, getShowLayoutTabFullPath, getTabbedFormTabFullPath, isValidSavedQuery, listFieldTypes, mergeInitialValuesWithDefaultValues, removeTags, sanitizeButtonRestProps, sanitizeFieldRestProps, sanitizeInputRestProps, showFieldTypes, useArrayInput, useCreateSuggestionContext, useResetErrorBoundaryOnLocationChange, useSavedQueries, useSidebarState, useSidebarStateResult, useSimpleFormIterator, useSimpleFormIteratorItem, useSupportCreateSuggestion, useTheme, useUserMenu };
