{"ast":null,"code":"import inflection from 'inflection';\n/**\n * Returns an array of arguments to use with the translate function for the label of a field.\n * The label will be the one specified by the label prop or one computed from the resource and source props.\n *\n * Usage:\n *  <span>\n *      {translate(...getFieldLabelTranslationArgs({ label, resource, source }))}\n *  </span>\n *\n * @see useTranslateLabel for a ready-to-use hook\n */\nexport default (function (options) {\n  if (!options) return [''];\n  var label = options.label,\n    prefix = options.prefix,\n    resource = options.resource,\n    resourceFromContext = options.resourceFromContext,\n    source = options.source;\n  if (typeof label !== 'undefined') return [label, {\n    _: label\n  }];\n  if (typeof source === 'undefined') return [''];\n  var _a = getSourceParts(source),\n    sourceWithoutDigits = _a.sourceWithoutDigits,\n    sourceSuffix = _a.sourceSuffix;\n  var defaultLabel = inflection.transform(sourceSuffix.replace(/\\./g, ' '), ['underscore', 'humanize']);\n  if (resource) {\n    return [\"resources.\".concat(resource, \".fields.\").concat(sourceWithoutDigits), {\n      _: defaultLabel\n    }];\n  }\n  if (prefix) {\n    return [\"\".concat(prefix, \".\").concat(sourceWithoutDigits), {\n      _: defaultLabel\n    }];\n  }\n  return [\"resources.\".concat(resourceFromContext, \".fields.\").concat(sourceWithoutDigits), {\n    _: defaultLabel\n  }];\n});\n/**\n * Uses the source string to guess a translation message and a default label.\n *\n * @example\n * getSourceParts('pictures') // { sourceWithoutDigits: 'pictures', sourceSuffix: 'pictures' }\n * getSourceParts('pictures.url') // { sourceWithoutDigits: 'pictures.url', sourceSuffix: 'pictures.url' }\n * getSourceParts('pictures.0.url') // { sourceWithoutDigits: 'pictures.url', sourceSuffix: 'url' }\n * getSourceParts('pictures.12.urls.5.protocol') // { sourceWithoutDigits: 'pictures.urls.protocol', sourceSuffix: 'protocol' }\n */\nvar getSourceParts = function (source) {\n  // remove digits, e.g. 'book.authors.2.categories.3.identifier.name' => 'book.authors.categories.identifier.name'\n  var sourceWithoutDigits = source.replace(/\\.\\d+\\./g, '.');\n  // get final part, e.g. 'book.authors.2.categories.3.identifier.name' => 'identifier.name'\n  // we're not using a regexp here to avoid code sacnning alert \"Polynomial regular expression used on uncontrolled data\"\n  var parts = source.split('.');\n  var lastPartWithDigits;\n  parts.forEach(function (part, index) {\n    if (onlyDigits(part)) {\n      lastPartWithDigits = index;\n    }\n  });\n  var sourceSuffix = lastPartWithDigits != null ? parts.slice(lastPartWithDigits + 1).join('.') : source;\n  return {\n    sourceWithoutDigits: sourceWithoutDigits,\n    sourceSuffix: sourceSuffix\n  };\n};\n// 48 and 57 are the char codes for \"0\" and \"9\", respectively\nvar onlyDigits = function (s) {\n  for (var i = s.length - 1; i >= 0; i--) {\n    var d = s.charCodeAt(i);\n    if (d < 48 || d > 57) return false;\n  }\n  return true;\n};","map":{"version":3,"mappings":"AAAA,OAAOA,UAAU,MAAM,YAAY;AAYnC;;;;;;;;;;;AAWA,gBAAe,UAACC,OAAc;EAC1B,IAAI,CAACA,OAAO,EAAE,OAAO,CAAC,EAAE,CAAC;EAEjB,SAAK,GAAoDA,OAAO,MAA3D;IAAEC,MAAM,GAA4CD,OAAO,OAAnD;IAAEE,QAAQ,GAAkCF,OAAO,SAAzC;IAAEG,mBAAmB,GAAaH,OAAO,oBAApB;IAAEI,MAAM,GAAKJ,OAAO,OAAZ;EAE5D,IAAI,OAAOK,KAAK,KAAK,WAAW,EAAE,OAAO,CAACA,KAAK,EAAE;IAAEC,CAAC,EAAED;EAAK,CAAE,CAAC;EAE9D,IAAI,OAAOD,MAAM,KAAK,WAAW,EAAE,OAAO,CAAC,EAAE,CAAC;EAExC,SAAwCG,cAAc,CAACH,MAAM,CAAC;IAA5DI,mBAAmB;IAAEC,YAAY,kBAA2B;EAEpE,IAAMC,YAAY,GAAGX,UAAU,CAACY,SAAS,CACrCF,YAAY,CAACG,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,EAChC,CAAC,YAAY,EAAE,UAAU,CAAC,CAC7B;EAED,IAAIV,QAAQ,EAAE;IACV,OAAO,CACH,oBAAaA,QAAQ,qBAAWM,mBAAmB,CAAE,EACrD;MAAEF,CAAC,EAAEI;IAAY,CAAE,CACtB;;EAGL,IAAIT,MAAM,EAAE;IACR,OAAO,CAAC,UAAGA,MAAM,cAAIO,mBAAmB,CAAE,EAAE;MAAEF,CAAC,EAAEI;IAAY,CAAE,CAAC;;EAGpE,OAAO,CACH,oBAAaP,mBAAmB,qBAAWK,mBAAmB,CAAE,EAChE;IAAEF,CAAC,EAAEI;EAAY,CAAE,CACtB;AACL,CAAC;AAED;;;;;;;;;AASA,IAAMH,cAAc,GAAG,UAACH,MAAc;EAClC;EACA,IAAMI,mBAAmB,GAAGJ,MAAM,CAACQ,OAAO,CAAC,UAAU,EAAE,GAAG,CAAC;EAC3D;EACA;EACA,IAAMC,KAAK,GAAGT,MAAM,CAACU,KAAK,CAAC,GAAG,CAAC;EAC/B,IAAIC,kBAAkB;EACtBF,KAAK,CAACG,OAAO,CAAC,UAACC,IAAI,EAAEC,KAAK;IACtB,IAAIC,UAAU,CAACF,IAAI,CAAC,EAAE;MAClBF,kBAAkB,GAAGG,KAAK;;EAElC,CAAC,CAAC;EACF,IAAMT,YAAY,GACdM,kBAAkB,IAAI,IAAI,GACpBF,KAAK,CAACO,KAAK,CAACL,kBAAkB,GAAG,CAAC,CAAC,CAACM,IAAI,CAAC,GAAG,CAAC,GAC7CjB,MAAM;EAEhB,OAAO;IAAEI,mBAAmB;IAAEC,YAAY;EAAA,CAAE;AAChD,CAAC;AAED;AACA,IAAMU,UAAU,GAAG,WAAC;EAChB,KAAK,IAAIG,CAAC,GAAGC,CAAC,CAACC,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IACpC,IAAMG,CAAC,GAAGF,CAAC,CAACG,UAAU,CAACJ,CAAC,CAAC;IACzB,IAAIG,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,EAAE,EAAE,OAAO,KAAK;;EAEtC,OAAO,IAAI;AACf,CAAC","names":["inflection","options","prefix","resource","resourceFromContext","source","label","_","getSourceParts","sourceWithoutDigits","sourceSuffix","defaultLabel","transform","replace","parts","split","lastPartWithDigits","forEach","part","index","onlyDigits","slice","join","i","s","length","d","charCodeAt"],"sources":["/Users/paigedeveau/Desktop/se-diva-docs-frontend/bwmdn-admin-portal/node_modules/ra-core/src/util/getFieldLabelTranslationArgs.ts"],"sourcesContent":["import inflection from 'inflection';\n\ninterface Args {\n    label?: string;\n    prefix?: string;\n    resource?: string;\n    resourceFromContext?: string;\n    source?: string;\n}\n\ntype TranslationArguments = [string, any?];\n\n/**\n * Returns an array of arguments to use with the translate function for the label of a field.\n * The label will be the one specified by the label prop or one computed from the resource and source props.\n *\n * Usage:\n *  <span>\n *      {translate(...getFieldLabelTranslationArgs({ label, resource, source }))}\n *  </span>\n *\n * @see useTranslateLabel for a ready-to-use hook\n */\nexport default (options?: Args): TranslationArguments => {\n    if (!options) return [''];\n\n    const { label, prefix, resource, resourceFromContext, source } = options;\n\n    if (typeof label !== 'undefined') return [label, { _: label }];\n\n    if (typeof source === 'undefined') return [''];\n\n    const { sourceWithoutDigits, sourceSuffix } = getSourceParts(source);\n\n    const defaultLabel = inflection.transform(\n        sourceSuffix.replace(/\\./g, ' '),\n        ['underscore', 'humanize']\n    );\n\n    if (resource) {\n        return [\n            `resources.${resource}.fields.${sourceWithoutDigits}`,\n            { _: defaultLabel },\n        ];\n    }\n\n    if (prefix) {\n        return [`${prefix}.${sourceWithoutDigits}`, { _: defaultLabel }];\n    }\n\n    return [\n        `resources.${resourceFromContext}.fields.${sourceWithoutDigits}`,\n        { _: defaultLabel },\n    ];\n};\n\n/**\n * Uses the source string to guess a translation message and a default label.\n *\n * @example\n * getSourceParts('pictures') // { sourceWithoutDigits: 'pictures', sourceSuffix: 'pictures' }\n * getSourceParts('pictures.url') // { sourceWithoutDigits: 'pictures.url', sourceSuffix: 'pictures.url' }\n * getSourceParts('pictures.0.url') // { sourceWithoutDigits: 'pictures.url', sourceSuffix: 'url' }\n * getSourceParts('pictures.12.urls.5.protocol') // { sourceWithoutDigits: 'pictures.urls.protocol', sourceSuffix: 'protocol' }\n */\nconst getSourceParts = (source: string) => {\n    // remove digits, e.g. 'book.authors.2.categories.3.identifier.name' => 'book.authors.categories.identifier.name'\n    const sourceWithoutDigits = source.replace(/\\.\\d+\\./g, '.');\n    // get final part, e.g. 'book.authors.2.categories.3.identifier.name' => 'identifier.name'\n    // we're not using a regexp here to avoid code sacnning alert \"Polynomial regular expression used on uncontrolled data\"\n    const parts = source.split('.');\n    let lastPartWithDigits;\n    parts.forEach((part, index) => {\n        if (onlyDigits(part)) {\n            lastPartWithDigits = index;\n        }\n    });\n    const sourceSuffix =\n        lastPartWithDigits != null\n            ? parts.slice(lastPartWithDigits + 1).join('.')\n            : source;\n\n    return { sourceWithoutDigits, sourceSuffix };\n};\n\n// 48 and 57 are the char codes for \"0\" and \"9\", respectively\nconst onlyDigits = s => {\n    for (let i = s.length - 1; i >= 0; i--) {\n        const d = s.charCodeAt(i);\n        if (d < 48 || d > 57) return false;\n    }\n    return true;\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}