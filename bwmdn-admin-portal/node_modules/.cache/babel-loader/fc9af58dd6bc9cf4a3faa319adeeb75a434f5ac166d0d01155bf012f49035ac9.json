{"ast":null,"code":"import lodashMemoize from 'lodash/memoize';\n/* eslint-disable no-underscore-dangle */\n/* @link http://stackoverflow.com/questions/46155/validate-email-address-in-javascript */\nvar EMAIL_REGEX = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; // eslint-disable-line no-useless-escape\nvar isEmpty = function (value) {\n  return typeof value === 'undefined' || value === null || value === '' || Array.isArray(value) && value.length === 0;\n};\n// type predicate, see https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates\nfunction isValidationErrorMessageWithArgs(error) {\n  return error ? error.hasOwnProperty('message') : false;\n}\nvar getMessage = function (message, messageArgs, value, values) {\n  return typeof message === 'function' ? message({\n    args: messageArgs,\n    value: value,\n    values: values\n  }) : messageArgs ? {\n    message: message,\n    args: messageArgs\n  } : message;\n};\n// If we define validation functions directly in JSX, it will\n// result in a new function at every render, and then trigger infinite re-render.\n// Hence, we memoize every built-in validator to prevent a \"Maximum call stack\" error.\nvar memoize = function (fn) {\n  return lodashMemoize(fn, function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return JSON.stringify(args);\n  });\n};\nvar isFunction = function (value) {\n  return typeof value === 'function';\n};\nexport var combine2Validators = function (validator1, validator2) {\n  return function (value, values, meta) {\n    var result1 = validator1(value, values, meta);\n    if (!result1) {\n      return validator2(value, values, meta);\n    }\n    if (typeof result1 === 'string' || isValidationErrorMessageWithArgs(result1)) {\n      return result1;\n    }\n    return result1.then(function (resolvedResult1) {\n      if (!resolvedResult1) {\n        return validator2(value, values, meta);\n      }\n      return resolvedResult1;\n    });\n  };\n};\n// Compose multiple validators into a single one for use with react-hook-form\nexport var composeValidators = function () {\n  var validators = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    validators[_i] = arguments[_i];\n  }\n  var allValidators = (Array.isArray(validators[0]) ? validators[0] : validators).filter(isFunction);\n  return allValidators.reduce(combine2Validators, function () {\n    return null;\n  });\n};\n// Compose multiple validators into a single one for use with react-hook-form\nexport var composeSyncValidators = function () {\n  var validators = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    validators[_i] = arguments[_i];\n  }\n  return function (value, values, meta) {\n    var allValidators = (Array.isArray(validators[0]) ? validators[0] : validators).filter(isFunction);\n    for (var _i = 0, allValidators_1 = allValidators; _i < allValidators_1.length; _i++) {\n      var validator = allValidators_1[_i];\n      var error = validator(value, values, meta);\n      if (error) {\n        return error;\n      }\n    }\n  };\n};\n/**\n * Required validator\n *\n * Returns an error if the value is null, undefined, or empty\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const titleValidators = [required('The title is required')];\n * <TextInput name=\"title\" validate={titleValidators} />\n */\nexport var required = memoize(function (message) {\n  if (message === void 0) {\n    message = 'ra.validation.required';\n  }\n  return Object.assign(function (value, values) {\n    return isEmpty(value) ? getMessage(message, undefined, value, values) : undefined;\n  }, {\n    isRequired: true\n  });\n});\n/**\n * Minimum length validator\n *\n * Returns an error if the value has a length less than the parameter\n *\n * @param {integer} min\n * @param {string|Function} message\n *\n * @example\n *\n * const passwordValidators = [minLength(10, 'Should be at least 10 characters')];\n * <TextInput type=\"password\" name=\"password\" validate={passwordValidators} />\n */\nexport var minLength = memoize(function (min, message) {\n  if (message === void 0) {\n    message = 'ra.validation.minLength';\n  }\n  return function (value, values) {\n    return !isEmpty(value) && value.length < min ? getMessage(message, {\n      min: min\n    }, value, values) : undefined;\n  };\n});\n/**\n * Maximum length validator\n *\n * Returns an error if the value has a length higher than the parameter\n *\n * @param {integer} max\n * @param {string|Function} message\n *\n * @example\n *\n * const nameValidators = [maxLength(10, 'Should be at most 10 characters')];\n * <TextInput name=\"name\" validate={nameValidators} />\n */\nexport var maxLength = memoize(function (max, message) {\n  if (message === void 0) {\n    message = 'ra.validation.maxLength';\n  }\n  return function (value, values) {\n    return !isEmpty(value) && value.length > max ? getMessage(message, {\n      max: max\n    }, value, values) : undefined;\n  };\n});\n/**\n * Minimum validator\n *\n * Returns an error if the value is less than the parameter\n *\n * @param {integer} min\n * @param {string|Function} message\n *\n * @example\n *\n * const fooValidators = [minValue(5, 'Should be more than 5')];\n * <NumberInput name=\"foo\" validate={fooValidators} />\n */\nexport var minValue = memoize(function (min, message) {\n  if (message === void 0) {\n    message = 'ra.validation.minValue';\n  }\n  return function (value, values) {\n    return !isEmpty(value) && value < min ? getMessage(message, {\n      min: min\n    }, value, values) : undefined;\n  };\n});\n/**\n * Maximum validator\n *\n * Returns an error if the value is higher than the parameter\n *\n * @param {integer} max\n * @param {string|Function} message\n *\n * @example\n *\n * const fooValidators = [maxValue(10, 'Should be less than 10')];\n * <NumberInput name=\"foo\" validate={fooValidators} />\n */\nexport var maxValue = memoize(function (max, message) {\n  if (message === void 0) {\n    message = 'ra.validation.maxValue';\n  }\n  return function (value, values) {\n    return !isEmpty(value) && value > max ? getMessage(message, {\n      max: max\n    }, value, values) : undefined;\n  };\n});\n/**\n * Number validator\n *\n * Returns an error if the value is not a number\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const ageValidators = [number('Must be a number')];\n * <TextInput name=\"age\" validate={ageValidators} />\n */\nexport var number = memoize(function (message) {\n  if (message === void 0) {\n    message = 'ra.validation.number';\n  }\n  return function (value, values) {\n    return !isEmpty(value) && isNaN(Number(value)) ? getMessage(message, undefined, value, values) : undefined;\n  };\n});\n/**\n * Regular expression validator\n *\n * Returns an error if the value does not match the pattern given as parameter\n *\n * @param {RegExp} pattern\n * @param {string|Function} message\n *\n * @example\n *\n * const zipValidators = [regex(/^\\d{5}(?:[-\\s]\\d{4})?$/, 'Must be a zip code')];\n * <TextInput name=\"zip\" validate={zipValidators} />\n */\nexport var regex = lodashMemoize(function (pattern, message) {\n  if (message === void 0) {\n    message = 'ra.validation.regex';\n  }\n  return function (value, values) {\n    return !isEmpty(value) && typeof value === 'string' && !pattern.test(value) ? getMessage(message, {\n      pattern: pattern\n    }, value, values) : undefined;\n  };\n}, function (pattern, message) {\n  return pattern.toString() + message;\n});\n/**\n * Email validator\n *\n * Returns an error if the value is not a valid email\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const emailValidators = [email('Must be an email')];\n * <TextInput name=\"email\" validate={emailValidators} />\n */\nexport var email = memoize(function (message) {\n  if (message === void 0) {\n    message = 'ra.validation.email';\n  }\n  return regex(EMAIL_REGEX, message);\n});\nvar oneOfTypeMessage = function (_a) {\n  var args = _a.args;\n  return {\n    message: 'ra.validation.oneOf',\n    args: args\n  };\n};\n/**\n * Choices validator\n *\n * Returns an error if the value is not among the list passed as parameter\n *\n * @param {array} list\n * @param {string|Function} message\n *\n * @example\n *\n * const genderValidators = [choices(['male', 'female'], 'Must be either Male or Female')];\n * <TextInput name=\"gender\" validate={genderValidators} />\n */\nexport var choices = memoize(function (list, message) {\n  if (message === void 0) {\n    message = oneOfTypeMessage;\n  }\n  return function (value, values) {\n    return !isEmpty(value) && list.indexOf(value) === -1 ? getMessage(message, {\n      list: list\n    }, value, values) : undefined;\n  };\n});\n/**\n * Given a validator, returns a boolean indicating whether the field is required or not.\n */\nexport var isRequired = function (validate) {\n  if (validate && validate.isRequired) {\n    return true;\n  }\n  if (Array.isArray(validate)) {\n    return !!validate.find(function (it) {\n      return it.isRequired;\n    });\n  }\n  return false;\n};","map":{"version":3,"mappings":"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","names":["lodashMemoize","EMAIL_REGEX","isEmpty","value","Array","isArray","length","isValidationErrorMessageWithArgs","error","hasOwnProperty","getMessage","message","messageArgs","values","args","memoize","fn","_i","stringify","isFunction","combine2Validators","validator1","validator2","meta","result1","then","resolvedResult1","composeValidators","validators","allValidators","filter","reduce","composeSyncValidators","allValidators_1","validator","required","assign","undefined","isRequired","minLength","min","maxLength","max","minValue","maxValue","number","isNaN","Number","regex","pattern","test","toString","email","oneOfTypeMessage","_a","choices","list","indexOf","validate","find"],"sources":["/Users/paigedeveau/node_modules/ra-core/src/form/validate.ts"],"sourcesContent":["import lodashMemoize from 'lodash/memoize';\n\n/* eslint-disable no-underscore-dangle */\n/* @link http://stackoverflow.com/questions/46155/validate-email-address-in-javascript */\nconst EMAIL_REGEX = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; // eslint-disable-line no-useless-escape\n\nconst isEmpty = (value: any) =>\n    typeof value === 'undefined' ||\n    value === null ||\n    value === '' ||\n    (Array.isArray(value) && value.length === 0);\n\nexport interface ValidationErrorMessageWithArgs {\n    message: string;\n    args: {\n        [key: string]: ValidationErrorMessageWithArgs | any;\n    };\n}\n\nexport type ValidationErrorMessage = string | ValidationErrorMessageWithArgs;\n\nexport type Validator = (\n    value: any,\n    values: any,\n    props: any\n) =>\n    | ValidationErrorMessage\n    | null\n    | undefined\n    | Promise<ValidationErrorMessage | null | undefined>;\n\n// type predicate, see https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates\nfunction isValidationErrorMessageWithArgs(\n    error: ReturnType<Validator>\n): error is ValidationErrorMessageWithArgs {\n    return error ? error.hasOwnProperty('message') : false;\n}\n\ninterface MessageFuncParams {\n    args: any;\n    value: any;\n    values: any;\n}\n\ntype MessageFunc = (params: MessageFuncParams) => ValidationErrorMessage;\n\nconst getMessage = (\n    message: string | MessageFunc,\n    messageArgs: any,\n    value: any,\n    values: any\n) =>\n    typeof message === 'function'\n        ? message({\n              args: messageArgs,\n              value,\n              values,\n          })\n        : messageArgs\n        ? {\n              message,\n              args: messageArgs,\n          }\n        : message;\n\ntype Memoize = <T extends (...args: any[]) => any>(\n    func: T,\n    resolver?: (...args: any[]) => any\n) => T;\n\n// If we define validation functions directly in JSX, it will\n// result in a new function at every render, and then trigger infinite re-render.\n// Hence, we memoize every built-in validator to prevent a \"Maximum call stack\" error.\nconst memoize: Memoize = (fn: any) =>\n    lodashMemoize(fn, (...args) => JSON.stringify(args));\n\nconst isFunction = value => typeof value === 'function';\n\nexport const combine2Validators = (\n    validator1: Validator,\n    validator2: Validator\n): Validator => {\n    return (value, values, meta) => {\n        const result1 = validator1(value, values, meta);\n        if (!result1) {\n            return validator2(value, values, meta);\n        }\n        if (\n            typeof result1 === 'string' ||\n            isValidationErrorMessageWithArgs(result1)\n        ) {\n            return result1;\n        }\n\n        return result1.then(resolvedResult1 => {\n            if (!resolvedResult1) {\n                return validator2(value, values, meta);\n            }\n            return resolvedResult1;\n        });\n    };\n};\n\n// Compose multiple validators into a single one for use with react-hook-form\nexport const composeValidators = (...validators) => {\n    const allValidators = (Array.isArray(validators[0])\n        ? validators[0]\n        : validators\n    ).filter(isFunction) as Validator[];\n    return allValidators.reduce(combine2Validators, () => null);\n};\n\n// Compose multiple validators into a single one for use with react-hook-form\nexport const composeSyncValidators = (...validators) => (\n    value,\n    values,\n    meta\n) => {\n    const allValidators = (Array.isArray(validators[0])\n        ? validators[0]\n        : validators\n    ).filter(isFunction) as Validator[];\n\n    for (const validator of allValidators) {\n        const error = validator(value, values, meta);\n\n        if (error) {\n            return error;\n        }\n    }\n};\n\n/**\n * Required validator\n *\n * Returns an error if the value is null, undefined, or empty\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const titleValidators = [required('The title is required')];\n * <TextInput name=\"title\" validate={titleValidators} />\n */\nexport const required = memoize((message = 'ra.validation.required') =>\n    Object.assign(\n        (value, values) =>\n            isEmpty(value)\n                ? getMessage(message, undefined, value, values)\n                : undefined,\n        { isRequired: true }\n    )\n);\n\n/**\n * Minimum length validator\n *\n * Returns an error if the value has a length less than the parameter\n *\n * @param {integer} min\n * @param {string|Function} message\n *\n * @example\n *\n * const passwordValidators = [minLength(10, 'Should be at least 10 characters')];\n * <TextInput type=\"password\" name=\"password\" validate={passwordValidators} />\n */\nexport const minLength = memoize(\n    (min, message = 'ra.validation.minLength') => (value, values) =>\n        !isEmpty(value) && value.length < min\n            ? getMessage(message, { min }, value, values)\n            : undefined\n);\n\n/**\n * Maximum length validator\n *\n * Returns an error if the value has a length higher than the parameter\n *\n * @param {integer} max\n * @param {string|Function} message\n *\n * @example\n *\n * const nameValidators = [maxLength(10, 'Should be at most 10 characters')];\n * <TextInput name=\"name\" validate={nameValidators} />\n */\nexport const maxLength = memoize(\n    (max, message = 'ra.validation.maxLength') => (value, values) =>\n        !isEmpty(value) && value.length > max\n            ? getMessage(message, { max }, value, values)\n            : undefined\n);\n\n/**\n * Minimum validator\n *\n * Returns an error if the value is less than the parameter\n *\n * @param {integer} min\n * @param {string|Function} message\n *\n * @example\n *\n * const fooValidators = [minValue(5, 'Should be more than 5')];\n * <NumberInput name=\"foo\" validate={fooValidators} />\n */\nexport const minValue = memoize(\n    (min, message = 'ra.validation.minValue') => (value, values) =>\n        !isEmpty(value) && value < min\n            ? getMessage(message, { min }, value, values)\n            : undefined\n);\n\n/**\n * Maximum validator\n *\n * Returns an error if the value is higher than the parameter\n *\n * @param {integer} max\n * @param {string|Function} message\n *\n * @example\n *\n * const fooValidators = [maxValue(10, 'Should be less than 10')];\n * <NumberInput name=\"foo\" validate={fooValidators} />\n */\nexport const maxValue = memoize(\n    (max, message = 'ra.validation.maxValue') => (value, values) =>\n        !isEmpty(value) && value > max\n            ? getMessage(message, { max }, value, values)\n            : undefined\n);\n\n/**\n * Number validator\n *\n * Returns an error if the value is not a number\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const ageValidators = [number('Must be a number')];\n * <TextInput name=\"age\" validate={ageValidators} />\n */\nexport const number = memoize(\n    (message = 'ra.validation.number') => (value, values) =>\n        !isEmpty(value) && isNaN(Number(value))\n            ? getMessage(message, undefined, value, values)\n            : undefined\n);\n\n/**\n * Regular expression validator\n *\n * Returns an error if the value does not match the pattern given as parameter\n *\n * @param {RegExp} pattern\n * @param {string|Function} message\n *\n * @example\n *\n * const zipValidators = [regex(/^\\d{5}(?:[-\\s]\\d{4})?$/, 'Must be a zip code')];\n * <TextInput name=\"zip\" validate={zipValidators} />\n */\nexport const regex = lodashMemoize(\n    (pattern, message = 'ra.validation.regex') => (value, values?) =>\n        !isEmpty(value) && typeof value === 'string' && !pattern.test(value)\n            ? getMessage(message, { pattern }, value, values)\n            : undefined,\n    (pattern, message) => {\n        return pattern.toString() + message;\n    }\n);\n\n/**\n * Email validator\n *\n * Returns an error if the value is not a valid email\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const emailValidators = [email('Must be an email')];\n * <TextInput name=\"email\" validate={emailValidators} />\n */\nexport const email = memoize((message = 'ra.validation.email') =>\n    regex(EMAIL_REGEX, message)\n);\n\nconst oneOfTypeMessage: MessageFunc = ({ args }) => ({\n    message: 'ra.validation.oneOf',\n    args,\n});\n\n/**\n * Choices validator\n *\n * Returns an error if the value is not among the list passed as parameter\n *\n * @param {array} list\n * @param {string|Function} message\n *\n * @example\n *\n * const genderValidators = [choices(['male', 'female'], 'Must be either Male or Female')];\n * <TextInput name=\"gender\" validate={genderValidators} />\n */\nexport const choices = memoize(\n    (list, message = oneOfTypeMessage) => (value, values) =>\n        !isEmpty(value) && list.indexOf(value) === -1\n            ? getMessage(message, { list }, value, values)\n            : undefined\n);\n\n/**\n * Given a validator, returns a boolean indicating whether the field is required or not.\n */\nexport const isRequired = validate => {\n    if (validate && validate.isRequired) {\n        return true;\n    }\n    if (Array.isArray(validate)) {\n        return !!validate.find(it => it.isRequired);\n    }\n    return false;\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}